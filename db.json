{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1644834141231},{"_id":"source/about/index.md","hash":"8a775329955da78b31522af1f1a777b8e4e7df05","modified":1644834141232},{"_id":"source/tags/index.md","hash":"86e3581b559b1e293be07bd6c36b03ee8005306c","modified":1644834141232},{"_id":"source/categories/index.md","hash":"229e0726ec97f0b4f892ba1f1f927731f0a503bb","modified":1644834141232},{"_id":"source/_posts/Angular/angular-04.md","hash":"77cc1db5154b978d9d87c64a4292588bf1248985","modified":1644909368547},{"_id":"source/_posts/Angular/angular-01.md","hash":"dfdcbe49c125eebef3196aa76bfddba29ada1b24","modified":1644909378385},{"_id":"source/_posts/Angular/angular-02.md","hash":"eb99269aa403ec66d5763793a3be5391ec46479c","modified":1644909375545},{"_id":"source/_posts/Angular/angular-03.md","hash":"9beec1848be94481db4b5f11ce4a07b57cbcf971","modified":1644909372369},{"_id":"source/_posts/Angular/angular-06.md","hash":"1ba4d52f3351957cecec521c7b0a7601f16da5a6","modified":1644920152477},{"_id":"source/_posts/Angular/angular-08.md","hash":"d25f6b225840a7b7fa2608a3f15690c793349099","modified":1644913161450},{"_id":"source/_posts/Angular/angular-05.md","hash":"ace7b96c1e569f7c1e1bb456db0968f599d070b3","modified":1644910072680},{"_id":"source/_posts/Angular/angular-07.md","hash":"44e49ed30db9842952a0743ee3ef19f5762f1ab6","modified":1644912701302},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"0a1212a43ef3ffaa7d6986534469bcd58512d4bd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/package.json","hash":"08086a270d50410afc8f6a78dd23e95b1a6485ba","modified":1644831637996},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":499162500000},{"_id":"node_modules/hexo-theme-next/README.md","hash":"fab15a85d9d8d90ecd8879525b9b74fb1c197978","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"70b90f7f66989ee9bbd4b117fbd69e586f199c85","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"b5e2a35eb6fff56b6e32ce479e63b6fc5e44d5cb","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"1ce12eda88fa5df7e76ec7b78b8463fc6618410c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"3abdcb715562414063e0fb3eeb6244ce59c477e0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"a2ae21ec522c9afd2a8c70f660a586ed0d8b97dc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"02bafc6ee86263790603861e356596f0c916e392","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"ab8bb12e4d55640b1ac4252514468ce37ebcb0b0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"87edab5a3eb7577a409c01df3f1631de40f8956f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"d0ed41b9b05254e19d051b5f91fdcaa125ee7ca6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"299664182f502447c07301461db99bfd6993fdac","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"672dce0632af589b7fe47fa45c2094fa013885f7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"8561e4125b227e5134cb058e2a76fb2e5233ca29","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"0682a52927c331eee17f190984ec3b25ee84f305","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"e447160d342b1f93df5214b6a733441039ced439","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"45477a04cf2b3c077061c8c3ada216c1ae288e0e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"09ffc0b1175e9c11b9329cf8b398123418d7b0eb","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"9a836d2bcc3defe4bd1ee51f5f4eb7006ebdd41b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"9b34143aec49e390e18f380026a45096f7477722","modified":499162500000},{"_id":"source/_posts/Angular/angular-12.md","hash":"a53ed2c680b6d0415aca5c4e9276a0431cc6c3fd","modified":1644974439682},{"_id":"source/_posts/Angular/angular-09.md","hash":"729bbd279fbd6fe63401810cab4c46a907aba1a2","modified":1644913235438},{"_id":"source/_posts/Angular/angular-10.md","hash":"7fe3b4ba8a06176aa3d001010d68190135cafc60","modified":1644919935197},{"_id":"source/_posts/Angular/angular-11.md","hash":"6972b275468055f8c86da00f59d97359ac5eefdb","modified":1644920355277}],"Category":[{"name":"2021 鐵人賽","_id":"ckznurmng0006kww3cwxhe6la"}],"Data":[],"Page":[{"title":"about","date":"2022-02-14T09:49:34.000Z","type":"abou——————————t","_content":"\nHi 我是 Fandix，我是一位全端工程師...吧？ \n\n目前在一間軟體公司擔任前端工程師的職位，但由於工作需求也需要會寫後端，所以勉強算是半個全端工程師吧。\n\n我喜歡不斷的學習新的技能，對於接觸到新的事物來說會讓我很興奮，所以會將自己所找的所學的寫在這個 Blog 中希望可以幫助到剛好也在學習某一個技能的夥伴們。\n\n我使用 Javascrpt 開發前端到現在已經快 2 年了，主要使用 Angular 這個前端框架，而後端則是使用 NodeJS Express 作為後端開發。","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-02-14 17:49:34\ntype: \"abou——————————t\"\n---\n\nHi 我是 Fandix，我是一位全端工程師...吧？ \n\n目前在一間軟體公司擔任前端工程師的職位，但由於工作需求也需要會寫後端，所以勉強算是半個全端工程師吧。\n\n我喜歡不斷的學習新的技能，對於接觸到新的事物來說會讓我很興奮，所以會將自己所找的所學的寫在這個 Blog 中希望可以幫助到剛好也在學習某一個技能的夥伴們。\n\n我使用 Javascrpt 開發前端到現在已經快 2 年了，主要使用 Angular 這個前端框架，而後端則是使用 NodeJS Express 作為後端開發。","updated":"2022-02-14T10:22:21.232Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckznurmn70000kww39qafcdc0","content":"<p>Hi 我是 Fandix，我是一位全端工程師…吧？ </p>\n<p>目前在一間軟體公司擔任前端工程師的職位，但由於工作需求也需要會寫後端，所以勉強算是半個全端工程師吧。</p>\n<p>我喜歡不斷的學習新的技能，對於接觸到新的事物來說會讓我很興奮，所以會將自己所找的所學的寫在這個 Blog 中希望可以幫助到剛好也在學習某一個技能的夥伴們。</p>\n<p>我使用 Javascrpt 開發前端到現在已經快 2 年了，主要使用 Angular 這個前端框架，而後端則是使用 NodeJS Express 作為後端開發。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Hi 我是 Fandix，我是一位全端工程師…吧？ </p>\n<p>目前在一間軟體公司擔任前端工程師的職位，但由於工作需求也需要會寫後端，所以勉強算是半個全端工程師吧。</p>\n<p>我喜歡不斷的學習新的技能，對於接觸到新的事物來說會讓我很興奮，所以會將自己所找的所學的寫在這個 Blog 中希望可以幫助到剛好也在學習某一個技能的夥伴們。</p>\n<p>我使用 Javascrpt 開發前端到現在已經快 2 年了，主要使用 Angular 這個前端框架，而後端則是使用 NodeJS Express 作為後端開發。</p>\n"},{"title":"categories","date":"2022-02-14T09:50:19.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-02-14 17:50:19\ntype: \"categories\"\n---\n","updated":"2022-02-14T10:22:21.232Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckznurmnc0002kww3b79j1w9x","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2022-02-14T09:50:13.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-02-14 17:50:13\ntype: \"tags\"\n---\n","updated":"2022-02-14T10:22:21.232Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckznurmne0004kww3a9f3a4i0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-02-14T10:22:21.231Z","updated":"2022-02-14T10:22:21.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmn90001kww3153a9heh","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Day1. 認識 Angular","date":"2022-02-15T02:59:36.000Z","_content":"\n在2020年9月，我正式的從韌體工程師轉職成為一位前端工程師，在自學前端的時候我是選擇了 React 這個 Javascript 框架，做了幾個作品後投履歷面試最後找到目前任職的公司，一路上跌跌撞撞但也算順利，不過唯一不太順了就是目前任職的這間公司是使用 Angular ，當初剛進到這間公司時也是從頭開始 K Angular 官方文檔，看得真的是無煞煞，現在也進到這間公司快一年了，也使用過 Angular 做了幾個專案與處理了幾個問題， 想說再次挑戰自己從頭開始認真看 Angular 官方文檔並用自己的理解整理成筆記，希望能對新進的 Angular 開發者有些幫助。\n\n![https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png](https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png)\n\n<!--more-->\n\n# What is Angular ?\n開門見山的說 Angular 是一個 `Javascript 的框架`，他是基於 `TypeScript` 進行開發的，它包括了：\n\n- 基於 Component 且用於構建 Web App 的框架\n- 他集成了許多 Library 涵蓋了多種功能，包括 Router, forms, client-server…\n- 一套開發人員工具，提供開發者開發、構建、測試與更新程式碼\n\n記得當初主管跟我分享 Angular 的好處，因為 Angular 擁有非常完整的功能，可以透過它提供的功能建立一個完整且大型的 Web App，而且就如他有\n非常完整的功能，當在面對多個開發者同時開發專案時，就會遵守共同的開發原則以減少多人開發的問題。\n\n\n\n# Angular applications: The essentials\nAngular 中有許多核心思想，了解這些核心思想對於之後的開發有非常好的幫助。\n\n## Components\nComponent 是`構建一個 Web App 的最基本方塊`，每一個 Web App 都是由一個又一個大大小小的 Component 所組成的，在之前學習 React \n的時候也是這個概念，但是 Angular 的 Component 跟 React 非常不一樣，他是一個帶有 `@Component()` 裝飾器的 TypeScript Class、\nHTML template, Style ，這邊你可能聽不懂，但沒關係現階段只要簡單記住他是一個有 TypeScript、HTML、CSS 的小方塊就好。\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hello-world',\n  template: `\n        <h2>Hello World</h2>\n        <p>This is my first component!</p>\n    `\n})\nexport class HelloWorldComponent {\n  // The code in this class drives the component's behavior.\n}\n```\n\n當你要使用這個 Component 時，只需要在 HTML 中將你要用的 selector 當作 tag 使用就好。\n\n```html\n<hello-world></hello-world>\n```\n\n## Templates\n每一個 Component 都擁有自己的 HTML template，它用於在畫面中呈現你這個 Component，當你的 Component 發生改變時 Angular 會\n自動更新並且重新渲染 DOM，他有許多非常好用的功能，比如說動態插入、事件綁定等等的，不過這個我們之後會專門講解，在這裡只要記得 Template \n是用來在 UI 上顯示 Component 內容的就可以了。\n\n## Dependency injection\nDependency injection 在 Angular 中是一個非常重要的觀念，簡單來說當你在寫一般的 JavaScript 時，你可能寫了一個 Class 裡面存放了許\n多邏輯，當你在使用的時候你可能會需要使用 new 將這個 Class 實例化成一個 Object，然後才能使用裡面的 method 或 property，這樣兩個 Class\n就產生了`依賴關係`。\n\n就「依賴」的文字意思來看，是指「一個東西需要另一個東西而存在；若沒有另外一個東西，則本身不能自立」。\n\n物件導向程式(OOP)中，程式是透過許多類別(Class)的實例(instance)，也就是物件(object)，彼此的交互組合來實現各種功能。所以依賴是指「一個物件需要另一個物件才能作用」\n\n而 DI 則是指`被依賴物件透過外部注入至依賴物件的程式中使用`，也就是被依賴物件並不是在依賴物件的程式中使用 `new` 產生而是由`外部注入`，這種注入可以透過 Class 中的\nConstructor 或 Setter 實現。\n\n詳細的內容會到後面再仔細講解什麼事 DI，目前只要記住 DI 是 Angular 的一個重要的概念，主要目的是用於將各個 Class 之間`解耦`。\n\n## Angular CLI\nAngular CLI 是開發 Angular 應用程序的最快、直接且推薦的方式，就像 React 的 create-react-app 一樣，可以透過指令快速建立出基本的 Angular app，除了建立模板之外還有非常多好用的功能，我會在下一章節中仔細講解 Angular CLI 是什麼。\n\n## First-party libraries\n就如上面所提到 Angular 擁有非常多非常完善的資源提供你創建你的 Web App，所以當你在開發過程中遇到需要添加功能時，就可以添加相對應的模組來達成你的目的。\n\n這邊簡單介紹幾個 first party libraries\n\n| Name   |      Description      |\n|----------|:-------------:|\n| Angular Router |  基於 Component 的客戶端導航與 Router，支援延遲載入、嵌套 Router、自定義路徑匹配等等 | \n| Angular Forms |    表單輸入與表單內容驗證   |\n| Angular HttpClient | 可支援 client 端與 server 端的溝通 |\n| Angular Animations | 驅動 app 動畫 |\n\n\n\n# 結論\n本篇章大概介紹了什麼是 Angular 與使用它的好處，有提到許多比較難的觀念，template 的操作與\nDependency injection 等等，現在可能看不太懂不過沒關係，我們後面會詳細講解這些是幹什麼的，當初我也是花了很多時間才大概了解他在幹嘛的 ( 苦笑。\n\n\n\n# Reference\n- [Angular.io](https://angular.io/guide/what-is-angular)","source":"_posts/Angular/angular-01.md","raw":"---\ntitle: Day1. 認識 Angular\ndate: 2022-02-15 10:59:36\ntags:\n- Angular\n- Front-end\ncategories:\n- 2021 鐵人賽\n---\n\n在2020年9月，我正式的從韌體工程師轉職成為一位前端工程師，在自學前端的時候我是選擇了 React 這個 Javascript 框架，做了幾個作品後投履歷面試最後找到目前任職的公司，一路上跌跌撞撞但也算順利，不過唯一不太順了就是目前任職的這間公司是使用 Angular ，當初剛進到這間公司時也是從頭開始 K Angular 官方文檔，看得真的是無煞煞，現在也進到這間公司快一年了，也使用過 Angular 做了幾個專案與處理了幾個問題， 想說再次挑戰自己從頭開始認真看 Angular 官方文檔並用自己的理解整理成筆記，希望能對新進的 Angular 開發者有些幫助。\n\n![https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png](https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png)\n\n<!--more-->\n\n# What is Angular ?\n開門見山的說 Angular 是一個 `Javascript 的框架`，他是基於 `TypeScript` 進行開發的，它包括了：\n\n- 基於 Component 且用於構建 Web App 的框架\n- 他集成了許多 Library 涵蓋了多種功能，包括 Router, forms, client-server…\n- 一套開發人員工具，提供開發者開發、構建、測試與更新程式碼\n\n記得當初主管跟我分享 Angular 的好處，因為 Angular 擁有非常完整的功能，可以透過它提供的功能建立一個完整且大型的 Web App，而且就如他有\n非常完整的功能，當在面對多個開發者同時開發專案時，就會遵守共同的開發原則以減少多人開發的問題。\n\n\n\n# Angular applications: The essentials\nAngular 中有許多核心思想，了解這些核心思想對於之後的開發有非常好的幫助。\n\n## Components\nComponent 是`構建一個 Web App 的最基本方塊`，每一個 Web App 都是由一個又一個大大小小的 Component 所組成的，在之前學習 React \n的時候也是這個概念，但是 Angular 的 Component 跟 React 非常不一樣，他是一個帶有 `@Component()` 裝飾器的 TypeScript Class、\nHTML template, Style ，這邊你可能聽不懂，但沒關係現階段只要簡單記住他是一個有 TypeScript、HTML、CSS 的小方塊就好。\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hello-world',\n  template: `\n        <h2>Hello World</h2>\n        <p>This is my first component!</p>\n    `\n})\nexport class HelloWorldComponent {\n  // The code in this class drives the component's behavior.\n}\n```\n\n當你要使用這個 Component 時，只需要在 HTML 中將你要用的 selector 當作 tag 使用就好。\n\n```html\n<hello-world></hello-world>\n```\n\n## Templates\n每一個 Component 都擁有自己的 HTML template，它用於在畫面中呈現你這個 Component，當你的 Component 發生改變時 Angular 會\n自動更新並且重新渲染 DOM，他有許多非常好用的功能，比如說動態插入、事件綁定等等的，不過這個我們之後會專門講解，在這裡只要記得 Template \n是用來在 UI 上顯示 Component 內容的就可以了。\n\n## Dependency injection\nDependency injection 在 Angular 中是一個非常重要的觀念，簡單來說當你在寫一般的 JavaScript 時，你可能寫了一個 Class 裡面存放了許\n多邏輯，當你在使用的時候你可能會需要使用 new 將這個 Class 實例化成一個 Object，然後才能使用裡面的 method 或 property，這樣兩個 Class\n就產生了`依賴關係`。\n\n就「依賴」的文字意思來看，是指「一個東西需要另一個東西而存在；若沒有另外一個東西，則本身不能自立」。\n\n物件導向程式(OOP)中，程式是透過許多類別(Class)的實例(instance)，也就是物件(object)，彼此的交互組合來實現各種功能。所以依賴是指「一個物件需要另一個物件才能作用」\n\n而 DI 則是指`被依賴物件透過外部注入至依賴物件的程式中使用`，也就是被依賴物件並不是在依賴物件的程式中使用 `new` 產生而是由`外部注入`，這種注入可以透過 Class 中的\nConstructor 或 Setter 實現。\n\n詳細的內容會到後面再仔細講解什麼事 DI，目前只要記住 DI 是 Angular 的一個重要的概念，主要目的是用於將各個 Class 之間`解耦`。\n\n## Angular CLI\nAngular CLI 是開發 Angular 應用程序的最快、直接且推薦的方式，就像 React 的 create-react-app 一樣，可以透過指令快速建立出基本的 Angular app，除了建立模板之外還有非常多好用的功能，我會在下一章節中仔細講解 Angular CLI 是什麼。\n\n## First-party libraries\n就如上面所提到 Angular 擁有非常多非常完善的資源提供你創建你的 Web App，所以當你在開發過程中遇到需要添加功能時，就可以添加相對應的模組來達成你的目的。\n\n這邊簡單介紹幾個 first party libraries\n\n| Name   |      Description      |\n|----------|:-------------:|\n| Angular Router |  基於 Component 的客戶端導航與 Router，支援延遲載入、嵌套 Router、自定義路徑匹配等等 | \n| Angular Forms |    表單輸入與表單內容驗證   |\n| Angular HttpClient | 可支援 client 端與 server 端的溝通 |\n| Angular Animations | 驅動 app 動畫 |\n\n\n\n# 結論\n本篇章大概介紹了什麼是 Angular 與使用它的好處，有提到許多比較難的觀念，template 的操作與\nDependency injection 等等，現在可能看不太懂不過沒關係，我們後面會詳細講解這些是幹什麼的，當初我也是花了很多時間才大概了解他在幹嘛的 ( 苦笑。\n\n\n\n# Reference\n- [Angular.io](https://angular.io/guide/what-is-angular)","slug":"Angular/angular-01","published":1,"updated":"2022-02-15T07:16:18.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmnd0003kww31d731dhn","content":"<p>在2020年9月，我正式的從韌體工程師轉職成為一位前端工程師，在自學前端的時候我是選擇了 React 這個 Javascript 框架，做了幾個作品後投履歷面試最後找到目前任職的公司，一路上跌跌撞撞但也算順利，不過唯一不太順了就是目前任職的這間公司是使用 Angular ，當初剛進到這間公司時也是從頭開始 K Angular 官方文檔，看得真的是無煞煞，現在也進到這間公司快一年了，也使用過 Angular 做了幾個專案與處理了幾個問題， 想說再次挑戰自己從頭開始認真看 Angular 官方文檔並用自己的理解整理成筆記，希望能對新進的 Angular 開發者有些幫助。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"What-is-Angular\"><a href=\"#What-is-Angular\" class=\"headerlink\" title=\"What is Angular ?\"></a>What is Angular ?</h1><p>開門見山的說 Angular 是一個 <code>Javascript 的框架</code>，他是基於 <code>TypeScript</code> 進行開發的，它包括了：</p>\n<ul>\n<li>基於 Component 且用於構建 Web App 的框架</li>\n<li>他集成了許多 Library 涵蓋了多種功能，包括 Router, forms, client-server…</li>\n<li>一套開發人員工具，提供開發者開發、構建、測試與更新程式碼</li>\n</ul>\n<p>記得當初主管跟我分享 Angular 的好處，因為 Angular 擁有非常完整的功能，可以透過它提供的功能建立一個完整且大型的 Web App，而且就如他有<br>非常完整的功能，當在面對多個開發者同時開發專案時，就會遵守共同的開發原則以減少多人開發的問題。</p>\n<h1 id=\"Angular-applications-The-essentials\"><a href=\"#Angular-applications-The-essentials\" class=\"headerlink\" title=\"Angular applications: The essentials\"></a>Angular applications: The essentials</h1><p>Angular 中有許多核心思想，了解這些核心思想對於之後的開發有非常好的幫助。</p>\n<h2 id=\"Components\"><a href=\"#Components\" class=\"headerlink\" title=\"Components\"></a>Components</h2><p>Component 是<code>構建一個 Web App 的最基本方塊</code>，每一個 Web App 都是由一個又一個大大小小的 Component 所組成的，在之前學習 React<br>的時候也是這個概念，但是 Angular 的 Component 跟 React 非常不一樣，他是一個帶有 <code>@Component()</code> 裝飾器的 TypeScript Class、<br>HTML template, Style ，這邊你可能聽不懂，但沒關係現階段只要簡單記住他是一個有 TypeScript、HTML、CSS 的小方塊就好。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;Hello World&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;This is my first component!&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// The code in this class drives the component&#x27;s behavior.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>當你要使用這個 Component 時，只需要在 HTML 中將你要用的 selector 當作 tag 使用就好。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Templates\"><a href=\"#Templates\" class=\"headerlink\" title=\"Templates\"></a>Templates</h2><p>每一個 Component 都擁有自己的 HTML template，它用於在畫面中呈現你這個 Component，當你的 Component 發生改變時 Angular 會<br>自動更新並且重新渲染 DOM，他有許多非常好用的功能，比如說動態插入、事件綁定等等的，不過這個我們之後會專門講解，在這裡只要記得 Template<br>是用來在 UI 上顯示 Component 內容的就可以了。</p>\n<h2 id=\"Dependency-injection\"><a href=\"#Dependency-injection\" class=\"headerlink\" title=\"Dependency injection\"></a>Dependency injection</h2><p>Dependency injection 在 Angular 中是一個非常重要的觀念，簡單來說當你在寫一般的 JavaScript 時，你可能寫了一個 Class 裡面存放了許<br>多邏輯，當你在使用的時候你可能會需要使用 new 將這個 Class 實例化成一個 Object，然後才能使用裡面的 method 或 property，這樣兩個 Class<br>就產生了<code>依賴關係</code>。</p>\n<p>就「依賴」的文字意思來看，是指「一個東西需要另一個東西而存在；若沒有另外一個東西，則本身不能自立」。</p>\n<p>物件導向程式(OOP)中，程式是透過許多類別(Class)的實例(instance)，也就是物件(object)，彼此的交互組合來實現各種功能。所以依賴是指「一個物件需要另一個物件才能作用」</p>\n<p>而 DI 則是指<code>被依賴物件透過外部注入至依賴物件的程式中使用</code>，也就是被依賴物件並不是在依賴物件的程式中使用 <code>new</code> 產生而是由<code>外部注入</code>，這種注入可以透過 Class 中的<br>Constructor 或 Setter 實現。</p>\n<p>詳細的內容會到後面再仔細講解什麼事 DI，目前只要記住 DI 是 Angular 的一個重要的概念，主要目的是用於將各個 Class 之間<code>解耦</code>。</p>\n<h2 id=\"Angular-CLI\"><a href=\"#Angular-CLI\" class=\"headerlink\" title=\"Angular CLI\"></a>Angular CLI</h2><p>Angular CLI 是開發 Angular 應用程序的最快、直接且推薦的方式，就像 React 的 create-react-app 一樣，可以透過指令快速建立出基本的 Angular app，除了建立模板之外還有非常多好用的功能，我會在下一章節中仔細講解 Angular CLI 是什麼。</p>\n<h2 id=\"First-party-libraries\"><a href=\"#First-party-libraries\" class=\"headerlink\" title=\"First-party libraries\"></a>First-party libraries</h2><p>就如上面所提到 Angular 擁有非常多非常完善的資源提供你創建你的 Web App，所以當你在開發過程中遇到需要添加功能時，就可以添加相對應的模組來達成你的目的。</p>\n<p>這邊簡單介紹幾個 first party libraries</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Angular Router</td>\n<td align=\"center\">基於 Component 的客戶端導航與 Router，支援延遲載入、嵌套 Router、自定義路徑匹配等等</td>\n</tr>\n<tr>\n<td>Angular Forms</td>\n<td align=\"center\">表單輸入與表單內容驗證</td>\n</tr>\n<tr>\n<td>Angular HttpClient</td>\n<td align=\"center\">可支援 client 端與 server 端的溝通</td>\n</tr>\n<tr>\n<td>Angular Animations</td>\n<td align=\"center\">驅動 app 動畫</td>\n</tr>\n</tbody></table>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇章大概介紹了什麼是 Angular 與使用它的好處，有提到許多比較難的觀念，template 的操作與<br>Dependency injection 等等，現在可能看不太懂不過沒關係，我們後面會詳細講解這些是幹什麼的，當初我也是花了很多時間才大概了解他在幹嘛的 ( 苦笑。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/what-is-angular\">Angular.io</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在2020年9月，我正式的從韌體工程師轉職成為一位前端工程師，在自學前端的時候我是選擇了 React 這個 Javascript 框架，做了幾個作品後投履歷面試最後找到目前任職的公司，一路上跌跌撞撞但也算順利，不過唯一不太順了就是目前任職的這間公司是使用 Angular ，當初剛進到這間公司時也是從頭開始 K Angular 官方文檔，看得真的是無煞煞，現在也進到這間公司快一年了，也使用過 Angular 做了幾個專案與處理了幾個問題， 想說再次挑戰自己從頭開始認真看 Angular 官方文檔並用自己的理解整理成筆記，希望能對新進的 Angular 開發者有些幫助。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210901/20124767Bd7CvcH5JV.png\"></p>","more":"<h1 id=\"What-is-Angular\"><a href=\"#What-is-Angular\" class=\"headerlink\" title=\"What is Angular ?\"></a>What is Angular ?</h1><p>開門見山的說 Angular 是一個 <code>Javascript 的框架</code>，他是基於 <code>TypeScript</code> 進行開發的，它包括了：</p>\n<ul>\n<li>基於 Component 且用於構建 Web App 的框架</li>\n<li>他集成了許多 Library 涵蓋了多種功能，包括 Router, forms, client-server…</li>\n<li>一套開發人員工具，提供開發者開發、構建、測試與更新程式碼</li>\n</ul>\n<p>記得當初主管跟我分享 Angular 的好處，因為 Angular 擁有非常完整的功能，可以透過它提供的功能建立一個完整且大型的 Web App，而且就如他有<br>非常完整的功能，當在面對多個開發者同時開發專案時，就會遵守共同的開發原則以減少多人開發的問題。</p>\n<h1 id=\"Angular-applications-The-essentials\"><a href=\"#Angular-applications-The-essentials\" class=\"headerlink\" title=\"Angular applications: The essentials\"></a>Angular applications: The essentials</h1><p>Angular 中有許多核心思想，了解這些核心思想對於之後的開發有非常好的幫助。</p>\n<h2 id=\"Components\"><a href=\"#Components\" class=\"headerlink\" title=\"Components\"></a>Components</h2><p>Component 是<code>構建一個 Web App 的最基本方塊</code>，每一個 Web App 都是由一個又一個大大小小的 Component 所組成的，在之前學習 React<br>的時候也是這個概念，但是 Angular 的 Component 跟 React 非常不一樣，他是一個帶有 <code>@Component()</code> 裝飾器的 TypeScript Class、<br>HTML template, Style ，這邊你可能聽不懂，但沒關係現階段只要簡單記住他是一個有 TypeScript、HTML、CSS 的小方塊就好。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;Hello World&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;This is my first component!&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// The code in this class drives the component&#x27;s behavior.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>當你要使用這個 Component 時，只需要在 HTML 中將你要用的 selector 當作 tag 使用就好。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Templates\"><a href=\"#Templates\" class=\"headerlink\" title=\"Templates\"></a>Templates</h2><p>每一個 Component 都擁有自己的 HTML template，它用於在畫面中呈現你這個 Component，當你的 Component 發生改變時 Angular 會<br>自動更新並且重新渲染 DOM，他有許多非常好用的功能，比如說動態插入、事件綁定等等的，不過這個我們之後會專門講解，在這裡只要記得 Template<br>是用來在 UI 上顯示 Component 內容的就可以了。</p>\n<h2 id=\"Dependency-injection\"><a href=\"#Dependency-injection\" class=\"headerlink\" title=\"Dependency injection\"></a>Dependency injection</h2><p>Dependency injection 在 Angular 中是一個非常重要的觀念，簡單來說當你在寫一般的 JavaScript 時，你可能寫了一個 Class 裡面存放了許<br>多邏輯，當你在使用的時候你可能會需要使用 new 將這個 Class 實例化成一個 Object，然後才能使用裡面的 method 或 property，這樣兩個 Class<br>就產生了<code>依賴關係</code>。</p>\n<p>就「依賴」的文字意思來看，是指「一個東西需要另一個東西而存在；若沒有另外一個東西，則本身不能自立」。</p>\n<p>物件導向程式(OOP)中，程式是透過許多類別(Class)的實例(instance)，也就是物件(object)，彼此的交互組合來實現各種功能。所以依賴是指「一個物件需要另一個物件才能作用」</p>\n<p>而 DI 則是指<code>被依賴物件透過外部注入至依賴物件的程式中使用</code>，也就是被依賴物件並不是在依賴物件的程式中使用 <code>new</code> 產生而是由<code>外部注入</code>，這種注入可以透過 Class 中的<br>Constructor 或 Setter 實現。</p>\n<p>詳細的內容會到後面再仔細講解什麼事 DI，目前只要記住 DI 是 Angular 的一個重要的概念，主要目的是用於將各個 Class 之間<code>解耦</code>。</p>\n<h2 id=\"Angular-CLI\"><a href=\"#Angular-CLI\" class=\"headerlink\" title=\"Angular CLI\"></a>Angular CLI</h2><p>Angular CLI 是開發 Angular 應用程序的最快、直接且推薦的方式，就像 React 的 create-react-app 一樣，可以透過指令快速建立出基本的 Angular app，除了建立模板之外還有非常多好用的功能，我會在下一章節中仔細講解 Angular CLI 是什麼。</p>\n<h2 id=\"First-party-libraries\"><a href=\"#First-party-libraries\" class=\"headerlink\" title=\"First-party libraries\"></a>First-party libraries</h2><p>就如上面所提到 Angular 擁有非常多非常完善的資源提供你創建你的 Web App，所以當你在開發過程中遇到需要添加功能時，就可以添加相對應的模組來達成你的目的。</p>\n<p>這邊簡單介紹幾個 first party libraries</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Angular Router</td>\n<td align=\"center\">基於 Component 的客戶端導航與 Router，支援延遲載入、嵌套 Router、自定義路徑匹配等等</td>\n</tr>\n<tr>\n<td>Angular Forms</td>\n<td align=\"center\">表單輸入與表單內容驗證</td>\n</tr>\n<tr>\n<td>Angular HttpClient</td>\n<td align=\"center\">可支援 client 端與 server 端的溝通</td>\n</tr>\n<tr>\n<td>Angular Animations</td>\n<td align=\"center\">驅動 app 動畫</td>\n</tr>\n</tbody></table>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇章大概介紹了什麼是 Angular 與使用它的好處，有提到許多比較難的觀念，template 的操作與<br>Dependency injection 等等，現在可能看不太懂不過沒關係，我們後面會詳細講解這些是幹什麼的，當初我也是花了很多時間才大概了解他在幹嘛的 ( 苦笑。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/what-is-angular\">Angular.io</a></li>\n</ul>"},{"title":"Day2. Angular CLI","date":"2022-02-15T03:24:24.000Z","_content":"\n大家都說\"工欲善其事必先利其器\"，在我們發開 Angular 時，必需了解一個非常好用的工具， \"Angular CLI\" ，而這篇文章將會介紹什麼是 Angular CLI、如何安裝與使用 Angular CLI以及一些其他該注意的事項以及常見的命令操作。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png)\n\n<!--more-->\n\n# What is the Angular CLI ?\n在 Angular 的官方文檔中提到， Angular CLI 是 Angular 團隊創建的工具，用於管理、構建、維護和測試你的 Angular 專案。\n\n可能有些剛接觸前端的新手會覺得又要記一些指令覺得麻煩，實際上有一個 [Viisual Studio Code](https://marketplace.visualstudio.com/items?itemName=sasxa-net.angular-gui) 的擴展可以使用，它提供了一個 Angular CLI GUI 介面，可以讓你取代在終端機中輸入命令。\n\n![img](https://i.imgur.com/o8zEERJ.gif)\n\n雖然有 GUI 介面可以使用，但是本篇章還是主要會介紹如何透過在終端機中下達命令來使用 Angular CLI，別放棄學習啊！！\n\n\n# Do I have to use the Angular CLI ?\n現在我們知道了什麼是 Angular CLI，可能很多人都會問，既然他是自動幫開發著處理一些問題的，那我一定要用嗎？我可以不要這麼自動（？\n\n答案是當然可以，你可以再開發 Angular 的時候，無論創建、維護、測試等等的都用手動的方式建立或操作，但是你可能會變成.... foolish Angular developer (別篇文章說的下面會放連結，罵他不要罵我）。\n\nAngular CLI 存在的目的是為了讓開發者專心進行專案開發，它負責將麻煩與耗時的動作自動化，使用指令可以自動化生成一個基礎並帶有 .gitgnore( 用來告訴 git 應該忽略哪些 file ) 的 Angular app，其中包括 Angular 的核心部分比如 component, module 等等，除了創造 app 之外他還可以自動化進行 unit test、building和其他基本卻複雜的操作。\n\n所以說了這麼多，有沒有更想使用 Angular CLI 啦（不要說沒有！\n\n\n# How to install the Angular CLI\n終於要進入到安裝的環節了，在安裝 Angular CLI 之前比需要先安裝  [Node.js](https://node.js.org/) ，如果不想使用終端機命令安裝 Node.js 可以在 [Node.js 官網下載](https://nodejs.org/en/download/) 並進行安裝。\n\n當安裝完 Node.js 後，可以在終端中輸入指令正式安裝 Angular CLI\n```bash\nnpm install -g @angular/cli\n```\n\n> 使用 -g option 代表要在系統範圍內（全域）安裝特定的 npm module，如果沒有使用 -g option 則會安裝在當前目錄的 node_modules 中。\n\n如果你需要更新 Angular CLI 到最新版本則可以使用\n```bash\nnpm update -g @angular/cli\n```\n\n這樣就完成在全域中安裝 Angular CLI 的方式，這意味著你可以在你機器的任何地方使用它，有趣的是當創建一個 Angular app 時，CLI 也將安裝在本地，這意味著他也會安裝在你 Angular app 的 node_module 中，讓你可以在你的專案中使用 Angular CLI 的功能。\n\n\n\n# How to create an Angular application with the CLI\n當要創建一個新的 Angular app 時，可以使用 Angular CLI 他可以自動且快速的建立所有需要的文件（如果手動創建可能要花一天的時間，那麼我們就來使用指令吧！\n\n```bash\nng new MyApplicationName\n```\n當按下 enter 後你就可以悠閒的喝個咖啡聊個天等待他自動完成\n\n當 Angular CLI 在創建 App 的時候會問一些問題:\n1. 是否需要設置 Router (y / N) → 選擇 N 之後也可以手動加入 Router\n2. 選擇想要的樣式格式 → 選擇要使用 CSS, SASS, SCSS 等不同的 style format\n   ![https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png](https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png)\n\n當都選擇好後就可以等他完成啦～\n![https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png](https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png)\n\n\n\n# CLI command-language syntax\n在使用每一個程式語言的時候，都必須要注意他的語法，不然很容易造成出乎自己意料的結果，CLI syntax如下：\n```\nng commandNameOrAlias requiredArg [optionalArg] [options]\n```\n- 大部分的 command 和一些 option 擁有別名，可以使用簡單的方式達到一樣的目的。\n- 使用雙破折號(—)放在 option 前面當作前綴，使用單破折號(-)放在 option 別名前面當作前綴，而參數沒有前綴。\n- 通常生成文件的名稱可以將它當作參數加在後面，也可以使用 —name 來指定文件名稱。\n- 參數和 option 名稱可以使用駝峰命名或破折號 → —myOpitonName = —my-option-name\n\n\n\n# How to use Angular CLI\n上面介紹了這麼多的 Angular CLI 來源、用途、語法等等，接下來就要進到最重要的環節，來介紹一些常用的 CLI 指令。\n\n## Create Component\n下面是創建一個新 Component 的 Angular CLI 指令。\n```\nng generate component MyComponentName -> 完整\nng g c MyCompoenntName -> 簡寫\n```\n如果你要將這個創建出來的 Component 歸屬於特定的 module 則可以使用\n```\nng generate component MyComponentName --module MyModuleName\n```\n## Create Module\n在 Angular 中 Module 的觀念非常重要，他可以有效地模塊化你的程式，詳細的 Module 我們後面再慢慢介紹，這邊就先了解如何快速創建一個 Module 吧。\n```\nng generate module MyModuleName\n```\n## Create pipes\npipes 也是 Angular 一個重要的觀念，他可以將你的資料自動地進行轉換，一樣詳細的內容我們放到後面介紹，這邊一樣介紹如何快速建立 pipes。\n```\nng generate pipe MyPipeName\n```\n## Create Services\nServices 在 Angular 中也是非常重要的，他可以有效地將畫面與計算邏輯分割開來，一樣詳細的內容我們放到後面介紹（瘋狂挖坑...\n```\nng generate service MyServiceName\n```\n## Run project\n當我們撰寫好了我們的 Angular 程式後，最重要的就是讓他跑起來，哪們就可以使用這個指令\n```\nng serve <project> [options]\nng s <project> [options]\n```\n使用這個指令會自動 build 和 serve 你的 App，並且在你`更改內容儲存後重新構建`。\n## Building project\n當我們撰寫好程式後，我們可以將我們寫的程式 build 好，以便做更多的處理，這時就可以使用這個指令\n```\nng build <project> [options]\nng b <project> [options]\n```\n## Extract-i18n\nAngular 支持多語言的設計，後面會詳細講解 i18n 的使用方法，這邊一樣先介紹如何編譯 i18n\n```\nng extract-i18n <project> [options]\nng i18n-extract <project> [options]\nng xi18n <project> [options]\n```\n\n\n# 結論\n本篇章介紹了許多 Angular CLI 的概念，我在剛接觸 Angular 的時候對 CLI 也是模模糊糊，雖然要真正了解 CLI 內部是如何操作的十分困難，但對於一般開發者而言只要懂的使用就可以了，上面也介紹了許多 CLI 的指令，但這只是冰山一角我只介紹了幾個我自己比較常用到的，有興趣或是有使用到的話也可以到 Angular 官網中查詢需要使用到的指令，希望今天的講解有讓你稍微了解一點什麼是 Angular CLI 也算使用 Angular 的第一步吧。\n\n\n# Reference\n- [How to install and use the Angular CLI](https://itnext.io/how-to-install-and-use-the-angular-cli-ac8b5aae1d05)\n- [Angular.io](https://angular.io/cli)","source":"_posts/Angular/angular-02.md","raw":"---\ntitle: Day2. Angular CLI\ndate: 2022-02-15 11:24:24\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n大家都說\"工欲善其事必先利其器\"，在我們發開 Angular 時，必需了解一個非常好用的工具， \"Angular CLI\" ，而這篇文章將會介紹什麼是 Angular CLI、如何安裝與使用 Angular CLI以及一些其他該注意的事項以及常見的命令操作。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png)\n\n<!--more-->\n\n# What is the Angular CLI ?\n在 Angular 的官方文檔中提到， Angular CLI 是 Angular 團隊創建的工具，用於管理、構建、維護和測試你的 Angular 專案。\n\n可能有些剛接觸前端的新手會覺得又要記一些指令覺得麻煩，實際上有一個 [Viisual Studio Code](https://marketplace.visualstudio.com/items?itemName=sasxa-net.angular-gui) 的擴展可以使用，它提供了一個 Angular CLI GUI 介面，可以讓你取代在終端機中輸入命令。\n\n![img](https://i.imgur.com/o8zEERJ.gif)\n\n雖然有 GUI 介面可以使用，但是本篇章還是主要會介紹如何透過在終端機中下達命令來使用 Angular CLI，別放棄學習啊！！\n\n\n# Do I have to use the Angular CLI ?\n現在我們知道了什麼是 Angular CLI，可能很多人都會問，既然他是自動幫開發著處理一些問題的，那我一定要用嗎？我可以不要這麼自動（？\n\n答案是當然可以，你可以再開發 Angular 的時候，無論創建、維護、測試等等的都用手動的方式建立或操作，但是你可能會變成.... foolish Angular developer (別篇文章說的下面會放連結，罵他不要罵我）。\n\nAngular CLI 存在的目的是為了讓開發者專心進行專案開發，它負責將麻煩與耗時的動作自動化，使用指令可以自動化生成一個基礎並帶有 .gitgnore( 用來告訴 git 應該忽略哪些 file ) 的 Angular app，其中包括 Angular 的核心部分比如 component, module 等等，除了創造 app 之外他還可以自動化進行 unit test、building和其他基本卻複雜的操作。\n\n所以說了這麼多，有沒有更想使用 Angular CLI 啦（不要說沒有！\n\n\n# How to install the Angular CLI\n終於要進入到安裝的環節了，在安裝 Angular CLI 之前比需要先安裝  [Node.js](https://node.js.org/) ，如果不想使用終端機命令安裝 Node.js 可以在 [Node.js 官網下載](https://nodejs.org/en/download/) 並進行安裝。\n\n當安裝完 Node.js 後，可以在終端中輸入指令正式安裝 Angular CLI\n```bash\nnpm install -g @angular/cli\n```\n\n> 使用 -g option 代表要在系統範圍內（全域）安裝特定的 npm module，如果沒有使用 -g option 則會安裝在當前目錄的 node_modules 中。\n\n如果你需要更新 Angular CLI 到最新版本則可以使用\n```bash\nnpm update -g @angular/cli\n```\n\n這樣就完成在全域中安裝 Angular CLI 的方式，這意味著你可以在你機器的任何地方使用它，有趣的是當創建一個 Angular app 時，CLI 也將安裝在本地，這意味著他也會安裝在你 Angular app 的 node_module 中，讓你可以在你的專案中使用 Angular CLI 的功能。\n\n\n\n# How to create an Angular application with the CLI\n當要創建一個新的 Angular app 時，可以使用 Angular CLI 他可以自動且快速的建立所有需要的文件（如果手動創建可能要花一天的時間，那麼我們就來使用指令吧！\n\n```bash\nng new MyApplicationName\n```\n當按下 enter 後你就可以悠閒的喝個咖啡聊個天等待他自動完成\n\n當 Angular CLI 在創建 App 的時候會問一些問題:\n1. 是否需要設置 Router (y / N) → 選擇 N 之後也可以手動加入 Router\n2. 選擇想要的樣式格式 → 選擇要使用 CSS, SASS, SCSS 等不同的 style format\n   ![https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png](https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png)\n\n當都選擇好後就可以等他完成啦～\n![https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png](https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png)\n\n\n\n# CLI command-language syntax\n在使用每一個程式語言的時候，都必須要注意他的語法，不然很容易造成出乎自己意料的結果，CLI syntax如下：\n```\nng commandNameOrAlias requiredArg [optionalArg] [options]\n```\n- 大部分的 command 和一些 option 擁有別名，可以使用簡單的方式達到一樣的目的。\n- 使用雙破折號(—)放在 option 前面當作前綴，使用單破折號(-)放在 option 別名前面當作前綴，而參數沒有前綴。\n- 通常生成文件的名稱可以將它當作參數加在後面，也可以使用 —name 來指定文件名稱。\n- 參數和 option 名稱可以使用駝峰命名或破折號 → —myOpitonName = —my-option-name\n\n\n\n# How to use Angular CLI\n上面介紹了這麼多的 Angular CLI 來源、用途、語法等等，接下來就要進到最重要的環節，來介紹一些常用的 CLI 指令。\n\n## Create Component\n下面是創建一個新 Component 的 Angular CLI 指令。\n```\nng generate component MyComponentName -> 完整\nng g c MyCompoenntName -> 簡寫\n```\n如果你要將這個創建出來的 Component 歸屬於特定的 module 則可以使用\n```\nng generate component MyComponentName --module MyModuleName\n```\n## Create Module\n在 Angular 中 Module 的觀念非常重要，他可以有效地模塊化你的程式，詳細的 Module 我們後面再慢慢介紹，這邊就先了解如何快速創建一個 Module 吧。\n```\nng generate module MyModuleName\n```\n## Create pipes\npipes 也是 Angular 一個重要的觀念，他可以將你的資料自動地進行轉換，一樣詳細的內容我們放到後面介紹，這邊一樣介紹如何快速建立 pipes。\n```\nng generate pipe MyPipeName\n```\n## Create Services\nServices 在 Angular 中也是非常重要的，他可以有效地將畫面與計算邏輯分割開來，一樣詳細的內容我們放到後面介紹（瘋狂挖坑...\n```\nng generate service MyServiceName\n```\n## Run project\n當我們撰寫好了我們的 Angular 程式後，最重要的就是讓他跑起來，哪們就可以使用這個指令\n```\nng serve <project> [options]\nng s <project> [options]\n```\n使用這個指令會自動 build 和 serve 你的 App，並且在你`更改內容儲存後重新構建`。\n## Building project\n當我們撰寫好程式後，我們可以將我們寫的程式 build 好，以便做更多的處理，這時就可以使用這個指令\n```\nng build <project> [options]\nng b <project> [options]\n```\n## Extract-i18n\nAngular 支持多語言的設計，後面會詳細講解 i18n 的使用方法，這邊一樣先介紹如何編譯 i18n\n```\nng extract-i18n <project> [options]\nng i18n-extract <project> [options]\nng xi18n <project> [options]\n```\n\n\n# 結論\n本篇章介紹了許多 Angular CLI 的概念，我在剛接觸 Angular 的時候對 CLI 也是模模糊糊，雖然要真正了解 CLI 內部是如何操作的十分困難，但對於一般開發者而言只要懂的使用就可以了，上面也介紹了許多 CLI 的指令，但這只是冰山一角我只介紹了幾個我自己比較常用到的，有興趣或是有使用到的話也可以到 Angular 官網中查詢需要使用到的指令，希望今天的講解有讓你稍微了解一點什麼是 Angular CLI 也算使用 Angular 的第一步吧。\n\n\n# Reference\n- [How to install and use the Angular CLI](https://itnext.io/how-to-install-and-use-the-angular-cli-ac8b5aae1d05)\n- [Angular.io](https://angular.io/cli)","slug":"Angular/angular-02","published":1,"updated":"2022-02-15T07:16:15.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmnf0005kww34lwjc1u9","content":"<p>大家都說”工欲善其事必先利其器”，在我們發開 Angular 時，必需了解一個非常好用的工具， “Angular CLI” ，而這篇文章將會介紹什麼是 Angular CLI、如何安裝與使用 Angular CLI以及一些其他該注意的事項以及常見的命令操作。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"What-is-the-Angular-CLI\"><a href=\"#What-is-the-Angular-CLI\" class=\"headerlink\" title=\"What is the Angular CLI ?\"></a>What is the Angular CLI ?</h1><p>在 Angular 的官方文檔中提到， Angular CLI 是 Angular 團隊創建的工具，用於管理、構建、維護和測試你的 Angular 專案。</p>\n<p>可能有些剛接觸前端的新手會覺得又要記一些指令覺得麻煩，實際上有一個 <a href=\"https://marketplace.visualstudio.com/items?itemName=sasxa-net.angular-gui\">Viisual Studio Code</a> 的擴展可以使用，它提供了一個 Angular CLI GUI 介面，可以讓你取代在終端機中輸入命令。</p>\n<p><img src=\"https://i.imgur.com/o8zEERJ.gif\" alt=\"img\"></p>\n<p>雖然有 GUI 介面可以使用，但是本篇章還是主要會介紹如何透過在終端機中下達命令來使用 Angular CLI，別放棄學習啊！！</p>\n<h1 id=\"Do-I-have-to-use-the-Angular-CLI\"><a href=\"#Do-I-have-to-use-the-Angular-CLI\" class=\"headerlink\" title=\"Do I have to use the Angular CLI ?\"></a>Do I have to use the Angular CLI ?</h1><p>現在我們知道了什麼是 Angular CLI，可能很多人都會問，既然他是自動幫開發著處理一些問題的，那我一定要用嗎？我可以不要這麼自動（？</p>\n<p>答案是當然可以，你可以再開發 Angular 的時候，無論創建、維護、測試等等的都用手動的方式建立或操作，但是你可能會變成…. foolish Angular developer (別篇文章說的下面會放連結，罵他不要罵我）。</p>\n<p>Angular CLI 存在的目的是為了讓開發者專心進行專案開發，它負責將麻煩與耗時的動作自動化，使用指令可以自動化生成一個基礎並帶有 .gitgnore( 用來告訴 git 應該忽略哪些 file ) 的 Angular app，其中包括 Angular 的核心部分比如 component, module 等等，除了創造 app 之外他還可以自動化進行 unit test、building和其他基本卻複雜的操作。</p>\n<p>所以說了這麼多，有沒有更想使用 Angular CLI 啦（不要說沒有！</p>\n<h1 id=\"How-to-install-the-Angular-CLI\"><a href=\"#How-to-install-the-Angular-CLI\" class=\"headerlink\" title=\"How to install the Angular CLI\"></a>How to install the Angular CLI</h1><p>終於要進入到安裝的環節了，在安裝 Angular CLI 之前比需要先安裝  <a href=\"https://node.js.org/\">Node.js</a> ，如果不想使用終端機命令安裝 Node.js 可以在 <a href=\"https://nodejs.org/en/download/\">Node.js 官網下載</a> 並進行安裝。</p>\n<p>當安裝完 Node.js 後，可以在終端中輸入指令正式安裝 Angular CLI</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @angular/cli</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 -g option 代表要在系統範圍內（全域）安裝特定的 npm module，如果沒有使用 -g option 則會安裝在當前目錄的 node_modules 中。</p>\n</blockquote>\n<p>如果你需要更新 Angular CLI 到最新版本則可以使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm update -g @angular/cli</span><br></pre></td></tr></table></figure>\n\n<p>這樣就完成在全域中安裝 Angular CLI 的方式，這意味著你可以在你機器的任何地方使用它，有趣的是當創建一個 Angular app 時，CLI 也將安裝在本地，這意味著他也會安裝在你 Angular app 的 node_module 中，讓你可以在你的專案中使用 Angular CLI 的功能。</p>\n<h1 id=\"How-to-create-an-Angular-application-with-the-CLI\"><a href=\"#How-to-create-an-Angular-application-with-the-CLI\" class=\"headerlink\" title=\"How to create an Angular application with the CLI\"></a>How to create an Angular application with the CLI</h1><p>當要創建一個新的 Angular app 時，可以使用 Angular CLI 他可以自動且快速的建立所有需要的文件（如果手動創建可能要花一天的時間，那麼我們就來使用指令吧！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng new MyApplicationName</span><br></pre></td></tr></table></figure>\n<p>當按下 enter 後你就可以悠閒的喝個咖啡聊個天等待他自動完成</p>\n<p>當 Angular CLI 在創建 App 的時候會問一些問題:</p>\n<ol>\n<li>是否需要設置 Router (y &#x2F; N) → 選擇 N 之後也可以手動加入 Router</li>\n<li>選擇想要的樣式格式 → 選擇要使用 CSS, SASS, SCSS 等不同的 style format<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png\"></li>\n</ol>\n<p>當都選擇好後就可以等他完成啦～<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png\"></p>\n<h1 id=\"CLI-command-language-syntax\"><a href=\"#CLI-command-language-syntax\" class=\"headerlink\" title=\"CLI command-language syntax\"></a>CLI command-language syntax</h1><p>在使用每一個程式語言的時候，都必須要注意他的語法，不然很容易造成出乎自己意料的結果，CLI syntax如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng commandNameOrAlias requiredArg [optionalArg] [options]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>大部分的 command 和一些 option 擁有別名，可以使用簡單的方式達到一樣的目的。</li>\n<li>使用雙破折號(—)放在 option 前面當作前綴，使用單破折號(-)放在 option 別名前面當作前綴，而參數沒有前綴。</li>\n<li>通常生成文件的名稱可以將它當作參數加在後面，也可以使用 —name 來指定文件名稱。</li>\n<li>參數和 option 名稱可以使用駝峰命名或破折號 → —myOpitonName &#x3D; —my-option-name</li>\n</ul>\n<h1 id=\"How-to-use-Angular-CLI\"><a href=\"#How-to-use-Angular-CLI\" class=\"headerlink\" title=\"How to use Angular CLI\"></a>How to use Angular CLI</h1><p>上面介紹了這麼多的 Angular CLI 來源、用途、語法等等，接下來就要進到最重要的環節，來介紹一些常用的 CLI 指令。</p>\n<h2 id=\"Create-Component\"><a href=\"#Create-Component\" class=\"headerlink\" title=\"Create Component\"></a>Create Component</h2><p>下面是創建一個新 Component 的 Angular CLI 指令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component MyComponentName -&gt; 完整</span><br><span class=\"line\">ng g c MyCompoenntName -&gt; 簡寫</span><br></pre></td></tr></table></figure>\n<p>如果你要將這個創建出來的 Component 歸屬於特定的 module 則可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component MyComponentName --module MyModuleName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-Module\"><a href=\"#Create-Module\" class=\"headerlink\" title=\"Create Module\"></a>Create Module</h2><p>在 Angular 中 Module 的觀念非常重要，他可以有效地模塊化你的程式，詳細的 Module 我們後面再慢慢介紹，這邊就先了解如何快速創建一個 Module 吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate module MyModuleName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-pipes\"><a href=\"#Create-pipes\" class=\"headerlink\" title=\"Create pipes\"></a>Create pipes</h2><p>pipes 也是 Angular 一個重要的觀念，他可以將你的資料自動地進行轉換，一樣詳細的內容我們放到後面介紹，這邊一樣介紹如何快速建立 pipes。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate pipe MyPipeName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-Services\"><a href=\"#Create-Services\" class=\"headerlink\" title=\"Create Services\"></a>Create Services</h2><p>Services 在 Angular 中也是非常重要的，他可以有效地將畫面與計算邏輯分割開來，一樣詳細的內容我們放到後面介紹（瘋狂挖坑…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate service MyServiceName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Run-project\"><a href=\"#Run-project\" class=\"headerlink\" title=\"Run project\"></a>Run project</h2><p>當我們撰寫好了我們的 Angular 程式後，最重要的就是讓他跑起來，哪們就可以使用這個指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng serve &lt;project&gt; [options]</span><br><span class=\"line\">ng s &lt;project&gt; [options]</span><br></pre></td></tr></table></figure>\n<p>使用這個指令會自動 build 和 serve 你的 App，並且在你<code>更改內容儲存後重新構建</code>。</p>\n<h2 id=\"Building-project\"><a href=\"#Building-project\" class=\"headerlink\" title=\"Building project\"></a>Building project</h2><p>當我們撰寫好程式後，我們可以將我們寫的程式 build 好，以便做更多的處理，這時就可以使用這個指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng build &lt;project&gt; [options]</span><br><span class=\"line\">ng b &lt;project&gt; [options]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Extract-i18n\"><a href=\"#Extract-i18n\" class=\"headerlink\" title=\"Extract-i18n\"></a>Extract-i18n</h2><p>Angular 支持多語言的設計，後面會詳細講解 i18n 的使用方法，這邊一樣先介紹如何編譯 i18n</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng extract-i18n &lt;project&gt; [options]</span><br><span class=\"line\">ng i18n-extract &lt;project&gt; [options]</span><br><span class=\"line\">ng xi18n &lt;project&gt; [options]</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇章介紹了許多 Angular CLI 的概念，我在剛接觸 Angular 的時候對 CLI 也是模模糊糊，雖然要真正了解 CLI 內部是如何操作的十分困難，但對於一般開發者而言只要懂的使用就可以了，上面也介紹了許多 CLI 的指令，但這只是冰山一角我只介紹了幾個我自己比較常用到的，有興趣或是有使用到的話也可以到 Angular 官網中查詢需要使用到的指令，希望今天的講解有讓你稍微了解一點什麼是 Angular CLI 也算使用 Angular 的第一步吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://itnext.io/how-to-install-and-use-the-angular-cli-ac8b5aae1d05\">How to install and use the Angular CLI</a></li>\n<li><a href=\"https://angular.io/cli\">Angular.io</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>大家都說”工欲善其事必先利其器”，在我們發開 Angular 時，必需了解一個非常好用的工具， “Angular CLI” ，而這篇文章將會介紹什麼是 Angular CLI、如何安裝與使用 Angular CLI以及一些其他該注意的事項以及常見的命令操作。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767FXInjTdVpO.png\"></p>","more":"<h1 id=\"What-is-the-Angular-CLI\"><a href=\"#What-is-the-Angular-CLI\" class=\"headerlink\" title=\"What is the Angular CLI ?\"></a>What is the Angular CLI ?</h1><p>在 Angular 的官方文檔中提到， Angular CLI 是 Angular 團隊創建的工具，用於管理、構建、維護和測試你的 Angular 專案。</p>\n<p>可能有些剛接觸前端的新手會覺得又要記一些指令覺得麻煩，實際上有一個 <a href=\"https://marketplace.visualstudio.com/items?itemName=sasxa-net.angular-gui\">Viisual Studio Code</a> 的擴展可以使用，它提供了一個 Angular CLI GUI 介面，可以讓你取代在終端機中輸入命令。</p>\n<p><img src=\"https://i.imgur.com/o8zEERJ.gif\" alt=\"img\"></p>\n<p>雖然有 GUI 介面可以使用，但是本篇章還是主要會介紹如何透過在終端機中下達命令來使用 Angular CLI，別放棄學習啊！！</p>\n<h1 id=\"Do-I-have-to-use-the-Angular-CLI\"><a href=\"#Do-I-have-to-use-the-Angular-CLI\" class=\"headerlink\" title=\"Do I have to use the Angular CLI ?\"></a>Do I have to use the Angular CLI ?</h1><p>現在我們知道了什麼是 Angular CLI，可能很多人都會問，既然他是自動幫開發著處理一些問題的，那我一定要用嗎？我可以不要這麼自動（？</p>\n<p>答案是當然可以，你可以再開發 Angular 的時候，無論創建、維護、測試等等的都用手動的方式建立或操作，但是你可能會變成…. foolish Angular developer (別篇文章說的下面會放連結，罵他不要罵我）。</p>\n<p>Angular CLI 存在的目的是為了讓開發者專心進行專案開發，它負責將麻煩與耗時的動作自動化，使用指令可以自動化生成一個基礎並帶有 .gitgnore( 用來告訴 git 應該忽略哪些 file ) 的 Angular app，其中包括 Angular 的核心部分比如 component, module 等等，除了創造 app 之外他還可以自動化進行 unit test、building和其他基本卻複雜的操作。</p>\n<p>所以說了這麼多，有沒有更想使用 Angular CLI 啦（不要說沒有！</p>\n<h1 id=\"How-to-install-the-Angular-CLI\"><a href=\"#How-to-install-the-Angular-CLI\" class=\"headerlink\" title=\"How to install the Angular CLI\"></a>How to install the Angular CLI</h1><p>終於要進入到安裝的環節了，在安裝 Angular CLI 之前比需要先安裝  <a href=\"https://node.js.org/\">Node.js</a> ，如果不想使用終端機命令安裝 Node.js 可以在 <a href=\"https://nodejs.org/en/download/\">Node.js 官網下載</a> 並進行安裝。</p>\n<p>當安裝完 Node.js 後，可以在終端中輸入指令正式安裝 Angular CLI</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g @angular/cli</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 -g option 代表要在系統範圍內（全域）安裝特定的 npm module，如果沒有使用 -g option 則會安裝在當前目錄的 node_modules 中。</p>\n</blockquote>\n<p>如果你需要更新 Angular CLI 到最新版本則可以使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm update -g @angular/cli</span><br></pre></td></tr></table></figure>\n\n<p>這樣就完成在全域中安裝 Angular CLI 的方式，這意味著你可以在你機器的任何地方使用它，有趣的是當創建一個 Angular app 時，CLI 也將安裝在本地，這意味著他也會安裝在你 Angular app 的 node_module 中，讓你可以在你的專案中使用 Angular CLI 的功能。</p>\n<h1 id=\"How-to-create-an-Angular-application-with-the-CLI\"><a href=\"#How-to-create-an-Angular-application-with-the-CLI\" class=\"headerlink\" title=\"How to create an Angular application with the CLI\"></a>How to create an Angular application with the CLI</h1><p>當要創建一個新的 Angular app 時，可以使用 Angular CLI 他可以自動且快速的建立所有需要的文件（如果手動創建可能要花一天的時間，那麼我們就來使用指令吧！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng new MyApplicationName</span><br></pre></td></tr></table></figure>\n<p>當按下 enter 後你就可以悠閒的喝個咖啡聊個天等待他自動完成</p>\n<p>當 Angular CLI 在創建 App 的時候會問一些問題:</p>\n<ol>\n<li>是否需要設置 Router (y &#x2F; N) → 選擇 N 之後也可以手動加入 Router</li>\n<li>選擇想要的樣式格式 → 選擇要使用 CSS, SASS, SCSS 等不同的 style format<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767MZ8BUaS7ww.png\"></li>\n</ol>\n<p>當都選擇好後就可以等他完成啦～<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210727/20124767WZkErowhaO.png\"></p>\n<h1 id=\"CLI-command-language-syntax\"><a href=\"#CLI-command-language-syntax\" class=\"headerlink\" title=\"CLI command-language syntax\"></a>CLI command-language syntax</h1><p>在使用每一個程式語言的時候，都必須要注意他的語法，不然很容易造成出乎自己意料的結果，CLI syntax如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng commandNameOrAlias requiredArg [optionalArg] [options]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>大部分的 command 和一些 option 擁有別名，可以使用簡單的方式達到一樣的目的。</li>\n<li>使用雙破折號(—)放在 option 前面當作前綴，使用單破折號(-)放在 option 別名前面當作前綴，而參數沒有前綴。</li>\n<li>通常生成文件的名稱可以將它當作參數加在後面，也可以使用 —name 來指定文件名稱。</li>\n<li>參數和 option 名稱可以使用駝峰命名或破折號 → —myOpitonName &#x3D; —my-option-name</li>\n</ul>\n<h1 id=\"How-to-use-Angular-CLI\"><a href=\"#How-to-use-Angular-CLI\" class=\"headerlink\" title=\"How to use Angular CLI\"></a>How to use Angular CLI</h1><p>上面介紹了這麼多的 Angular CLI 來源、用途、語法等等，接下來就要進到最重要的環節，來介紹一些常用的 CLI 指令。</p>\n<h2 id=\"Create-Component\"><a href=\"#Create-Component\" class=\"headerlink\" title=\"Create Component\"></a>Create Component</h2><p>下面是創建一個新 Component 的 Angular CLI 指令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component MyComponentName -&gt; 完整</span><br><span class=\"line\">ng g c MyCompoenntName -&gt; 簡寫</span><br></pre></td></tr></table></figure>\n<p>如果你要將這個創建出來的 Component 歸屬於特定的 module 則可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component MyComponentName --module MyModuleName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-Module\"><a href=\"#Create-Module\" class=\"headerlink\" title=\"Create Module\"></a>Create Module</h2><p>在 Angular 中 Module 的觀念非常重要，他可以有效地模塊化你的程式，詳細的 Module 我們後面再慢慢介紹，這邊就先了解如何快速創建一個 Module 吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate module MyModuleName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-pipes\"><a href=\"#Create-pipes\" class=\"headerlink\" title=\"Create pipes\"></a>Create pipes</h2><p>pipes 也是 Angular 一個重要的觀念，他可以將你的資料自動地進行轉換，一樣詳細的內容我們放到後面介紹，這邊一樣介紹如何快速建立 pipes。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate pipe MyPipeName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Create-Services\"><a href=\"#Create-Services\" class=\"headerlink\" title=\"Create Services\"></a>Create Services</h2><p>Services 在 Angular 中也是非常重要的，他可以有效地將畫面與計算邏輯分割開來，一樣詳細的內容我們放到後面介紹（瘋狂挖坑…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate service MyServiceName</span><br></pre></td></tr></table></figure>\n<h2 id=\"Run-project\"><a href=\"#Run-project\" class=\"headerlink\" title=\"Run project\"></a>Run project</h2><p>當我們撰寫好了我們的 Angular 程式後，最重要的就是讓他跑起來，哪們就可以使用這個指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng serve &lt;project&gt; [options]</span><br><span class=\"line\">ng s &lt;project&gt; [options]</span><br></pre></td></tr></table></figure>\n<p>使用這個指令會自動 build 和 serve 你的 App，並且在你<code>更改內容儲存後重新構建</code>。</p>\n<h2 id=\"Building-project\"><a href=\"#Building-project\" class=\"headerlink\" title=\"Building project\"></a>Building project</h2><p>當我們撰寫好程式後，我們可以將我們寫的程式 build 好，以便做更多的處理，這時就可以使用這個指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng build &lt;project&gt; [options]</span><br><span class=\"line\">ng b &lt;project&gt; [options]</span><br></pre></td></tr></table></figure>\n<h2 id=\"Extract-i18n\"><a href=\"#Extract-i18n\" class=\"headerlink\" title=\"Extract-i18n\"></a>Extract-i18n</h2><p>Angular 支持多語言的設計，後面會詳細講解 i18n 的使用方法，這邊一樣先介紹如何編譯 i18n</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng extract-i18n &lt;project&gt; [options]</span><br><span class=\"line\">ng i18n-extract &lt;project&gt; [options]</span><br><span class=\"line\">ng xi18n &lt;project&gt; [options]</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇章介紹了許多 Angular CLI 的概念，我在剛接觸 Angular 的時候對 CLI 也是模模糊糊，雖然要真正了解 CLI 內部是如何操作的十分困難，但對於一般開發者而言只要懂的使用就可以了，上面也介紹了許多 CLI 的指令，但這只是冰山一角我只介紹了幾個我自己比較常用到的，有興趣或是有使用到的話也可以到 Angular 官網中查詢需要使用到的指令，希望今天的講解有讓你稍微了解一點什麼是 Angular CLI 也算使用 Angular 的第一步吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://itnext.io/how-to-install-and-use-the-angular-cli-ac8b5aae1d05\">How to install and use the Angular CLI</a></li>\n<li><a href=\"https://angular.io/cli\">Angular.io</a></li>\n</ul>"},{"title":"Day3. angular.json","date":"2022-02-15T03:39:10.000Z","_content":"\n在上一篇中介紹了什麼是 Angular CLI 與他可以提供許多方便功能，不過只是大概介紹他的用法與他是什麼，要實際暸解到他背後的運行邏輯其實是滿複雜的，這邊就不詳細的講解（因為我也不太了解...\n\n不過說到 Angular CLI 就避免不了要介紹一下 Angular CLI 的控制塔 \" angular.json \"， angular.json 是位於 Angular workspace root level 的一個文件，主要是`提供 workspace 的配置與 project 的預設配置，供 Angular CLI 中 build 和 development tool 使用`。\n> A file named angular.json at the root level of an Angular workspace provides workspace-wide and project-specific configuration defaults for build and development tools provided by the Angular CLI. Path values given in the configuration are relative to the root workspace folder.\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png)\n\n<!--more-->\n\n# Overall JSON structure\n大概講完 angular.json 是幹嘛的後接下來要分析一下 angular.json 的結構。\n\nangular.json 主要分為兩個區域： root 和 project。\n\nroot 的部分主要是關於 workspace 的一些信息，主要用於配置 workspace，你會在上面找到：\n\n- **version**：你的 workspace 配置版本\n- **newProjectRoot**：這是用於創建新項目的路徑，比如使用 ng generate application <name> 或 ng generate library <name>，那麼 Angular CLI 會藉由這個路徑知道要從哪裡生成 applicatioon 或 library。\n- **defaultProject**：這是在你使用 ng new <name> 時所創建的屬性，他對應著你創建這個項目時給定的初始名稱，如果在使用 Angular CLI 時沒有填入項目名稱，則會直接將這個屬性帶入，比如說你要執行 app 時所使用的 ng server <name>，你可以直接執行 ng server 而不會出錯的原因就是它會自動將名稱帶入變成 ng server my-app。\n- **projects**：這裡包含了你的 application 和 library 所有必要的訊息。\n- **schematics**：用於客製化 ng generation 命令的預設選項。\n\nproject 的部分包含 CLI 可以使用的特定訊息，你會在上面找到：\n\n- **root**：這是 project 相對於 workspace 的路徑。\n- **sourceroot**：這是包含當前項目 source file 的文件夾路徑。\n- **projectType**：可以是 application 或 library，CLI 需要知道專案類型，因為每種類型都有對應的需求與限制，比如說 library 需要被打包才能分發並且不能在與 application 相反的瀏覽器中提供服務。\n- **prefix**：這是當前項目 selectors 的前綴字串，當使用 ng generate component 時會將這個前綴字加在你的 component 前面，比如你的 prefix 這制為 gna，那麼使用 ng generate component hello-world 所創建出來的 component 的 selectors 就會是 \"gna-hello-world\"。\n- **schematics**：用於這是當前 project 中某些 schematics 所使用到的默認選項，比如你要將你專案的樣是從 CSS 變為 SCSS，就可以在這個屬性中添加 “styleext”:“scss”。\n- **architect**：為這個 project 各個 architect 提供預設值。\n\n下圖是一個簡單的 angular.json file，其中只有一個 build command。\n![https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png](https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png)\n\n\n# What is Architect ?\n可能看到這邊很多人都會覺得還可以，畢竟這些 property 大概都能了解在幹嘛而且也可以在自己的 Angular app 中找到對應的位置，但是！ \"Architect\" 這個到底是什麼？，可能對很多新手來說相當的複雜（我現在也迷迷糊糊，有說錯的話歡迎指正），接下來我們就來看看 Angular 官網是怎麼描述這個東西的。\n> Architect is the tool that the CLI uses to perform complex tasks, such as compilation and test running\n\nArchitect 是 CLI 用來執行複雜任務的工具，例如 compilation 和 test running，而 Architect 是一個 shell，它根據 target configuration 執行指定的 Builder 來執行給定的任務\n\n![https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png](https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png)\n\n可以把它看作是 `Angular CLI 與 builder 之間的 \"中間人\"`，Architect 是可以訪問或修改特定 builder 選項或添加選項配置的地方，`當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作`。\n\n\n\n# What is Builders ?\n大概了解 Architect 是什麼並且他在做什麼之後，那麼什麼是 Builders？， Builders 是 Architect 要處理特定任務時所運行的工具，通常他會對應到 npm package，例如 packageing your libreay 或 building，和 serving application。\n\n通常 builders 會接收兩個參數，一組輸入 option ( a JSON object )，和一個 context ( a BuilderContext object )，option object 由 CLI 使用者提供，而 context 由 CLI Builder API 提供。\n\nAngular 提供了一些由 CLI 用於 ng build 和 ng test 等命令的 builders，這些內建的 CLI Builders 可以在 angular.json 的 \"Architect\" 部分找到，當然你也可以當然你也可以使用 ng run <targetName>來自定你想要的 builders，不過這有點過於深入不在本章節的討論範圍。\n\n\n\n# Understanding the command mapping\n![https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png](https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png)\n\n正如我們前面所說的，當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作，所以當我們輸入了簡化的 command 後，實際上他會被 Architect 轉化成通用的 command : ng run projectName:architectTarget。\n\nExample: build: ng build... → ng run <projectName>:build\n\n知道了這一點後我們可以推敲一下這些命令在 Architect 轉換後會變成什麼：\n\n- build: ng build … → ng run my-app:build;\n- serve: ng serve … → ng run my-app:serve;\n- e2e: ng e2e … → ng run my-app:e2e;\n- test: ng test … → ng run my-app:test;\n- lint: ng lint … → ng run my-app:lint;\n- extract-i18n: ng xi18n … → ng run my-app:xi18n\n\n\n\n# Assets configuration\n在每一個 build target 中都可以有一個陣列，裡面可以放你想要的文件或文件夾，他會在你 build 專案的時候按照原樣複製一份，不會對他進行壓縮或打包，通常會把圖片放在這邊。\n```JSON\n\"assets\": [\n  \"src/assets\",\n  \"src/favicon.ico\"\n]\n```\n\n你可以把 Assets 的內容變為一個一個的物件，這樣相較於只有填入檔案名稱或路徑會更清楚與更清晰，將 Assets 的內容變為物件可以具有以下個 key：\n\n- glob：使用 node-glob 設置的基本目錄\n- input：相對於 root 目錄的路徑\n- output：相對於 outDir 的路徑，簡單來說就是 build 後存放的位置，預設是 dist / project-name\n- ignore：要排除的 glob 列表\n- followSymlinks：使否允許搜尋符號鏈接的子目錄，默認為 false\n\n舉個例子你可以使用這些 key 更詳細描述你的 asset 路徑：\n```JSON\n\"assets\": [\n  {\n    \"glob\": \"**/*\",\n    \"input\": \"src/assets/\",\n    \"output\": \"/assets/\"\n  },\n  {\n    \"glob\": \"favicon.ico\",\n    \"input\": \"src/\",\n    \"output\": \"/\"\n  }\n]\n```\n\n\n\n# 結論\n在本篇文章中大概了解的 angular.json 是個什麼東西，了解他與 Angular CLI 之間的關係，也大概個介紹了什麼是 Architect 與 builders ，不過都只是稍微講解一下概念並沒有太過深入鑽研他背後的運作原理，不過還是大概總結一下：\n\n- angular.json 是 Angular CLI 的控制塔，它提供了 Angular workspace 和 project 的預設配置。\n- 講解了一些 angular.json 的資料架構。\n- 什麼是 Architect 和 Builders 與他們之間的關係。\n- Angular CLI 是如何透過 Architect 解析命令的。\n- 如何透過 assets 在打包專案時複製完整的資料。\n\n\n# Reference\n- [Angular CLI — Demystifying the workspace](https://blog.nrwl.io/angular-cli-demystifying-the-workspace-7f59ffaab4cb)\n- [Angular.io](https://angular.io/guide/workspace-config)\n\n","source":"_posts/Angular/angular-03.md","raw":"---\ntitle: Day3. angular.json\ndate: 2022-02-15 11:39:10\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n在上一篇中介紹了什麼是 Angular CLI 與他可以提供許多方便功能，不過只是大概介紹他的用法與他是什麼，要實際暸解到他背後的運行邏輯其實是滿複雜的，這邊就不詳細的講解（因為我也不太了解...\n\n不過說到 Angular CLI 就避免不了要介紹一下 Angular CLI 的控制塔 \" angular.json \"， angular.json 是位於 Angular workspace root level 的一個文件，主要是`提供 workspace 的配置與 project 的預設配置，供 Angular CLI 中 build 和 development tool 使用`。\n> A file named angular.json at the root level of an Angular workspace provides workspace-wide and project-specific configuration defaults for build and development tools provided by the Angular CLI. Path values given in the configuration are relative to the root workspace folder.\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png)\n\n<!--more-->\n\n# Overall JSON structure\n大概講完 angular.json 是幹嘛的後接下來要分析一下 angular.json 的結構。\n\nangular.json 主要分為兩個區域： root 和 project。\n\nroot 的部分主要是關於 workspace 的一些信息，主要用於配置 workspace，你會在上面找到：\n\n- **version**：你的 workspace 配置版本\n- **newProjectRoot**：這是用於創建新項目的路徑，比如使用 ng generate application <name> 或 ng generate library <name>，那麼 Angular CLI 會藉由這個路徑知道要從哪裡生成 applicatioon 或 library。\n- **defaultProject**：這是在你使用 ng new <name> 時所創建的屬性，他對應著你創建這個項目時給定的初始名稱，如果在使用 Angular CLI 時沒有填入項目名稱，則會直接將這個屬性帶入，比如說你要執行 app 時所使用的 ng server <name>，你可以直接執行 ng server 而不會出錯的原因就是它會自動將名稱帶入變成 ng server my-app。\n- **projects**：這裡包含了你的 application 和 library 所有必要的訊息。\n- **schematics**：用於客製化 ng generation 命令的預設選項。\n\nproject 的部分包含 CLI 可以使用的特定訊息，你會在上面找到：\n\n- **root**：這是 project 相對於 workspace 的路徑。\n- **sourceroot**：這是包含當前項目 source file 的文件夾路徑。\n- **projectType**：可以是 application 或 library，CLI 需要知道專案類型，因為每種類型都有對應的需求與限制，比如說 library 需要被打包才能分發並且不能在與 application 相反的瀏覽器中提供服務。\n- **prefix**：這是當前項目 selectors 的前綴字串，當使用 ng generate component 時會將這個前綴字加在你的 component 前面，比如你的 prefix 這制為 gna，那麼使用 ng generate component hello-world 所創建出來的 component 的 selectors 就會是 \"gna-hello-world\"。\n- **schematics**：用於這是當前 project 中某些 schematics 所使用到的默認選項，比如你要將你專案的樣是從 CSS 變為 SCSS，就可以在這個屬性中添加 “styleext”:“scss”。\n- **architect**：為這個 project 各個 architect 提供預設值。\n\n下圖是一個簡單的 angular.json file，其中只有一個 build command。\n![https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png](https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png)\n\n\n# What is Architect ?\n可能看到這邊很多人都會覺得還可以，畢竟這些 property 大概都能了解在幹嘛而且也可以在自己的 Angular app 中找到對應的位置，但是！ \"Architect\" 這個到底是什麼？，可能對很多新手來說相當的複雜（我現在也迷迷糊糊，有說錯的話歡迎指正），接下來我們就來看看 Angular 官網是怎麼描述這個東西的。\n> Architect is the tool that the CLI uses to perform complex tasks, such as compilation and test running\n\nArchitect 是 CLI 用來執行複雜任務的工具，例如 compilation 和 test running，而 Architect 是一個 shell，它根據 target configuration 執行指定的 Builder 來執行給定的任務\n\n![https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png](https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png)\n\n可以把它看作是 `Angular CLI 與 builder 之間的 \"中間人\"`，Architect 是可以訪問或修改特定 builder 選項或添加選項配置的地方，`當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作`。\n\n\n\n# What is Builders ?\n大概了解 Architect 是什麼並且他在做什麼之後，那麼什麼是 Builders？， Builders 是 Architect 要處理特定任務時所運行的工具，通常他會對應到 npm package，例如 packageing your libreay 或 building，和 serving application。\n\n通常 builders 會接收兩個參數，一組輸入 option ( a JSON object )，和一個 context ( a BuilderContext object )，option object 由 CLI 使用者提供，而 context 由 CLI Builder API 提供。\n\nAngular 提供了一些由 CLI 用於 ng build 和 ng test 等命令的 builders，這些內建的 CLI Builders 可以在 angular.json 的 \"Architect\" 部分找到，當然你也可以當然你也可以使用 ng run <targetName>來自定你想要的 builders，不過這有點過於深入不在本章節的討論範圍。\n\n\n\n# Understanding the command mapping\n![https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png](https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png)\n\n正如我們前面所說的，當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作，所以當我們輸入了簡化的 command 後，實際上他會被 Architect 轉化成通用的 command : ng run projectName:architectTarget。\n\nExample: build: ng build... → ng run <projectName>:build\n\n知道了這一點後我們可以推敲一下這些命令在 Architect 轉換後會變成什麼：\n\n- build: ng build … → ng run my-app:build;\n- serve: ng serve … → ng run my-app:serve;\n- e2e: ng e2e … → ng run my-app:e2e;\n- test: ng test … → ng run my-app:test;\n- lint: ng lint … → ng run my-app:lint;\n- extract-i18n: ng xi18n … → ng run my-app:xi18n\n\n\n\n# Assets configuration\n在每一個 build target 中都可以有一個陣列，裡面可以放你想要的文件或文件夾，他會在你 build 專案的時候按照原樣複製一份，不會對他進行壓縮或打包，通常會把圖片放在這邊。\n```JSON\n\"assets\": [\n  \"src/assets\",\n  \"src/favicon.ico\"\n]\n```\n\n你可以把 Assets 的內容變為一個一個的物件，這樣相較於只有填入檔案名稱或路徑會更清楚與更清晰，將 Assets 的內容變為物件可以具有以下個 key：\n\n- glob：使用 node-glob 設置的基本目錄\n- input：相對於 root 目錄的路徑\n- output：相對於 outDir 的路徑，簡單來說就是 build 後存放的位置，預設是 dist / project-name\n- ignore：要排除的 glob 列表\n- followSymlinks：使否允許搜尋符號鏈接的子目錄，默認為 false\n\n舉個例子你可以使用這些 key 更詳細描述你的 asset 路徑：\n```JSON\n\"assets\": [\n  {\n    \"glob\": \"**/*\",\n    \"input\": \"src/assets/\",\n    \"output\": \"/assets/\"\n  },\n  {\n    \"glob\": \"favicon.ico\",\n    \"input\": \"src/\",\n    \"output\": \"/\"\n  }\n]\n```\n\n\n\n# 結論\n在本篇文章中大概了解的 angular.json 是個什麼東西，了解他與 Angular CLI 之間的關係，也大概個介紹了什麼是 Architect 與 builders ，不過都只是稍微講解一下概念並沒有太過深入鑽研他背後的運作原理，不過還是大概總結一下：\n\n- angular.json 是 Angular CLI 的控制塔，它提供了 Angular workspace 和 project 的預設配置。\n- 講解了一些 angular.json 的資料架構。\n- 什麼是 Architect 和 Builders 與他們之間的關係。\n- Angular CLI 是如何透過 Architect 解析命令的。\n- 如何透過 assets 在打包專案時複製完整的資料。\n\n\n# Reference\n- [Angular CLI — Demystifying the workspace](https://blog.nrwl.io/angular-cli-demystifying-the-workspace-7f59ffaab4cb)\n- [Angular.io](https://angular.io/guide/workspace-config)\n\n","slug":"Angular/angular-03","published":1,"updated":"2022-02-15T07:16:12.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmni0008kww31ns71pgf","content":"<p>在上一篇中介紹了什麼是 Angular CLI 與他可以提供許多方便功能，不過只是大概介紹他的用法與他是什麼，要實際暸解到他背後的運行邏輯其實是滿複雜的，這邊就不詳細的講解（因為我也不太了解…</p>\n<p>不過說到 Angular CLI 就避免不了要介紹一下 Angular CLI 的控制塔 “ angular.json “， angular.json 是位於 Angular workspace root level 的一個文件，主要是<code>提供 workspace 的配置與 project 的預設配置，供 Angular CLI 中 build 和 development tool 使用</code>。</p>\n<blockquote>\n<p>A file named angular.json at the root level of an Angular workspace provides workspace-wide and project-specific configuration defaults for build and development tools provided by the Angular CLI. Path values given in the configuration are relative to the root workspace folder.</p>\n</blockquote>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Overall-JSON-structure\"><a href=\"#Overall-JSON-structure\" class=\"headerlink\" title=\"Overall JSON structure\"></a>Overall JSON structure</h1><p>大概講完 angular.json 是幹嘛的後接下來要分析一下 angular.json 的結構。</p>\n<p>angular.json 主要分為兩個區域： root 和 project。</p>\n<p>root 的部分主要是關於 workspace 的一些信息，主要用於配置 workspace，你會在上面找到：</p>\n<ul>\n<li><strong>version</strong>：你的 workspace 配置版本</li>\n<li><strong>newProjectRoot</strong>：這是用於創建新項目的路徑，比如使用 ng generate application <name> 或 ng generate library <name>，那麼 Angular CLI 會藉由這個路徑知道要從哪裡生成 applicatioon 或 library。</li>\n<li><strong>defaultProject</strong>：這是在你使用 ng new <name> 時所創建的屬性，他對應著你創建這個項目時給定的初始名稱，如果在使用 Angular CLI 時沒有填入項目名稱，則會直接將這個屬性帶入，比如說你要執行 app 時所使用的 ng server <name>，你可以直接執行 ng server 而不會出錯的原因就是它會自動將名稱帶入變成 ng server my-app。</li>\n<li><strong>projects</strong>：這裡包含了你的 application 和 library 所有必要的訊息。</li>\n<li><strong>schematics</strong>：用於客製化 ng generation 命令的預設選項。</li>\n</ul>\n<p>project 的部分包含 CLI 可以使用的特定訊息，你會在上面找到：</p>\n<ul>\n<li><strong>root</strong>：這是 project 相對於 workspace 的路徑。</li>\n<li><strong>sourceroot</strong>：這是包含當前項目 source file 的文件夾路徑。</li>\n<li><strong>projectType</strong>：可以是 application 或 library，CLI 需要知道專案類型，因為每種類型都有對應的需求與限制，比如說 library 需要被打包才能分發並且不能在與 application 相反的瀏覽器中提供服務。</li>\n<li><strong>prefix</strong>：這是當前項目 selectors 的前綴字串，當使用 ng generate component 時會將這個前綴字加在你的 component 前面，比如你的 prefix 這制為 gna，那麼使用 ng generate component hello-world 所創建出來的 component 的 selectors 就會是 “gna-hello-world”。</li>\n<li><strong>schematics</strong>：用於這是當前 project 中某些 schematics 所使用到的默認選項，比如你要將你專案的樣是從 CSS 變為 SCSS，就可以在這個屬性中添加 “styleext”:“scss”。</li>\n<li><strong>architect</strong>：為這個 project 各個 architect 提供預設值。</li>\n</ul>\n<p>下圖是一個簡單的 angular.json file，其中只有一個 build command。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png\"></p>\n<h1 id=\"What-is-Architect\"><a href=\"#What-is-Architect\" class=\"headerlink\" title=\"What is Architect ?\"></a>What is Architect ?</h1><p>可能看到這邊很多人都會覺得還可以，畢竟這些 property 大概都能了解在幹嘛而且也可以在自己的 Angular app 中找到對應的位置，但是！ “Architect” 這個到底是什麼？，可能對很多新手來說相當的複雜（我現在也迷迷糊糊，有說錯的話歡迎指正），接下來我們就來看看 Angular 官網是怎麼描述這個東西的。</p>\n<blockquote>\n<p>Architect is the tool that the CLI uses to perform complex tasks, such as compilation and test running</p>\n</blockquote>\n<p>Architect 是 CLI 用來執行複雜任務的工具，例如 compilation 和 test running，而 Architect 是一個 shell，它根據 target configuration 執行指定的 Builder 來執行給定的任務</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png\"></p>\n<p>可以把它看作是 <code>Angular CLI 與 builder 之間的 &quot;中間人&quot;</code>，Architect 是可以訪問或修改特定 builder 選項或添加選項配置的地方，<code>當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作</code>。</p>\n<h1 id=\"What-is-Builders\"><a href=\"#What-is-Builders\" class=\"headerlink\" title=\"What is Builders ?\"></a>What is Builders ?</h1><p>大概了解 Architect 是什麼並且他在做什麼之後，那麼什麼是 Builders？， Builders 是 Architect 要處理特定任務時所運行的工具，通常他會對應到 npm package，例如 packageing your libreay 或 building，和 serving application。</p>\n<p>通常 builders 會接收兩個參數，一組輸入 option ( a JSON object )，和一個 context ( a BuilderContext object )，option object 由 CLI 使用者提供，而 context 由 CLI Builder API 提供。</p>\n<p>Angular 提供了一些由 CLI 用於 ng build 和 ng test 等命令的 builders，這些內建的 CLI Builders 可以在 angular.json 的 “Architect” 部分找到，當然你也可以當然你也可以使用 ng run <targetName>來自定你想要的 builders，不過這有點過於深入不在本章節的討論範圍。</p>\n<h1 id=\"Understanding-the-command-mapping\"><a href=\"#Understanding-the-command-mapping\" class=\"headerlink\" title=\"Understanding the command mapping\"></a>Understanding the command mapping</h1><p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png\"></p>\n<p>正如我們前面所說的，當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作，所以當我們輸入了簡化的 command 後，實際上他會被 Architect 轉化成通用的 command : ng run projectName:architectTarget。</p>\n<p>Example: build: ng build… → ng run <projectName>:build</p>\n<p>知道了這一點後我們可以推敲一下這些命令在 Architect 轉換後會變成什麼：</p>\n<ul>\n<li>build: ng build … → ng run my-app:build;</li>\n<li>serve: ng serve … → ng run my-app:serve;</li>\n<li>e2e: ng e2e … → ng run my-app:e2e;</li>\n<li>test: ng test … → ng run my-app:test;</li>\n<li>lint: ng lint … → ng run my-app:lint;</li>\n<li>extract-i18n: ng xi18n … → ng run my-app:xi18n</li>\n</ul>\n<h1 id=\"Assets-configuration\"><a href=\"#Assets-configuration\" class=\"headerlink\" title=\"Assets configuration\"></a>Assets configuration</h1><p>在每一個 build target 中都可以有一個陣列，裡面可以放你想要的文件或文件夾，他會在你 build 專案的時候按照原樣複製一份，不會對他進行壓縮或打包，通常會把圖片放在這邊。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;assets&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"string\">&quot;src/assets&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"string\">&quot;src/favicon.ico&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以把 Assets 的內容變為一個一個的物件，這樣相較於只有填入檔案名稱或路徑會更清楚與更清晰，將 Assets 的內容變為物件可以具有以下個 key：</p>\n<ul>\n<li>glob：使用 node-glob 設置的基本目錄</li>\n<li>input：相對於 root 目錄的路徑</li>\n<li>output：相對於 outDir 的路徑，簡單來說就是 build 後存放的位置，預設是 dist &#x2F; project-name</li>\n<li>ignore：要排除的 glob 列表</li>\n<li>followSymlinks：使否允許搜尋符號鏈接的子目錄，默認為 false</li>\n</ul>\n<p>舉個例子你可以使用這些 key 更詳細描述你的 asset 路徑：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;assets&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;glob&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;**/*&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;input&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;src/assets/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;output&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/assets/&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;glob&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;favicon.ico&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;input&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;src/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;output&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本篇文章中大概了解的 angular.json 是個什麼東西，了解他與 Angular CLI 之間的關係，也大概個介紹了什麼是 Architect 與 builders ，不過都只是稍微講解一下概念並沒有太過深入鑽研他背後的運作原理，不過還是大概總結一下：</p>\n<ul>\n<li>angular.json 是 Angular CLI 的控制塔，它提供了 Angular workspace 和 project 的預設配置。</li>\n<li>講解了一些 angular.json 的資料架構。</li>\n<li>什麼是 Architect 和 Builders 與他們之間的關係。</li>\n<li>Angular CLI 是如何透過 Architect 解析命令的。</li>\n<li>如何透過 assets 在打包專案時複製完整的資料。</li>\n</ul>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://blog.nrwl.io/angular-cli-demystifying-the-workspace-7f59ffaab4cb\">Angular CLI — Demystifying the workspace</a></li>\n<li><a href=\"https://angular.io/guide/workspace-config\">Angular.io</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在上一篇中介紹了什麼是 Angular CLI 與他可以提供許多方便功能，不過只是大概介紹他的用法與他是什麼，要實際暸解到他背後的運行邏輯其實是滿複雜的，這邊就不詳細的講解（因為我也不太了解…</p>\n<p>不過說到 Angular CLI 就避免不了要介紹一下 Angular CLI 的控制塔 “ angular.json “， angular.json 是位於 Angular workspace root level 的一個文件，主要是<code>提供 workspace 的配置與 project 的預設配置，供 Angular CLI 中 build 和 development tool 使用</code>。</p>\n<blockquote>\n<p>A file named angular.json at the root level of an Angular workspace provides workspace-wide and project-specific configuration defaults for build and development tools provided by the Angular CLI. Path values given in the configuration are relative to the root workspace folder.</p>\n</blockquote>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767GwY7OIYgvq.png\"></p>","more":"<h1 id=\"Overall-JSON-structure\"><a href=\"#Overall-JSON-structure\" class=\"headerlink\" title=\"Overall JSON structure\"></a>Overall JSON structure</h1><p>大概講完 angular.json 是幹嘛的後接下來要分析一下 angular.json 的結構。</p>\n<p>angular.json 主要分為兩個區域： root 和 project。</p>\n<p>root 的部分主要是關於 workspace 的一些信息，主要用於配置 workspace，你會在上面找到：</p>\n<ul>\n<li><strong>version</strong>：你的 workspace 配置版本</li>\n<li><strong>newProjectRoot</strong>：這是用於創建新項目的路徑，比如使用 ng generate application <name> 或 ng generate library <name>，那麼 Angular CLI 會藉由這個路徑知道要從哪裡生成 applicatioon 或 library。</li>\n<li><strong>defaultProject</strong>：這是在你使用 ng new <name> 時所創建的屬性，他對應著你創建這個項目時給定的初始名稱，如果在使用 Angular CLI 時沒有填入項目名稱，則會直接將這個屬性帶入，比如說你要執行 app 時所使用的 ng server <name>，你可以直接執行 ng server 而不會出錯的原因就是它會自動將名稱帶入變成 ng server my-app。</li>\n<li><strong>projects</strong>：這裡包含了你的 application 和 library 所有必要的訊息。</li>\n<li><strong>schematics</strong>：用於客製化 ng generation 命令的預設選項。</li>\n</ul>\n<p>project 的部分包含 CLI 可以使用的特定訊息，你會在上面找到：</p>\n<ul>\n<li><strong>root</strong>：這是 project 相對於 workspace 的路徑。</li>\n<li><strong>sourceroot</strong>：這是包含當前項目 source file 的文件夾路徑。</li>\n<li><strong>projectType</strong>：可以是 application 或 library，CLI 需要知道專案類型，因為每種類型都有對應的需求與限制，比如說 library 需要被打包才能分發並且不能在與 application 相反的瀏覽器中提供服務。</li>\n<li><strong>prefix</strong>：這是當前項目 selectors 的前綴字串，當使用 ng generate component 時會將這個前綴字加在你的 component 前面，比如你的 prefix 這制為 gna，那麼使用 ng generate component hello-world 所創建出來的 component 的 selectors 就會是 “gna-hello-world”。</li>\n<li><strong>schematics</strong>：用於這是當前 project 中某些 schematics 所使用到的默認選項，比如你要將你專案的樣是從 CSS 變為 SCSS，就可以在這個屬性中添加 “styleext”:“scss”。</li>\n<li><strong>architect</strong>：為這個 project 各個 architect 提供預設值。</li>\n</ul>\n<p>下圖是一個簡單的 angular.json file，其中只有一個 build command。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767znwvhlEFXA.png\"></p>\n<h1 id=\"What-is-Architect\"><a href=\"#What-is-Architect\" class=\"headerlink\" title=\"What is Architect ?\"></a>What is Architect ?</h1><p>可能看到這邊很多人都會覺得還可以，畢竟這些 property 大概都能了解在幹嘛而且也可以在自己的 Angular app 中找到對應的位置，但是！ “Architect” 這個到底是什麼？，可能對很多新手來說相當的複雜（我現在也迷迷糊糊，有說錯的話歡迎指正），接下來我們就來看看 Angular 官網是怎麼描述這個東西的。</p>\n<blockquote>\n<p>Architect is the tool that the CLI uses to perform complex tasks, such as compilation and test running</p>\n</blockquote>\n<p>Architect 是 CLI 用來執行複雜任務的工具，例如 compilation 和 test running，而 Architect 是一個 shell，它根據 target configuration 執行指定的 Builder 來執行給定的任務</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767ZvVJbw5arN.png\"></p>\n<p>可以把它看作是 <code>Angular CLI 與 builder 之間的 &quot;中間人&quot;</code>，Architect 是可以訪問或修改特定 builder 選項或添加選項配置的地方，<code>當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作</code>。</p>\n<h1 id=\"What-is-Builders\"><a href=\"#What-is-Builders\" class=\"headerlink\" title=\"What is Builders ?\"></a>What is Builders ?</h1><p>大概了解 Architect 是什麼並且他在做什麼之後，那麼什麼是 Builders？， Builders 是 Architect 要處理特定任務時所運行的工具，通常他會對應到 npm package，例如 packageing your libreay 或 building，和 serving application。</p>\n<p>通常 builders 會接收兩個參數，一組輸入 option ( a JSON object )，和一個 context ( a BuilderContext object )，option object 由 CLI 使用者提供，而 context 由 CLI Builder API 提供。</p>\n<p>Angular 提供了一些由 CLI 用於 ng build 和 ng test 等命令的 builders，這些內建的 CLI Builders 可以在 angular.json 的 “Architect” 部分找到，當然你也可以當然你也可以使用 ng run <targetName>來自定你想要的 builders，不過這有點過於深入不在本章節的討論範圍。</p>\n<h1 id=\"Understanding-the-command-mapping\"><a href=\"#Understanding-the-command-mapping\" class=\"headerlink\" title=\"Understanding the command mapping\"></a>Understanding the command mapping</h1><p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210729/20124767Stj9kOMC1l.png\"></p>\n<p>正如我們前面所說的，當你輸入 command 後 Architect 會對 command 進行分析、解析最後對正確的 builder 執行請求操作，所以當我們輸入了簡化的 command 後，實際上他會被 Architect 轉化成通用的 command : ng run projectName:architectTarget。</p>\n<p>Example: build: ng build… → ng run <projectName>:build</p>\n<p>知道了這一點後我們可以推敲一下這些命令在 Architect 轉換後會變成什麼：</p>\n<ul>\n<li>build: ng build … → ng run my-app:build;</li>\n<li>serve: ng serve … → ng run my-app:serve;</li>\n<li>e2e: ng e2e … → ng run my-app:e2e;</li>\n<li>test: ng test … → ng run my-app:test;</li>\n<li>lint: ng lint … → ng run my-app:lint;</li>\n<li>extract-i18n: ng xi18n … → ng run my-app:xi18n</li>\n</ul>\n<h1 id=\"Assets-configuration\"><a href=\"#Assets-configuration\" class=\"headerlink\" title=\"Assets configuration\"></a>Assets configuration</h1><p>在每一個 build target 中都可以有一個陣列，裡面可以放你想要的文件或文件夾，他會在你 build 專案的時候按照原樣複製一份，不會對他進行壓縮或打包，通常會把圖片放在這邊。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;assets&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"string\">&quot;src/assets&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"string\">&quot;src/favicon.ico&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以把 Assets 的內容變為一個一個的物件，這樣相較於只有填入檔案名稱或路徑會更清楚與更清晰，將 Assets 的內容變為物件可以具有以下個 key：</p>\n<ul>\n<li>glob：使用 node-glob 設置的基本目錄</li>\n<li>input：相對於 root 目錄的路徑</li>\n<li>output：相對於 outDir 的路徑，簡單來說就是 build 後存放的位置，預設是 dist &#x2F; project-name</li>\n<li>ignore：要排除的 glob 列表</li>\n<li>followSymlinks：使否允許搜尋符號鏈接的子目錄，默認為 false</li>\n</ul>\n<p>舉個例子你可以使用這些 key 更詳細描述你的 asset 路徑：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;assets&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;glob&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;**/*&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;input&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;src/assets/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;output&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/assets/&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;glob&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;favicon.ico&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;input&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;src/&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;output&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本篇文章中大概了解的 angular.json 是個什麼東西，了解他與 Angular CLI 之間的關係，也大概個介紹了什麼是 Architect 與 builders ，不過都只是稍微講解一下概念並沒有太過深入鑽研他背後的運作原理，不過還是大概總結一下：</p>\n<ul>\n<li>angular.json 是 Angular CLI 的控制塔，它提供了 Angular workspace 和 project 的預設配置。</li>\n<li>講解了一些 angular.json 的資料架構。</li>\n<li>什麼是 Architect 和 Builders 與他們之間的關係。</li>\n<li>Angular CLI 是如何透過 Architect 解析命令的。</li>\n<li>如何透過 assets 在打包專案時複製完整的資料。</li>\n</ul>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://blog.nrwl.io/angular-cli-demystifying-the-workspace-7f59ffaab4cb\">Angular CLI — Demystifying the workspace</a></li>\n<li><a href=\"https://angular.io/guide/workspace-config\">Angular.io</a></li>\n</ul>"},{"title":"Day4. Component","date":"2022-02-15T07:06:26.000Z","_content":"\n講完前面幾張比較偏向原理與不常使用到的章節後，從這章節開始會介紹比較實際運用的東西。\n\n就像在 Day1 所提到的，`Angular app 是由無數個大大小小的 Component 所組合而成的`，也可以說 Angular app 的基本單位就是 Component，所以 Component 在 Angular 中是非常重要的觀念，每個 Component 都包含著：\n\n- 一個 HTML Template，用於將 Component 的內容顯示在 UI 上。\n- 一個 TypeScript 的 Class\n- 一個 selector，用於定義這個 Component 如何在別的 Component 中被使用。\n- 一個 CSS style 的檔案，用於決定這個 Component 在 UI 上呈現的樣式。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png)\n\n<!--more-->\n\n# Create a component\n在介紹什麼是 Component 之前，最重要的就是先創建一個 Component 出來，最簡單的方法就是使用 Angular CLI 來自動創建，當然你也可以手動新增檔案然後把所有需要的訊息補上\n\n要自動化創造一個新的 Component，首先要在終端機中輸入 Angular CLI Command\n```bash\nng generate component <component-name>\nng g c <component-name>\n```\n\n在默認情況下，會自動創建出：\n\n- 以 component-name 所命名的資料夾\n- 一個 component file,  <component-name>.component.ts\n- 一個 HTML Template file,  <component-name>.component.html\n- 一個 CSS file,  <component-name>.component.css\n- 一個測試規範文件,  <component-name>.component.spec.ts\n\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png)\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png)\n\n\n# Specifying a component's CSS selector\n每一個 Component 都需要一個 CSS Selector，這個 selector 會讓 Angular 知道他應該要在哪裡找到訊息並將他實例化，簡單來說可以把它當成這個 Component 在 Angular 的`身份證號碼`，當 Angular 在 HTML 中發現這個身份證號碼後，他就會知道該去哪裡把這個 Component 給實例化。\n\n舉個例子，如果今天有一個 component 叫做 hello-world.component.ts，他的 selector 叫 app-hello-world，所以每當 Angular 在任何一個 HTML Template 中出現時，他就知道要去把 hello-world.component.ts 這個 Component 給實例化。\n\n```typescript\n@Component({\n  selector: 'app-hello-world',\n})\n```\n\n\n# Defining a component's template\n在了解 Angular 是如何透過 selector 找到對應的 Component 並將他實例化後，接下來介紹的是\n\nTemplate，他其實就是一個 HTML，它告訴 Angular 要把這個 Component 如何呈現在 UI 上，可以通過兩種方法定義 Template，第一種是引用外部文件，第二種是直接將你的 HTML 寫在 Component 中。\n \n- 引用外部文件\n``` typescript\n@Component({\n  selector: 'app-hello-world',\n  templateUrl: './hello-world.component.html',\n})\n```\n- 直接寫 HTML 在 Component 中\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  template: '<h1>Hello World!</h1>',\n})\n```\n除了使用 ( ' ' ) 包裹著 HTML Tag 之外，也可以使用反引號 ( ` ) 一次輸入多個 Tag\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  template: `\n\t  <h1>Hello World!</h1>\n\t  <p>This template definition spans multiple lines.</p>\n\t`,\n})\n```\n\n兩種方法都可以設定你的 HTML Template，但是要注意，如果使用`外部文件的話是使用 templateUrl`，而`直接填入 HTML Tag 則是使用 template`。\n\n\n\n# Declaring a component's styles\n有了身份證號碼有了畫面接下來就要讓畫面多一點美感，這時候就需要使用 CSS 來美化我們的 UI，和 Template 一樣可以透過兩種方式聲明 CSS，第一是引用外部文件，第二是直接寫在 Component 中。\n\n- 引用外部文件\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  templateUrl: './hello-world.component.html',\n  styleUrls: [ './hello-world.component.css' ]\n})\n```\n- 直接寫在 Component 中\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  template: '<h1>Hello World!</h1>',\n\tstyles: [ 'h1 { font-weight: normal; }' ]\n})\n```\nStyle 與 Template 一樣，如果是`引用外部文件是使用 styleUrls`，而`直接寫在 Component 中是使用styles`。\n\n\n# 結論\n本章節比較輕鬆一點，介紹了如何創建一個新的 Component，並瞭解一個 component 是由哪些元素組成，並且這些元素是代表什麼，下一篇我們會介紹 Component 的 Lifecycle，是在開發 Angular App 中非常常使用到的觀念，那我們就下篇再見吧。\n\n\n# Reference\n- [Angular.io - Component-overview](https://angular.io/guide/component-overview)\n","source":"_posts/Angular/angular-04.md","raw":"---\ntitle: Day4. Component\ndate: 2022-02-15 15:06:26\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n講完前面幾張比較偏向原理與不常使用到的章節後，從這章節開始會介紹比較實際運用的東西。\n\n就像在 Day1 所提到的，`Angular app 是由無數個大大小小的 Component 所組合而成的`，也可以說 Angular app 的基本單位就是 Component，所以 Component 在 Angular 中是非常重要的觀念，每個 Component 都包含著：\n\n- 一個 HTML Template，用於將 Component 的內容顯示在 UI 上。\n- 一個 TypeScript 的 Class\n- 一個 selector，用於定義這個 Component 如何在別的 Component 中被使用。\n- 一個 CSS style 的檔案，用於決定這個 Component 在 UI 上呈現的樣式。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png)\n\n<!--more-->\n\n# Create a component\n在介紹什麼是 Component 之前，最重要的就是先創建一個 Component 出來，最簡單的方法就是使用 Angular CLI 來自動創建，當然你也可以手動新增檔案然後把所有需要的訊息補上\n\n要自動化創造一個新的 Component，首先要在終端機中輸入 Angular CLI Command\n```bash\nng generate component <component-name>\nng g c <component-name>\n```\n\n在默認情況下，會自動創建出：\n\n- 以 component-name 所命名的資料夾\n- 一個 component file,  <component-name>.component.ts\n- 一個 HTML Template file,  <component-name>.component.html\n- 一個 CSS file,  <component-name>.component.css\n- 一個測試規範文件,  <component-name>.component.spec.ts\n\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png)\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png)\n\n\n# Specifying a component's CSS selector\n每一個 Component 都需要一個 CSS Selector，這個 selector 會讓 Angular 知道他應該要在哪裡找到訊息並將他實例化，簡單來說可以把它當成這個 Component 在 Angular 的`身份證號碼`，當 Angular 在 HTML 中發現這個身份證號碼後，他就會知道該去哪裡把這個 Component 給實例化。\n\n舉個例子，如果今天有一個 component 叫做 hello-world.component.ts，他的 selector 叫 app-hello-world，所以每當 Angular 在任何一個 HTML Template 中出現時，他就知道要去把 hello-world.component.ts 這個 Component 給實例化。\n\n```typescript\n@Component({\n  selector: 'app-hello-world',\n})\n```\n\n\n# Defining a component's template\n在了解 Angular 是如何透過 selector 找到對應的 Component 並將他實例化後，接下來介紹的是\n\nTemplate，他其實就是一個 HTML，它告訴 Angular 要把這個 Component 如何呈現在 UI 上，可以通過兩種方法定義 Template，第一種是引用外部文件，第二種是直接將你的 HTML 寫在 Component 中。\n \n- 引用外部文件\n``` typescript\n@Component({\n  selector: 'app-hello-world',\n  templateUrl: './hello-world.component.html',\n})\n```\n- 直接寫 HTML 在 Component 中\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  template: '<h1>Hello World!</h1>',\n})\n```\n除了使用 ( ' ' ) 包裹著 HTML Tag 之外，也可以使用反引號 ( ` ) 一次輸入多個 Tag\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  template: `\n\t  <h1>Hello World!</h1>\n\t  <p>This template definition spans multiple lines.</p>\n\t`,\n})\n```\n\n兩種方法都可以設定你的 HTML Template，但是要注意，如果使用`外部文件的話是使用 templateUrl`，而`直接填入 HTML Tag 則是使用 template`。\n\n\n\n# Declaring a component's styles\n有了身份證號碼有了畫面接下來就要讓畫面多一點美感，這時候就需要使用 CSS 來美化我們的 UI，和 Template 一樣可以透過兩種方式聲明 CSS，第一是引用外部文件，第二是直接寫在 Component 中。\n\n- 引用外部文件\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  templateUrl: './hello-world.component.html',\n  styleUrls: [ './hello-world.component.css' ]\n})\n```\n- 直接寫在 Component 中\n```typescript\n@Component({\n  selector: 'app-hello-world',\n  template: '<h1>Hello World!</h1>',\n\tstyles: [ 'h1 { font-weight: normal; }' ]\n})\n```\nStyle 與 Template 一樣，如果是`引用外部文件是使用 styleUrls`，而`直接寫在 Component 中是使用styles`。\n\n\n# 結論\n本章節比較輕鬆一點，介紹了如何創建一個新的 Component，並瞭解一個 component 是由哪些元素組成，並且這些元素是代表什麼，下一篇我們會介紹 Component 的 Lifecycle，是在開發 Angular App 中非常常使用到的觀念，那我們就下篇再見吧。\n\n\n# Reference\n- [Angular.io - Component-overview](https://angular.io/guide/component-overview)\n","slug":"Angular/angular-04","published":1,"updated":"2022-02-15T07:16:08.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmnj0009kww3b3tea85s","content":"<p>講完前面幾張比較偏向原理與不常使用到的章節後，從這章節開始會介紹比較實際運用的東西。</p>\n<p>就像在 Day1 所提到的，<code>Angular app 是由無數個大大小小的 Component 所組合而成的</code>，也可以說 Angular app 的基本單位就是 Component，所以 Component 在 Angular 中是非常重要的觀念，每個 Component 都包含著：</p>\n<ul>\n<li>一個 HTML Template，用於將 Component 的內容顯示在 UI 上。</li>\n<li>一個 TypeScript 的 Class</li>\n<li>一個 selector，用於定義這個 Component 如何在別的 Component 中被使用。</li>\n<li>一個 CSS style 的檔案，用於決定這個 Component 在 UI 上呈現的樣式。</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Create-a-component\"><a href=\"#Create-a-component\" class=\"headerlink\" title=\"Create a component\"></a>Create a component</h1><p>在介紹什麼是 Component 之前，最重要的就是先創建一個 Component 出來，最簡單的方法就是使用 Angular CLI 來自動創建，當然你也可以手動新增檔案然後把所有需要的訊息補上</p>\n<p>要自動化創造一個新的 Component，首先要在終端機中輸入 Angular CLI Command</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component &lt;component-name&gt;</span><br><span class=\"line\">ng g c &lt;component-name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在默認情況下，會自動創建出：</p>\n<ul>\n<li>以 component-name 所命名的資料夾</li>\n<li>一個 component file,  <component-name>.component.ts</li>\n<li>一個 HTML Template file,  <component-name>.component.html</li>\n<li>一個 CSS file,  <component-name>.component.css</li>\n<li>一個測試規範文件,  <component-name>.component.spec.ts</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png\"><br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png\"></p>\n<h1 id=\"Specifying-a-component’s-CSS-selector\"><a href=\"#Specifying-a-component’s-CSS-selector\" class=\"headerlink\" title=\"Specifying a component’s CSS selector\"></a>Specifying a component’s CSS selector</h1><p>每一個 Component 都需要一個 CSS Selector，這個 selector 會讓 Angular 知道他應該要在哪裡找到訊息並將他實例化，簡單來說可以把它當成這個 Component 在 Angular 的<code>身份證號碼</code>，當 Angular 在 HTML 中發現這個身份證號碼後，他就會知道該去哪裡把這個 Component 給實例化。</p>\n<p>舉個例子，如果今天有一個 component 叫做 hello-world.component.ts，他的 selector 叫 app-hello-world，所以每當 Angular 在任何一個 HTML Template 中出現時，他就知道要去把 hello-world.component.ts 這個 Component 給實例化。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Defining-a-component’s-template\"><a href=\"#Defining-a-component’s-template\" class=\"headerlink\" title=\"Defining a component’s template\"></a>Defining a component’s template</h1><p>在了解 Angular 是如何透過 selector 找到對應的 Component 並將他實例化後，接下來介紹的是</p>\n<p>Template，他其實就是一個 HTML，它告訴 Angular 要把這個 Component 如何呈現在 UI 上，可以通過兩種方法定義 Template，第一種是引用外部文件，第二種是直接將你的 HTML 寫在 Component 中。</p>\n<ul>\n<li>引用外部文件<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./hello-world.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>直接寫 HTML 在 Component 中<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n除了使用 ( ‘ ‘ ) 包裹著 HTML Tag 之外，也可以使用反引號 ( &#96; ) 一次輸入多個 Tag<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">\t  &lt;h1&gt;Hello World!&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t  &lt;p&gt;This template definition spans multiple lines.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t`</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>兩種方法都可以設定你的 HTML Template，但是要注意，如果使用<code>外部文件的話是使用 templateUrl</code>，而<code>直接填入 HTML Tag 則是使用 template</code>。</p>\n<h1 id=\"Declaring-a-component’s-styles\"><a href=\"#Declaring-a-component’s-styles\" class=\"headerlink\" title=\"Declaring a component’s styles\"></a>Declaring a component’s styles</h1><p>有了身份證號碼有了畫面接下來就要讓畫面多一點美感，這時候就需要使用 CSS 來美化我們的 UI，和 Template 一樣可以透過兩種方式聲明 CSS，第一是引用外部文件，第二是直接寫在 Component 中。</p>\n<ul>\n<li>引用外部文件<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./hello-world.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [ <span class=\"string\">&#x27;./hello-world.component.css&#x27;</span> ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>直接寫在 Component 中<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">styles</span>: [ <span class=\"string\">&#x27;h1 &#123; font-weight: normal; &#125;&#x27;</span> ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\nStyle 與 Template 一樣，如果是<code>引用外部文件是使用 styleUrls</code>，而<code>直接寫在 Component 中是使用styles</code>。</li>\n</ul>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本章節比較輕鬆一點，介紹了如何創建一個新的 Component，並瞭解一個 component 是由哪些元素組成，並且這些元素是代表什麼，下一篇我們會介紹 Component 的 Lifecycle，是在開發 Angular App 中非常常使用到的觀念，那我們就下篇再見吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/component-overview\">Angular.io - Component-overview</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>講完前面幾張比較偏向原理與不常使用到的章節後，從這章節開始會介紹比較實際運用的東西。</p>\n<p>就像在 Day1 所提到的，<code>Angular app 是由無數個大大小小的 Component 所組合而成的</code>，也可以說 Angular app 的基本單位就是 Component，所以 Component 在 Angular 中是非常重要的觀念，每個 Component 都包含著：</p>\n<ul>\n<li>一個 HTML Template，用於將 Component 的內容顯示在 UI 上。</li>\n<li>一個 TypeScript 的 Class</li>\n<li>一個 selector，用於定義這個 Component 如何在別的 Component 中被使用。</li>\n<li>一個 CSS style 的檔案，用於決定這個 Component 在 UI 上呈現的樣式。</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767ow9wdaimBy.png\"></p>","more":"<h1 id=\"Create-a-component\"><a href=\"#Create-a-component\" class=\"headerlink\" title=\"Create a component\"></a>Create a component</h1><p>在介紹什麼是 Component 之前，最重要的就是先創建一個 Component 出來，最簡單的方法就是使用 Angular CLI 來自動創建，當然你也可以手動新增檔案然後把所有需要的訊息補上</p>\n<p>要自動化創造一個新的 Component，首先要在終端機中輸入 Angular CLI Command</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component &lt;component-name&gt;</span><br><span class=\"line\">ng g c &lt;component-name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在默認情況下，會自動創建出：</p>\n<ul>\n<li>以 component-name 所命名的資料夾</li>\n<li>一個 component file,  <component-name>.component.ts</li>\n<li>一個 HTML Template file,  <component-name>.component.html</li>\n<li>一個 CSS file,  <component-name>.component.css</li>\n<li>一個測試規範文件,  <component-name>.component.spec.ts</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767XlBg9RHWON.png\"><br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767c8SVZdpzx9.png\"></p>\n<h1 id=\"Specifying-a-component’s-CSS-selector\"><a href=\"#Specifying-a-component’s-CSS-selector\" class=\"headerlink\" title=\"Specifying a component’s CSS selector\"></a>Specifying a component’s CSS selector</h1><p>每一個 Component 都需要一個 CSS Selector，這個 selector 會讓 Angular 知道他應該要在哪裡找到訊息並將他實例化，簡單來說可以把它當成這個 Component 在 Angular 的<code>身份證號碼</code>，當 Angular 在 HTML 中發現這個身份證號碼後，他就會知道該去哪裡把這個 Component 給實例化。</p>\n<p>舉個例子，如果今天有一個 component 叫做 hello-world.component.ts，他的 selector 叫 app-hello-world，所以每當 Angular 在任何一個 HTML Template 中出現時，他就知道要去把 hello-world.component.ts 這個 Component 給實例化。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Defining-a-component’s-template\"><a href=\"#Defining-a-component’s-template\" class=\"headerlink\" title=\"Defining a component’s template\"></a>Defining a component’s template</h1><p>在了解 Angular 是如何透過 selector 找到對應的 Component 並將他實例化後，接下來介紹的是</p>\n<p>Template，他其實就是一個 HTML，它告訴 Angular 要把這個 Component 如何呈現在 UI 上，可以通過兩種方法定義 Template，第一種是引用外部文件，第二種是直接將你的 HTML 寫在 Component 中。</p>\n<ul>\n<li>引用外部文件<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./hello-world.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>直接寫 HTML 在 Component 中<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n除了使用 ( ‘ ‘ ) 包裹著 HTML Tag 之外，也可以使用反引號 ( &#96; ) 一次輸入多個 Tag<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">\t  &lt;h1&gt;Hello World!&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t  &lt;p&gt;This template definition spans multiple lines.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t`</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>兩種方法都可以設定你的 HTML Template，但是要注意，如果使用<code>外部文件的話是使用 templateUrl</code>，而<code>直接填入 HTML Tag 則是使用 template</code>。</p>\n<h1 id=\"Declaring-a-component’s-styles\"><a href=\"#Declaring-a-component’s-styles\" class=\"headerlink\" title=\"Declaring a component’s styles\"></a>Declaring a component’s styles</h1><p>有了身份證號碼有了畫面接下來就要讓畫面多一點美感，這時候就需要使用 CSS 來美化我們的 UI，和 Template 一樣可以透過兩種方式聲明 CSS，第一是引用外部文件，第二是直接寫在 Component 中。</p>\n<ul>\n<li>引用外部文件<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./hello-world.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [ <span class=\"string\">&#x27;./hello-world.component.css&#x27;</span> ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>直接寫在 Component 中<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-hello-world&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">styles</span>: [ <span class=\"string\">&#x27;h1 &#123; font-weight: normal; &#125;&#x27;</span> ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\nStyle 與 Template 一樣，如果是<code>引用外部文件是使用 styleUrls</code>，而<code>直接寫在 Component 中是使用styles</code>。</li>\n</ul>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本章節比較輕鬆一點，介紹了如何創建一個新的 Component，並瞭解一個 component 是由哪些元素組成，並且這些元素是代表什麼，下一篇我們會介紹 Component 的 Lifecycle，是在開發 Angular App 中非常常使用到的觀念，那我們就下篇再見吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/component-overview\">Angular.io - Component-overview</a></li>\n</ul>"},{"title":"Day5. Lifecycle hooks","date":"2022-02-15T07:17:07.000Z","_content":"\n在 Angular 的 Component 中有一個生命週期，`當 Angular 實例化這個 Component 並且把它或他的 sub-component 呈現在 UI 時便會開始`，而 Lifecycle 會持續的檢測是否有綁定的數據被更改，因為這些綁定數據的更改可能會需要更新 UI 或 Component 的內容，而當 Angular 銷毀了這個 Component 實例並從 DOM 中移除這個 Component 的 Template 後 Lifecycle 就會結束。\n\n簡單來說，當 Angular 在某一個地方的 HTML 發現了一個 Component 的 selector（身分證號碼）後，便會找到這個 Component 並將他實例化和將他的 Template 呈現在 UI 上（放進 DOM 中），這個時候這個 Component 就開始了他的一生，他會在他的一生中不斷的檢測是否有東西需要改變，最後當使用者離開了這個頁面，代表著這個 Component 不在被需要了，他就會被銷毀掉結束他的一生。\n\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png)\n\n<!--more-->\n\n# Responding to lifecycle events\n了解了什麼是 Lifecycle 後，我們要正式介紹 Lifecycle 了，首先你可以透過 import `angular/core` 引入一個或多個 lifecycle 使用。\n```typescript\nimport { Component, OnInit, OnChanges, ... } from '@angular/core';\n```\n\n每一個 Lifecycle  method 前面都有 `ng` 當作前綴字，舉例來說如果要使用 OnInit 這個 Lifecycle method 則要在你的 TypeScript Class 中輸入 ngOnInit( )，而當你要使用某一個 Lifycycle method 時，記得要在你的 Class 使用 `implements` 繼承這個 Lifycycle。\n```typescript\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-first-component',\n  templateUrl: './first-component.component.html',\n  styleUrls: ['./first-component.component.css']\n})\nexport class FirstComponentComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n```\n\n## Lifecycle event sequence\n每一個 Lifecycle method 都有對應的被調用時機，Angular 會自動在最適當的時間調用適當的  Lifecycle method，以下是 Angular 按照順序執行的 Lifecycle method。\n\n| Name   |      Purpose      |  Timing\n|----------|:-------------:|:-------------:|\n| ngOnChanges() |  當這制或重置綁定的數據時會被調用，比如你在這個 Component 中綁定了一個由父層傳下來的數據，當這個數據發生改變（父層丟新的東西下來）時就會觸發，要注意的是如果在這個 method 的邏輯沒有處理好，可能會發生無限迴圈的問題，所以需要特別注意。 | 他會在 Component 剛被創造出來就被調用一次，會`比 OnInit() 還早`，還有每當一個或多個數據綁定 @Input 屬性發生改變時會觸發。 \n| ngOnInit() | 會在 Component 完成數據綁定（ngOnChanges）後初始化 Component。 | 在第一個 ngOnChange() 之後觸發，只會被調用一次。\n| ngDoCheck() | `當 Angular 無法獲不會自動檢測到變化並採取行動`，在每次更改檢測運行期間被調用，會跟在 ngOnChanges() 和 ngOnInit() 後面，有點抽象我會在下面有詳細解釋。 | 在每次更改檢測運行時立即在 ngOnChanges() 之後調用，在第一次運行時立即在 ngOnInit() 之後調用。\n| ngAfterContentInit() | Angular 將 ng-content 的內容投影到 Component 的 view 後被調用 | 在第一個 ngDoCheck() 後被調用\n| ngAfterContentChecked() | 每次完成 ng-content 的變更檢測之後調用 | 在 ngAfterContentInit() 之後和每一個 ngDoCheck() 之後被調用\n| ngAfterViewInit() | 當 Angular 初始化自身 Component和子 Component 的 view 後被調用。 | 在第一個 ngAfterContentChecked() 之後調用一次\n| ngAfterViewChecked() | 每次做完自身 Component和子 Component 的變更檢測後呼叫 | 在 ngAfterViewInit() 和每個 ngAfterContentChecked() 之後調用\n| ngOnDestroy() |  在 Angular 銷毀 directive 或 Component 之前調用，主要用於 unsubscribe Observable 以防內存泄露 | 在 Angular 銷毀 directive 或 Component 之前立即調用\n\n## 詳解 ngDoCheck()\n當我第一次在 Angular 官方文件中看到這個我看了十幾次我都看不懂，查了一些文章後才大概了解他是在什麼時候被呼叫到，我們就來詳細介紹一下吧。\n\n在 Angular 官方文檔中這樣寫到：\n> Detect and act upon changes that Angular can’t or won’t detect on its own.\nCalled during every change detection run, immediately after ngOnChanges() and ngOnInit()\n\n相當抽象對吧，，雖然知道他會是在 ngOnChanges( ) 和 ngOnInit( ) 之後觸發的，但是當他被觸發的時候 Component 是否有被檢查？而 Angular 無法自動檢查是指什麼？要解答這個問題我們需要先了解什麼是 Component check，在 Component 變更檢測有三個核心的操作：\n\n- update child component input binding ( @Input( ) )\n- update DOM interpolations ( 在 Template 中的 {{ value }} )\n- update query list\n\n除了這些之外 Angular 還會觸發 Lifecycle 作為變更檢測的一部分，所以當檢查父層時會觸發子層的 Lifycycle，假設我們有一個這樣的結構：\n```\nComponentA\n\tComponentB\n\t\tComponentC\n```\n當 Angular 運行檢測時的順序如下：\n```\nChecking A component:\n  - update B input bindings\n  - call NgDoCheck on the B component\n  - update DOM interpolations for component A\n \n Checking B component:\n    - update C input bindings\n    - call NgDoCheck on the C component\n    - update DOM interpolations for component B\n \n   Checking C component:\n      - update DOM interpolations for component C\n```\n上面的順序只是一個簡單的順序列表，可以看到 DoCheck 會在何時被觸發。\n\n可以看到在檢查父層時子層就會調用 ngDoCheck ，假設我們在 ComponentB 使用了 onPush 會發生什麼事：\n```\nChecking A component:\n  - update B input bindings\n  - call NgDoCheck on the B component\n  - update DOM interpolations for component A\n  \n if (bindings changed) -> checking B component:\n    - update C input bindings\n    - call NgDoCheck on the C component\n    - update DOM interpolations for component B\n \n   Checking C component:\n      - update DOM interpolations for component C\n```\n可以看到我們在 ComponenB 檢測前加上了一個小判斷，如果這個判斷為 false 就會滿足官方文檔提到的`當 Angular 無法獲不會自動檢測到變化並採取行動`，所以即使不會檢查 ComponentB 但是仍然會觸發 ComponentB 上面的 ngDoCheck。\n\n我們來透過程式碼直接操作看看，首先我們先定義一個 sub-component\n```typescript\n@Component({\n  selector: 'app-first-component',\n  template: '<h2>The name is: {{o.name}}</h2>',\n  changeDetection: ChangeDetectionStrategy.OnPush // (1)\n})\n\nexport class FirstComponentComponent implements OnChanges {\n\t@Input() o: { id: number; name: string; } = { id: NaN, name: '' }; // (2)\n\n\tid: number = NaN;\n\n  ngOnChanges() {\n    console.log('first-component OnChange() been call');  // (3)\n    this.id = this.o.id;\n  }\n\n  ngDoCheck() {\n    console.log('first-component DoCheck() been call');  // (4)\n    if (this.id !== this.o.id) {\n      this.cd.markForCheck();\n    }\n  }\n}\n```\n- （1）：利用 OnPush 來變更檢測策略。\n- （2）：使用 @Input( ) 綁定一個 input binding\n- （3）：當 @Input( ) 發生改變時，觸發 sub-component 中的 ngOnChanges\n- （4）：當父層發生變化時，觸發 sub-component 的 ngDoCheck\n\n接著我們在父層將 o 這個物件向下傳給 sub-component，在2秒內他通過更新 name 和 id 來改變這個物件\n```typescript\n@Component({\n  selector: 'app-root',\n  template: `\n\t\t<h1>Hello {{name}}</h1>\n    <a-comp [o]=\"o\"></a-comp>  // (1)\n\t`\n})\nexport class AppComponent implements OnInit{\n  o = {id: 1, name: 'Fandix'};\n\n  ngOnInit() {\n    setTimeout(() => {         // (2)\n      this.o.id = 2;\n      this.o.name = 'Jane';\n    }, 2000);\n  }\n}\n```\n- （1）： 將 o 向下傳遞給 sub-component\n- （2）：利用 setTimeout 在經過兩秒後更改 o 的 property\n\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png)\n\n由於 Angular 追蹤的是 o 這個物件的 reference，所以當我們以不更改 reference 的情況下改變 o 的內容就不會被 Angular 檢測到，這就是為什麼 sub-component 的 ngOnChanges() 只有被呼叫一次（創建 Component 時第一次呼叫），但是經過上面的解說後可以知道，`就算 sub-component 不會被 Angular 給自動檢測，但是由於父層發生了改變就會讓子層的 ngDoCheck 自動被呼叫到`，所以在 AppComponent 發生改變時 sub-component 的 ngDoCheck 依然會被觸發，這就是`當 Angular 無法或不會自動檢測到變化並採取行動`的意思。\n\n\n# Initializing a component or directive\n大概介紹完 Angular 的 Lifecycle，我們來看看 ngOnInit 的使用場景。\n\n- 在 construstor 之外執行邏輯複雜的初始化任務，如果是 fetch data 就不應該在 constructor 做而應該要在 ngOnInit 處理。\n- 可以在 ngOnInit 中設置輸入屬性，constructor 應該只將初始局部變量設置為簡單的值，所以如果你需要根據 @Input() 的值來設定內容的話，需要在 ngOnInit 中處理。\n\n\n# Cleaning up on instance destruction\n在開發 Angular component 時可以將清理的邏輯放在 ngOnDestroy( ) 中，這些邏輯必須在 Angular 銷毀這個 Component 之前執行，這裡是`釋放不會自動釋放資源的地方`，如果一直建立不會自動釋放資源的東西最後卻沒有將他清理掉，可能會造成內存洩漏或滿載的問題，這裡可以用來：\n\n- Unsubscribe Observable 和 DOM event\n- 停止 interval timers\n- Unregister 所有影響到別的地方的 callback function\n\n\n# 結論\n在本章中我們談到了 Angular 的 Lifecycle，了解有哪些 Lifecycle method 可以使用以及他們被調用的時機點，掌握好如何在對的時機點使用對的 Lifecycle method 是非常重要的，如果在錯的時間使用錯的 Lifecycle method 會造成非預期的錯誤，下一章將介紹在 Angular 中父子層 Component 之間是如何共享數據的，雖然在本章節有提到一點點（ @Input( ) ），不過將會在下一張更詳細的說明，那我們下一章再見。\n\n\n# Reference\n- [Angular.io - lifechcke hook](https://angular.io/guide/lifecycle-hooks)\n- [If you think ngDoCheck means your component is being checked — read this article](https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article)\n\n","source":"_posts/Angular/angular-05.md","raw":"---\ntitle: Day5. Lifecycle hooks\ndate: 2022-02-15 15:17:07\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n在 Angular 的 Component 中有一個生命週期，`當 Angular 實例化這個 Component 並且把它或他的 sub-component 呈現在 UI 時便會開始`，而 Lifecycle 會持續的檢測是否有綁定的數據被更改，因為這些綁定數據的更改可能會需要更新 UI 或 Component 的內容，而當 Angular 銷毀了這個 Component 實例並從 DOM 中移除這個 Component 的 Template 後 Lifecycle 就會結束。\n\n簡單來說，當 Angular 在某一個地方的 HTML 發現了一個 Component 的 selector（身分證號碼）後，便會找到這個 Component 並將他實例化和將他的 Template 呈現在 UI 上（放進 DOM 中），這個時候這個 Component 就開始了他的一生，他會在他的一生中不斷的檢測是否有東西需要改變，最後當使用者離開了這個頁面，代表著這個 Component 不在被需要了，他就會被銷毀掉結束他的一生。\n\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png)\n\n<!--more-->\n\n# Responding to lifecycle events\n了解了什麼是 Lifecycle 後，我們要正式介紹 Lifecycle 了，首先你可以透過 import `angular/core` 引入一個或多個 lifecycle 使用。\n```typescript\nimport { Component, OnInit, OnChanges, ... } from '@angular/core';\n```\n\n每一個 Lifecycle  method 前面都有 `ng` 當作前綴字，舉例來說如果要使用 OnInit 這個 Lifecycle method 則要在你的 TypeScript Class 中輸入 ngOnInit( )，而當你要使用某一個 Lifycycle method 時，記得要在你的 Class 使用 `implements` 繼承這個 Lifycycle。\n```typescript\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-first-component',\n  templateUrl: './first-component.component.html',\n  styleUrls: ['./first-component.component.css']\n})\nexport class FirstComponentComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n```\n\n## Lifecycle event sequence\n每一個 Lifecycle method 都有對應的被調用時機，Angular 會自動在最適當的時間調用適當的  Lifecycle method，以下是 Angular 按照順序執行的 Lifecycle method。\n\n| Name   |      Purpose      |  Timing\n|----------|:-------------:|:-------------:|\n| ngOnChanges() |  當這制或重置綁定的數據時會被調用，比如你在這個 Component 中綁定了一個由父層傳下來的數據，當這個數據發生改變（父層丟新的東西下來）時就會觸發，要注意的是如果在這個 method 的邏輯沒有處理好，可能會發生無限迴圈的問題，所以需要特別注意。 | 他會在 Component 剛被創造出來就被調用一次，會`比 OnInit() 還早`，還有每當一個或多個數據綁定 @Input 屬性發生改變時會觸發。 \n| ngOnInit() | 會在 Component 完成數據綁定（ngOnChanges）後初始化 Component。 | 在第一個 ngOnChange() 之後觸發，只會被調用一次。\n| ngDoCheck() | `當 Angular 無法獲不會自動檢測到變化並採取行動`，在每次更改檢測運行期間被調用，會跟在 ngOnChanges() 和 ngOnInit() 後面，有點抽象我會在下面有詳細解釋。 | 在每次更改檢測運行時立即在 ngOnChanges() 之後調用，在第一次運行時立即在 ngOnInit() 之後調用。\n| ngAfterContentInit() | Angular 將 ng-content 的內容投影到 Component 的 view 後被調用 | 在第一個 ngDoCheck() 後被調用\n| ngAfterContentChecked() | 每次完成 ng-content 的變更檢測之後調用 | 在 ngAfterContentInit() 之後和每一個 ngDoCheck() 之後被調用\n| ngAfterViewInit() | 當 Angular 初始化自身 Component和子 Component 的 view 後被調用。 | 在第一個 ngAfterContentChecked() 之後調用一次\n| ngAfterViewChecked() | 每次做完自身 Component和子 Component 的變更檢測後呼叫 | 在 ngAfterViewInit() 和每個 ngAfterContentChecked() 之後調用\n| ngOnDestroy() |  在 Angular 銷毀 directive 或 Component 之前調用，主要用於 unsubscribe Observable 以防內存泄露 | 在 Angular 銷毀 directive 或 Component 之前立即調用\n\n## 詳解 ngDoCheck()\n當我第一次在 Angular 官方文件中看到這個我看了十幾次我都看不懂，查了一些文章後才大概了解他是在什麼時候被呼叫到，我們就來詳細介紹一下吧。\n\n在 Angular 官方文檔中這樣寫到：\n> Detect and act upon changes that Angular can’t or won’t detect on its own.\nCalled during every change detection run, immediately after ngOnChanges() and ngOnInit()\n\n相當抽象對吧，，雖然知道他會是在 ngOnChanges( ) 和 ngOnInit( ) 之後觸發的，但是當他被觸發的時候 Component 是否有被檢查？而 Angular 無法自動檢查是指什麼？要解答這個問題我們需要先了解什麼是 Component check，在 Component 變更檢測有三個核心的操作：\n\n- update child component input binding ( @Input( ) )\n- update DOM interpolations ( 在 Template 中的 {{ value }} )\n- update query list\n\n除了這些之外 Angular 還會觸發 Lifecycle 作為變更檢測的一部分，所以當檢查父層時會觸發子層的 Lifycycle，假設我們有一個這樣的結構：\n```\nComponentA\n\tComponentB\n\t\tComponentC\n```\n當 Angular 運行檢測時的順序如下：\n```\nChecking A component:\n  - update B input bindings\n  - call NgDoCheck on the B component\n  - update DOM interpolations for component A\n \n Checking B component:\n    - update C input bindings\n    - call NgDoCheck on the C component\n    - update DOM interpolations for component B\n \n   Checking C component:\n      - update DOM interpolations for component C\n```\n上面的順序只是一個簡單的順序列表，可以看到 DoCheck 會在何時被觸發。\n\n可以看到在檢查父層時子層就會調用 ngDoCheck ，假設我們在 ComponentB 使用了 onPush 會發生什麼事：\n```\nChecking A component:\n  - update B input bindings\n  - call NgDoCheck on the B component\n  - update DOM interpolations for component A\n  \n if (bindings changed) -> checking B component:\n    - update C input bindings\n    - call NgDoCheck on the C component\n    - update DOM interpolations for component B\n \n   Checking C component:\n      - update DOM interpolations for component C\n```\n可以看到我們在 ComponenB 檢測前加上了一個小判斷，如果這個判斷為 false 就會滿足官方文檔提到的`當 Angular 無法獲不會自動檢測到變化並採取行動`，所以即使不會檢查 ComponentB 但是仍然會觸發 ComponentB 上面的 ngDoCheck。\n\n我們來透過程式碼直接操作看看，首先我們先定義一個 sub-component\n```typescript\n@Component({\n  selector: 'app-first-component',\n  template: '<h2>The name is: {{o.name}}</h2>',\n  changeDetection: ChangeDetectionStrategy.OnPush // (1)\n})\n\nexport class FirstComponentComponent implements OnChanges {\n\t@Input() o: { id: number; name: string; } = { id: NaN, name: '' }; // (2)\n\n\tid: number = NaN;\n\n  ngOnChanges() {\n    console.log('first-component OnChange() been call');  // (3)\n    this.id = this.o.id;\n  }\n\n  ngDoCheck() {\n    console.log('first-component DoCheck() been call');  // (4)\n    if (this.id !== this.o.id) {\n      this.cd.markForCheck();\n    }\n  }\n}\n```\n- （1）：利用 OnPush 來變更檢測策略。\n- （2）：使用 @Input( ) 綁定一個 input binding\n- （3）：當 @Input( ) 發生改變時，觸發 sub-component 中的 ngOnChanges\n- （4）：當父層發生變化時，觸發 sub-component 的 ngDoCheck\n\n接著我們在父層將 o 這個物件向下傳給 sub-component，在2秒內他通過更新 name 和 id 來改變這個物件\n```typescript\n@Component({\n  selector: 'app-root',\n  template: `\n\t\t<h1>Hello {{name}}</h1>\n    <a-comp [o]=\"o\"></a-comp>  // (1)\n\t`\n})\nexport class AppComponent implements OnInit{\n  o = {id: 1, name: 'Fandix'};\n\n  ngOnInit() {\n    setTimeout(() => {         // (2)\n      this.o.id = 2;\n      this.o.name = 'Jane';\n    }, 2000);\n  }\n}\n```\n- （1）： 將 o 向下傳遞給 sub-component\n- （2）：利用 setTimeout 在經過兩秒後更改 o 的 property\n\n![https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png](https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png)\n\n由於 Angular 追蹤的是 o 這個物件的 reference，所以當我們以不更改 reference 的情況下改變 o 的內容就不會被 Angular 檢測到，這就是為什麼 sub-component 的 ngOnChanges() 只有被呼叫一次（創建 Component 時第一次呼叫），但是經過上面的解說後可以知道，`就算 sub-component 不會被 Angular 給自動檢測，但是由於父層發生了改變就會讓子層的 ngDoCheck 自動被呼叫到`，所以在 AppComponent 發生改變時 sub-component 的 ngDoCheck 依然會被觸發，這就是`當 Angular 無法或不會自動檢測到變化並採取行動`的意思。\n\n\n# Initializing a component or directive\n大概介紹完 Angular 的 Lifecycle，我們來看看 ngOnInit 的使用場景。\n\n- 在 construstor 之外執行邏輯複雜的初始化任務，如果是 fetch data 就不應該在 constructor 做而應該要在 ngOnInit 處理。\n- 可以在 ngOnInit 中設置輸入屬性，constructor 應該只將初始局部變量設置為簡單的值，所以如果你需要根據 @Input() 的值來設定內容的話，需要在 ngOnInit 中處理。\n\n\n# Cleaning up on instance destruction\n在開發 Angular component 時可以將清理的邏輯放在 ngOnDestroy( ) 中，這些邏輯必須在 Angular 銷毀這個 Component 之前執行，這裡是`釋放不會自動釋放資源的地方`，如果一直建立不會自動釋放資源的東西最後卻沒有將他清理掉，可能會造成內存洩漏或滿載的問題，這裡可以用來：\n\n- Unsubscribe Observable 和 DOM event\n- 停止 interval timers\n- Unregister 所有影響到別的地方的 callback function\n\n\n# 結論\n在本章中我們談到了 Angular 的 Lifecycle，了解有哪些 Lifecycle method 可以使用以及他們被調用的時機點，掌握好如何在對的時機點使用對的 Lifecycle method 是非常重要的，如果在錯的時間使用錯的 Lifecycle method 會造成非預期的錯誤，下一章將介紹在 Angular 中父子層 Component 之間是如何共享數據的，雖然在本章節有提到一點點（ @Input( ) ），不過將會在下一張更詳細的說明，那我們下一章再見。\n\n\n# Reference\n- [Angular.io - lifechcke hook](https://angular.io/guide/lifecycle-hooks)\n- [If you think ngDoCheck means your component is being checked — read this article](https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article)\n\n","slug":"Angular/angular-05","published":1,"updated":"2022-02-15T07:27:52.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmnj000akww3d6dx9lih","content":"<p>在 Angular 的 Component 中有一個生命週期，<code>當 Angular 實例化這個 Component 並且把它或他的 sub-component 呈現在 UI 時便會開始</code>，而 Lifecycle 會持續的檢測是否有綁定的數據被更改，因為這些綁定數據的更改可能會需要更新 UI 或 Component 的內容，而當 Angular 銷毀了這個 Component 實例並從 DOM 中移除這個 Component 的 Template 後 Lifecycle 就會結束。</p>\n<p>簡單來說，當 Angular 在某一個地方的 HTML 發現了一個 Component 的 selector（身分證號碼）後，便會找到這個 Component 並將他實例化和將他的 Template 呈現在 UI 上（放進 DOM 中），這個時候這個 Component 就開始了他的一生，他會在他的一生中不斷的檢測是否有東西需要改變，最後當使用者離開了這個頁面，代表著這個 Component 不在被需要了，他就會被銷毀掉結束他的一生。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Responding-to-lifecycle-events\"><a href=\"#Responding-to-lifecycle-events\" class=\"headerlink\" title=\"Responding to lifecycle events\"></a>Responding to lifecycle events</h1><p>了解了什麼是 Lifecycle 後，我們要正式介紹 Lifecycle 了，首先你可以透過 import <code>angular/core</code> 引入一個或多個 lifecycle 使用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">OnInit</span>, <span class=\"title class_\">OnChanges</span>, ... &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>每一個 Lifecycle  method 前面都有 <code>ng</code> 當作前綴字，舉例來說如果要使用 OnInit 這個 Lifecycle method 則要在你的 TypeScript Class 中輸入 ngOnInit( )，而當你要使用某一個 Lifycycle method 時，記得要在你的 Class 使用 <code>implements</code> 繼承這個 Lifycycle。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">OnInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-first-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./first-component.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./first-component.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FirstComponentComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnInit</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngOnInit</span>(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lifecycle-event-sequence\"><a href=\"#Lifecycle-event-sequence\" class=\"headerlink\" title=\"Lifecycle event sequence\"></a>Lifecycle event sequence</h2><p>每一個 Lifecycle method 都有對應的被調用時機，Angular 會自動在最適當的時間調用適當的  Lifecycle method，以下是 Angular 按照順序執行的 Lifecycle method。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th align=\"center\">Purpose</th>\n<th align=\"center\">Timing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ngOnChanges()</td>\n<td align=\"center\">當這制或重置綁定的數據時會被調用，比如你在這個 Component 中綁定了一個由父層傳下來的數據，當這個數據發生改變（父層丟新的東西下來）時就會觸發，要注意的是如果在這個 method 的邏輯沒有處理好，可能會發生無限迴圈的問題，所以需要特別注意。</td>\n<td align=\"center\">他會在 Component 剛被創造出來就被調用一次，會<code>比 OnInit() 還早</code>，還有每當一個或多個數據綁定 @Input 屬性發生改變時會觸發。</td>\n</tr>\n<tr>\n<td>ngOnInit()</td>\n<td align=\"center\">會在 Component 完成數據綁定（ngOnChanges）後初始化 Component。</td>\n<td align=\"center\">在第一個 ngOnChange() 之後觸發，只會被調用一次。</td>\n</tr>\n<tr>\n<td>ngDoCheck()</td>\n<td align=\"center\"><code>當 Angular 無法獲不會自動檢測到變化並採取行動</code>，在每次更改檢測運行期間被調用，會跟在 ngOnChanges() 和 ngOnInit() 後面，有點抽象我會在下面有詳細解釋。</td>\n<td align=\"center\">在每次更改檢測運行時立即在 ngOnChanges() 之後調用，在第一次運行時立即在 ngOnInit() 之後調用。</td>\n</tr>\n<tr>\n<td>ngAfterContentInit()</td>\n<td align=\"center\">Angular 將 ng-content 的內容投影到 Component 的 view 後被調用</td>\n<td align=\"center\">在第一個 ngDoCheck() 後被調用</td>\n</tr>\n<tr>\n<td>ngAfterContentChecked()</td>\n<td align=\"center\">每次完成 ng-content 的變更檢測之後調用</td>\n<td align=\"center\">在 ngAfterContentInit() 之後和每一個 ngDoCheck() 之後被調用</td>\n</tr>\n<tr>\n<td>ngAfterViewInit()</td>\n<td align=\"center\">當 Angular 初始化自身 Component和子 Component 的 view 後被調用。</td>\n<td align=\"center\">在第一個 ngAfterContentChecked() 之後調用一次</td>\n</tr>\n<tr>\n<td>ngAfterViewChecked()</td>\n<td align=\"center\">每次做完自身 Component和子 Component 的變更檢測後呼叫</td>\n<td align=\"center\">在 ngAfterViewInit() 和每個 ngAfterContentChecked() 之後調用</td>\n</tr>\n<tr>\n<td>ngOnDestroy()</td>\n<td align=\"center\">在 Angular 銷毀 directive 或 Component 之前調用，主要用於 unsubscribe Observable 以防內存泄露</td>\n<td align=\"center\">在 Angular 銷毀 directive 或 Component 之前立即調用</td>\n</tr>\n</tbody></table>\n<h2 id=\"詳解-ngDoCheck\"><a href=\"#詳解-ngDoCheck\" class=\"headerlink\" title=\"詳解 ngDoCheck()\"></a>詳解 ngDoCheck()</h2><p>當我第一次在 Angular 官方文件中看到這個我看了十幾次我都看不懂，查了一些文章後才大概了解他是在什麼時候被呼叫到，我們就來詳細介紹一下吧。</p>\n<p>在 Angular 官方文檔中這樣寫到：</p>\n<blockquote>\n<p>Detect and act upon changes that Angular can’t or won’t detect on its own.<br>Called during every change detection run, immediately after ngOnChanges() and ngOnInit()</p>\n</blockquote>\n<p>相當抽象對吧，，雖然知道他會是在 ngOnChanges( ) 和 ngOnInit( ) 之後觸發的，但是當他被觸發的時候 Component 是否有被檢查？而 Angular 無法自動檢查是指什麼？要解答這個問題我們需要先了解什麼是 Component check，在 Component 變更檢測有三個核心的操作：</p>\n<ul>\n<li>update child component input binding ( @Input( ) )</li>\n<li>update DOM interpolations ( 在 Template 中的  )</li>\n<li>update query list</li>\n</ul>\n<p>除了這些之外 Angular 還會觸發 Lifecycle 作為變更檢測的一部分，所以當檢查父層時會觸發子層的 Lifycycle，假設我們有一個這樣的結構：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ComponentA</span><br><span class=\"line\">\tComponentB</span><br><span class=\"line\">\t\tComponentC</span><br></pre></td></tr></table></figure>\n<p>當 Angular 運行檢測時的順序如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Checking A component:</span><br><span class=\"line\">  - update B input bindings</span><br><span class=\"line\">  - call NgDoCheck on the B component</span><br><span class=\"line\">  - update DOM interpolations for component A</span><br><span class=\"line\"> </span><br><span class=\"line\"> Checking B component:</span><br><span class=\"line\">    - update C input bindings</span><br><span class=\"line\">    - call NgDoCheck on the C component</span><br><span class=\"line\">    - update DOM interpolations for component B</span><br><span class=\"line\"> </span><br><span class=\"line\">   Checking C component:</span><br><span class=\"line\">      - update DOM interpolations for component C</span><br></pre></td></tr></table></figure>\n<p>上面的順序只是一個簡單的順序列表，可以看到 DoCheck 會在何時被觸發。</p>\n<p>可以看到在檢查父層時子層就會調用 ngDoCheck ，假設我們在 ComponentB 使用了 onPush 會發生什麼事：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Checking A component:</span><br><span class=\"line\">  - update B input bindings</span><br><span class=\"line\">  - call NgDoCheck on the B component</span><br><span class=\"line\">  - update DOM interpolations for component A</span><br><span class=\"line\">  </span><br><span class=\"line\"> if (bindings changed) -&gt; checking B component:</span><br><span class=\"line\">    - update C input bindings</span><br><span class=\"line\">    - call NgDoCheck on the C component</span><br><span class=\"line\">    - update DOM interpolations for component B</span><br><span class=\"line\"> </span><br><span class=\"line\">   Checking C component:</span><br><span class=\"line\">      - update DOM interpolations for component C</span><br></pre></td></tr></table></figure>\n<p>可以看到我們在 ComponenB 檢測前加上了一個小判斷，如果這個判斷為 false 就會滿足官方文檔提到的<code>當 Angular 無法獲不會自動檢測到變化並採取行動</code>，所以即使不會檢查 ComponentB 但是仍然會觸發 ComponentB 上面的 ngDoCheck。</p>\n<p>我們來透過程式碼直接操作看看，首先我們先定義一個 sub-component</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-first-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;h2&gt;The name is: &#123;&#123;o.name&#125;&#125;&lt;/h2&gt;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">changeDetection</span>: <span class=\"title class_\">ChangeDetectionStrategy</span>.<span class=\"property\">OnPush</span> <span class=\"comment\">// (1)</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FirstComponentComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnChanges</span> &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Input</span>() <span class=\"attr\">o</span>: &#123; <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; &#125; = &#123; <span class=\"attr\">id</span>: <span class=\"title class_\">NaN</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;&#x27;</span> &#125;; <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">id</span>: <span class=\"built_in\">number</span> = <span class=\"title class_\">NaN</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngOnChanges</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;first-component OnChange() been call&#x27;</span>);  <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">id</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngDoCheck</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;first-component DoCheck() been call&#x27;</span>);  <span class=\"comment\">// (4)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">id</span> !== <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">id</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">cd</span>.<span class=\"title function_\">markForCheck</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>（1）：利用 OnPush 來變更檢測策略。</li>\n<li>（2）：使用 @Input( ) 綁定一個 input binding</li>\n<li>（3）：當 @Input( ) 發生改變時，觸發 sub-component 中的 ngOnChanges</li>\n<li>（4）：當父層發生變化時，觸發 sub-component 的 ngDoCheck</li>\n</ul>\n<p>接著我們在父層將 o 這個物件向下傳給 sub-component，在2秒內他通過更新 name 和 id 來改變這個物件</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">\t\t&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;a-comp [o]=&quot;o&quot;&gt;&lt;/a-comp&gt;  // (1)</span></span><br><span class=\"line\"><span class=\"string\">\t`</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnInit</span>&#123;</span><br><span class=\"line\">  o = &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngOnInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;         <span class=\"comment\">// (2)</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">id</span> = <span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Jane&#x27;</span>;</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>（1）： 將 o 向下傳遞給 sub-component</li>\n<li>（2）：利用 setTimeout 在經過兩秒後更改 o 的 property</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png\"></p>\n<p>由於 Angular 追蹤的是 o 這個物件的 reference，所以當我們以不更改 reference 的情況下改變 o 的內容就不會被 Angular 檢測到，這就是為什麼 sub-component 的 ngOnChanges() 只有被呼叫一次（創建 Component 時第一次呼叫），但是經過上面的解說後可以知道，<code>就算 sub-component 不會被 Angular 給自動檢測，但是由於父層發生了改變就會讓子層的 ngDoCheck 自動被呼叫到</code>，所以在 AppComponent 發生改變時 sub-component 的 ngDoCheck 依然會被觸發，這就是<code>當 Angular 無法或不會自動檢測到變化並採取行動</code>的意思。</p>\n<h1 id=\"Initializing-a-component-or-directive\"><a href=\"#Initializing-a-component-or-directive\" class=\"headerlink\" title=\"Initializing a component or directive\"></a>Initializing a component or directive</h1><p>大概介紹完 Angular 的 Lifecycle，我們來看看 ngOnInit 的使用場景。</p>\n<ul>\n<li>在 construstor 之外執行邏輯複雜的初始化任務，如果是 fetch data 就不應該在 constructor 做而應該要在 ngOnInit 處理。</li>\n<li>可以在 ngOnInit 中設置輸入屬性，constructor 應該只將初始局部變量設置為簡單的值，所以如果你需要根據 @Input() 的值來設定內容的話，需要在 ngOnInit 中處理。</li>\n</ul>\n<h1 id=\"Cleaning-up-on-instance-destruction\"><a href=\"#Cleaning-up-on-instance-destruction\" class=\"headerlink\" title=\"Cleaning up on instance destruction\"></a>Cleaning up on instance destruction</h1><p>在開發 Angular component 時可以將清理的邏輯放在 ngOnDestroy( ) 中，這些邏輯必須在 Angular 銷毀這個 Component 之前執行，這裡是<code>釋放不會自動釋放資源的地方</code>，如果一直建立不會自動釋放資源的東西最後卻沒有將他清理掉，可能會造成內存洩漏或滿載的問題，這裡可以用來：</p>\n<ul>\n<li>Unsubscribe Observable 和 DOM event</li>\n<li>停止 interval timers</li>\n<li>Unregister 所有影響到別的地方的 callback function</li>\n</ul>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本章中我們談到了 Angular 的 Lifecycle，了解有哪些 Lifecycle method 可以使用以及他們被調用的時機點，掌握好如何在對的時機點使用對的 Lifecycle method 是非常重要的，如果在錯的時間使用錯的 Lifecycle method 會造成非預期的錯誤，下一章將介紹在 Angular 中父子層 Component 之間是如何共享數據的，雖然在本章節有提到一點點（ @Input( ) ），不過將會在下一張更詳細的說明，那我們下一章再見。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/lifecycle-hooks\">Angular.io - lifechcke hook</a></li>\n<li><a href=\"https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article\">If you think ngDoCheck means your component is being checked — read this article</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在 Angular 的 Component 中有一個生命週期，<code>當 Angular 實例化這個 Component 並且把它或他的 sub-component 呈現在 UI 時便會開始</code>，而 Lifecycle 會持續的檢測是否有綁定的數據被更改，因為這些綁定數據的更改可能會需要更新 UI 或 Component 的內容，而當 Angular 銷毀了這個 Component 實例並從 DOM 中移除這個 Component 的 Template 後 Lifecycle 就會結束。</p>\n<p>簡單來說，當 Angular 在某一個地方的 HTML 發現了一個 Component 的 selector（身分證號碼）後，便會找到這個 Component 並將他實例化和將他的 Template 呈現在 UI 上（放進 DOM 中），這個時候這個 Component 就開始了他的一生，他會在他的一生中不斷的檢測是否有東西需要改變，最後當使用者離開了這個頁面，代表著這個 Component 不在被需要了，他就會被銷毀掉結束他的一生。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767kIMDJfjDfg.png\"></p>","more":"<h1 id=\"Responding-to-lifecycle-events\"><a href=\"#Responding-to-lifecycle-events\" class=\"headerlink\" title=\"Responding to lifecycle events\"></a>Responding to lifecycle events</h1><p>了解了什麼是 Lifecycle 後，我們要正式介紹 Lifecycle 了，首先你可以透過 import <code>angular/core</code> 引入一個或多個 lifecycle 使用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">OnInit</span>, <span class=\"title class_\">OnChanges</span>, ... &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>每一個 Lifecycle  method 前面都有 <code>ng</code> 當作前綴字，舉例來說如果要使用 OnInit 這個 Lifecycle method 則要在你的 TypeScript Class 中輸入 ngOnInit( )，而當你要使用某一個 Lifycycle method 時，記得要在你的 Class 使用 <code>implements</code> 繼承這個 Lifycycle。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">OnInit</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-first-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./first-component.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./first-component.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FirstComponentComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnInit</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngOnInit</span>(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lifecycle-event-sequence\"><a href=\"#Lifecycle-event-sequence\" class=\"headerlink\" title=\"Lifecycle event sequence\"></a>Lifecycle event sequence</h2><p>每一個 Lifecycle method 都有對應的被調用時機，Angular 會自動在最適當的時間調用適當的  Lifecycle method，以下是 Angular 按照順序執行的 Lifecycle method。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th align=\"center\">Purpose</th>\n<th align=\"center\">Timing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ngOnChanges()</td>\n<td align=\"center\">當這制或重置綁定的數據時會被調用，比如你在這個 Component 中綁定了一個由父層傳下來的數據，當這個數據發生改變（父層丟新的東西下來）時就會觸發，要注意的是如果在這個 method 的邏輯沒有處理好，可能會發生無限迴圈的問題，所以需要特別注意。</td>\n<td align=\"center\">他會在 Component 剛被創造出來就被調用一次，會<code>比 OnInit() 還早</code>，還有每當一個或多個數據綁定 @Input 屬性發生改變時會觸發。</td>\n</tr>\n<tr>\n<td>ngOnInit()</td>\n<td align=\"center\">會在 Component 完成數據綁定（ngOnChanges）後初始化 Component。</td>\n<td align=\"center\">在第一個 ngOnChange() 之後觸發，只會被調用一次。</td>\n</tr>\n<tr>\n<td>ngDoCheck()</td>\n<td align=\"center\"><code>當 Angular 無法獲不會自動檢測到變化並採取行動</code>，在每次更改檢測運行期間被調用，會跟在 ngOnChanges() 和 ngOnInit() 後面，有點抽象我會在下面有詳細解釋。</td>\n<td align=\"center\">在每次更改檢測運行時立即在 ngOnChanges() 之後調用，在第一次運行時立即在 ngOnInit() 之後調用。</td>\n</tr>\n<tr>\n<td>ngAfterContentInit()</td>\n<td align=\"center\">Angular 將 ng-content 的內容投影到 Component 的 view 後被調用</td>\n<td align=\"center\">在第一個 ngDoCheck() 後被調用</td>\n</tr>\n<tr>\n<td>ngAfterContentChecked()</td>\n<td align=\"center\">每次完成 ng-content 的變更檢測之後調用</td>\n<td align=\"center\">在 ngAfterContentInit() 之後和每一個 ngDoCheck() 之後被調用</td>\n</tr>\n<tr>\n<td>ngAfterViewInit()</td>\n<td align=\"center\">當 Angular 初始化自身 Component和子 Component 的 view 後被調用。</td>\n<td align=\"center\">在第一個 ngAfterContentChecked() 之後調用一次</td>\n</tr>\n<tr>\n<td>ngAfterViewChecked()</td>\n<td align=\"center\">每次做完自身 Component和子 Component 的變更檢測後呼叫</td>\n<td align=\"center\">在 ngAfterViewInit() 和每個 ngAfterContentChecked() 之後調用</td>\n</tr>\n<tr>\n<td>ngOnDestroy()</td>\n<td align=\"center\">在 Angular 銷毀 directive 或 Component 之前調用，主要用於 unsubscribe Observable 以防內存泄露</td>\n<td align=\"center\">在 Angular 銷毀 directive 或 Component 之前立即調用</td>\n</tr>\n</tbody></table>\n<h2 id=\"詳解-ngDoCheck\"><a href=\"#詳解-ngDoCheck\" class=\"headerlink\" title=\"詳解 ngDoCheck()\"></a>詳解 ngDoCheck()</h2><p>當我第一次在 Angular 官方文件中看到這個我看了十幾次我都看不懂，查了一些文章後才大概了解他是在什麼時候被呼叫到，我們就來詳細介紹一下吧。</p>\n<p>在 Angular 官方文檔中這樣寫到：</p>\n<blockquote>\n<p>Detect and act upon changes that Angular can’t or won’t detect on its own.<br>Called during every change detection run, immediately after ngOnChanges() and ngOnInit()</p>\n</blockquote>\n<p>相當抽象對吧，，雖然知道他會是在 ngOnChanges( ) 和 ngOnInit( ) 之後觸發的，但是當他被觸發的時候 Component 是否有被檢查？而 Angular 無法自動檢查是指什麼？要解答這個問題我們需要先了解什麼是 Component check，在 Component 變更檢測有三個核心的操作：</p>\n<ul>\n<li>update child component input binding ( @Input( ) )</li>\n<li>update DOM interpolations ( 在 Template 中的  )</li>\n<li>update query list</li>\n</ul>\n<p>除了這些之外 Angular 還會觸發 Lifecycle 作為變更檢測的一部分，所以當檢查父層時會觸發子層的 Lifycycle，假設我們有一個這樣的結構：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ComponentA</span><br><span class=\"line\">\tComponentB</span><br><span class=\"line\">\t\tComponentC</span><br></pre></td></tr></table></figure>\n<p>當 Angular 運行檢測時的順序如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Checking A component:</span><br><span class=\"line\">  - update B input bindings</span><br><span class=\"line\">  - call NgDoCheck on the B component</span><br><span class=\"line\">  - update DOM interpolations for component A</span><br><span class=\"line\"> </span><br><span class=\"line\"> Checking B component:</span><br><span class=\"line\">    - update C input bindings</span><br><span class=\"line\">    - call NgDoCheck on the C component</span><br><span class=\"line\">    - update DOM interpolations for component B</span><br><span class=\"line\"> </span><br><span class=\"line\">   Checking C component:</span><br><span class=\"line\">      - update DOM interpolations for component C</span><br></pre></td></tr></table></figure>\n<p>上面的順序只是一個簡單的順序列表，可以看到 DoCheck 會在何時被觸發。</p>\n<p>可以看到在檢查父層時子層就會調用 ngDoCheck ，假設我們在 ComponentB 使用了 onPush 會發生什麼事：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Checking A component:</span><br><span class=\"line\">  - update B input bindings</span><br><span class=\"line\">  - call NgDoCheck on the B component</span><br><span class=\"line\">  - update DOM interpolations for component A</span><br><span class=\"line\">  </span><br><span class=\"line\"> if (bindings changed) -&gt; checking B component:</span><br><span class=\"line\">    - update C input bindings</span><br><span class=\"line\">    - call NgDoCheck on the C component</span><br><span class=\"line\">    - update DOM interpolations for component B</span><br><span class=\"line\"> </span><br><span class=\"line\">   Checking C component:</span><br><span class=\"line\">      - update DOM interpolations for component C</span><br></pre></td></tr></table></figure>\n<p>可以看到我們在 ComponenB 檢測前加上了一個小判斷，如果這個判斷為 false 就會滿足官方文檔提到的<code>當 Angular 無法獲不會自動檢測到變化並採取行動</code>，所以即使不會檢查 ComponentB 但是仍然會觸發 ComponentB 上面的 ngDoCheck。</p>\n<p>我們來透過程式碼直接操作看看，首先我們先定義一個 sub-component</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-first-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">&#x27;&lt;h2&gt;The name is: &#123;&#123;o.name&#125;&#125;&lt;/h2&gt;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">changeDetection</span>: <span class=\"title class_\">ChangeDetectionStrategy</span>.<span class=\"property\">OnPush</span> <span class=\"comment\">// (1)</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FirstComponentComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnChanges</span> &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Input</span>() <span class=\"attr\">o</span>: &#123; <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; &#125; = &#123; <span class=\"attr\">id</span>: <span class=\"title class_\">NaN</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;&#x27;</span> &#125;; <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">id</span>: <span class=\"built_in\">number</span> = <span class=\"title class_\">NaN</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngOnChanges</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;first-component OnChange() been call&#x27;</span>);  <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">id</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngDoCheck</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;first-component DoCheck() been call&#x27;</span>);  <span class=\"comment\">// (4)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">id</span> !== <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">id</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">cd</span>.<span class=\"title function_\">markForCheck</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>（1）：利用 OnPush 來變更檢測策略。</li>\n<li>（2）：使用 @Input( ) 綁定一個 input binding</li>\n<li>（3）：當 @Input( ) 發生改變時，觸發 sub-component 中的 ngOnChanges</li>\n<li>（4）：當父層發生變化時，觸發 sub-component 的 ngDoCheck</li>\n</ul>\n<p>接著我們在父層將 o 這個物件向下傳給 sub-component，在2秒內他通過更新 name 和 id 來改變這個物件</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">\t\t&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;a-comp [o]=&quot;o&quot;&gt;&lt;/a-comp&gt;  // (1)</span></span><br><span class=\"line\"><span class=\"string\">\t`</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">OnInit</span>&#123;</span><br><span class=\"line\">  o = &#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngOnInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;         <span class=\"comment\">// (2)</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">id</span> = <span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">o</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Jane&#x27;</span>;</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>（1）： 將 o 向下傳遞給 sub-component</li>\n<li>（2）：利用 setTimeout 在經過兩秒後更改 o 的 property</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210730/20124767T4wP0YOgSv.png\"></p>\n<p>由於 Angular 追蹤的是 o 這個物件的 reference，所以當我們以不更改 reference 的情況下改變 o 的內容就不會被 Angular 檢測到，這就是為什麼 sub-component 的 ngOnChanges() 只有被呼叫一次（創建 Component 時第一次呼叫），但是經過上面的解說後可以知道，<code>就算 sub-component 不會被 Angular 給自動檢測，但是由於父層發生了改變就會讓子層的 ngDoCheck 自動被呼叫到</code>，所以在 AppComponent 發生改變時 sub-component 的 ngDoCheck 依然會被觸發，這就是<code>當 Angular 無法或不會自動檢測到變化並採取行動</code>的意思。</p>\n<h1 id=\"Initializing-a-component-or-directive\"><a href=\"#Initializing-a-component-or-directive\" class=\"headerlink\" title=\"Initializing a component or directive\"></a>Initializing a component or directive</h1><p>大概介紹完 Angular 的 Lifecycle，我們來看看 ngOnInit 的使用場景。</p>\n<ul>\n<li>在 construstor 之外執行邏輯複雜的初始化任務，如果是 fetch data 就不應該在 constructor 做而應該要在 ngOnInit 處理。</li>\n<li>可以在 ngOnInit 中設置輸入屬性，constructor 應該只將初始局部變量設置為簡單的值，所以如果你需要根據 @Input() 的值來設定內容的話，需要在 ngOnInit 中處理。</li>\n</ul>\n<h1 id=\"Cleaning-up-on-instance-destruction\"><a href=\"#Cleaning-up-on-instance-destruction\" class=\"headerlink\" title=\"Cleaning up on instance destruction\"></a>Cleaning up on instance destruction</h1><p>在開發 Angular component 時可以將清理的邏輯放在 ngOnDestroy( ) 中，這些邏輯必須在 Angular 銷毀這個 Component 之前執行，這裡是<code>釋放不會自動釋放資源的地方</code>，如果一直建立不會自動釋放資源的東西最後卻沒有將他清理掉，可能會造成內存洩漏或滿載的問題，這裡可以用來：</p>\n<ul>\n<li>Unsubscribe Observable 和 DOM event</li>\n<li>停止 interval timers</li>\n<li>Unregister 所有影響到別的地方的 callback function</li>\n</ul>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本章中我們談到了 Angular 的 Lifecycle，了解有哪些 Lifecycle method 可以使用以及他們被調用的時機點，掌握好如何在對的時機點使用對的 Lifecycle method 是非常重要的，如果在錯的時間使用錯的 Lifecycle method 會造成非預期的錯誤，下一章將介紹在 Angular 中父子層 Component 之間是如何共享數據的，雖然在本章節有提到一點點（ @Input( ) ），不過將會在下一張更詳細的說明，那我們下一章再見。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/lifecycle-hooks\">Angular.io - lifechcke hook</a></li>\n<li><a href=\"https://indepth.dev/posts/1131/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article\">If you think ngDoCheck means your component is being checked — read this article</a></li>\n</ul>"},{"title":"Day6. Sharing data between child and parent directives and components","date":"2022-02-15T07:34:28.000Z","_content":"\n我們了解到 Angular app 是由無數個大大小小的 Component 所組成的，所以就會常常需要使用將 Component 嵌套，一個大個 Component 中包含了 10 個小的 Component 之類的，那麼讓資料在父子層 Component 之間傳遞就非常重要，要實現這個功能就需要使用到 Angular 中的 @Input() 和 @Output()。\n\n@Input() 是讓父層更新子層 Component 中的數據，相反的 @Output() 是為讓子層向父層 Component 發送數據的。\n\n下面我們會做一個簡單的例子來實際使用與講解如使用 @Input() 與 @Output()。\n![https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png](https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png)\n\n<!--more-->\n\n# Sending data to a child component\n大概知道了 Angular 是如何讓父子層 Component  之間傳遞數據的，接下來我們使用一個小小的例子來講解與操作這個功能吧。\n\n## Create child and parent components\n首先我們先透過 Angular CLI 建立兩個父子層關係的 Component。\n```bash\nng generate component parent\nng generate component child\n```\n創建完後，我們將在 parent.component.html 中加入 child.component .ts 中的 selector，建立兩個 Component 的父子層關係。\n```html\n<!-- parent.component.html -->\n<p>parent component works!</p>\n<hr>\n<app-child-component></app-child-component>\n```\n我們打開網頁的開發模式，來確認一下 DOM 是不是確實有將兩個 Component 建立為父子層關係。\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png)\n\n## Configuring the child component\n首先第一步我們要在 child.component.ts 中使用 `@Input()` 裝飾器，先把他透過 import 從 `@angular/core` 中引用進來然後使用它。\n```typescript\nimport { Component, Input } from '@angular/core';  // (1)\n\n@Component({\n  selector: 'app-child-component',\n  templateUrl: './child.component.html'\n})\nexport class ChildComponent {\n  @Input() item = ''; // (2)\n  constructor() { }\n}\n```\n- (1): 使用 import 將 @Input 引入\n- (2): 使用 @Input( ) 裝飾 property \"item\"\n\n可以看到我們使用了 @Input() 裝飾了 ChildComponent 中的 item 這個 property， 雖然在上面的例子中是將他初始化為 string，但是`不代表使用 @Input() 裝飾的 property 只能是字串型態`，他可以是任一種資料型態，代表著這個 property 來自父層。\n\n接下來我們將這個 property 放在 child.component.html 中讓我們可以觀察他的變化。\n```\n<!-- child.component.html  -->\n<p>child component works!</p>\n\n<div>Today's item: {{ item }}</div>\n```\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png)\n在畫面中我們會看到我們打上的 Today's item 後面並沒有東西（因為父層還沒傳資料下來啊～!\n\n## Configuring the parent component\n接下來我們來在父層的 HTML 中綁定屬性：\n1. 先 parent.component.ts 中定義一個 property 並將他賦值\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent-component',\n  templateUrl: './parent.component.html'\n})\nexport class ParentComponent {\n  constructor() { }\n  currentItem = 'Television';  // defind a property\n}\n```\n2. 在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層\n```html\n<app-child-component [item]=\"currentItem\"></app-child-component>\n```\n![https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png](https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png)\n\n在畫面中可以看到原本 Today's item 後面什麼都沒有的卻顯示了來自 parent.component.ts 中的 property 內容，這就是透過 @Input( ) 將父層的資料傳遞給子層。\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767EYEXWLzvqp.png](https://lh3.googleusercontent.com/NRaoUQUGHeo774fUM3u9g-s8BMPkiS-pfcrfArgAugzTrNx2OHlVISHGBjmfzGrophrKYmXKFDJeDCV4Apif3v0qpT3Vq5U0bp5_ALAJ7y4xVX9lFjxUlg2TNXiOINLAv-JOCfFZaERBBti_ku0Hr76v9964ZFXAssFbUjCexnaOlVZ64N41va0sAGxUSZ0RTHfarVsNn5fMU3ZKcFiURwxjpdypvb0G89UjExhAb8DflKFsV_RL2AH9FORmTfFi4kCOY0gv4VgMrOF2-OccsVn-1Proaq9GswprjAZN4WcsE9KtQKjNBHY2L4r6SVij5d1DBnloCpDJMprkCbPqNxubfAVHZZ7DSw4x1D1VQLl-SPzxsmmz-W5SrGLJ8tsFEK5DGu9JB6_gdsrFYbTyoWsAo7ylV8wW6_UZrOR2RN4PFbnYOfuzf3XL0MzTeO8sy6hq9_Nr_pmMiIuTJlLduff_WSdpON3wNBYD74gRk21cEDVA-Ih8MIhOmOUt-VEBqqB_-GbDOWIJb3YVD5R6GuNCTuEHy1d6HwCrcOd5z2KdHOVuomgHGsg2aQX81W9ZVQkvT_zOg1RgU5qDNd8MxMwieQasVVvmuh9EJ3b4S5iqN2R2WyrS9pLj0V2cOc6J4YZpBaZm7VXtsVyLX2yUZEv6y02bhrrZiTm8FglASN2s6xjx-ZmAJOo4U7qALg7gmfkwSkpa0DQcimTmlTgWV8ovSy90-dS2pmEBa9Cp0xblaRWT=w700-h180-no)\n上面的圖已看到，[ ] 中的目標是你在子層使用 @Input() 裝飾的 property，而 source (等好右邊的部分) 是父層要提供給子層數據的名稱，也就是在父層中為了要傳遞給子層數值所定義的 property。\n\n我們在 Lifecycle 中有提到，ngOnChange() 被調用的條件，除了 Component 剛被創建出來的第一次調用之外，其他的每一次都是在當有 input binding 發生改變時會被調用，這代表著如果父層要向下傳遞的 property 發生改變時，就會觸發子層的 ngOnChange()。\n\n\n\n# Sending data to a parent component\n講解完如何透過 @Input() 將父層的數據傳給子層後，接下來介紹如何透過 @Output() 讓子層的數據傳遞給父層。\n\n首先 @Output() 裝飾器它可以讓子層的 property 標記成為數據可以傳遞給父層的入口，子層透過使用被 @Output() 裝飾的 property 觸發 event 來通知父層數據已經被更改了，要觸發事件這個子層的 property 必須是 \"EventEmitter\" 型別，他可以從 '@angular/core' 中引入，下面我們一樣會用一個小例子舉例並講解。\n\n## Configuring the child component\n我們在 child 中設置一個可以點擊一個 `<button>` 來觸發 EventEmitter，並將數據傳遞給父層。\n```typescript\nimport { Component, Output, EventEmitter } from '@angular/core';  // (1)\n\n@Component({\n  selector: 'app-child-component',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css']\n})\nexport class ChildComponent {\n  @Output() newItemEvent = new EventEmitter<boolean>();  // (2)\n  constructor() { }\n\n  parentValueChange(value: boolean) {  // (3)\n    this.newItemEvent.emit(value);\n  }\n}\n```\n- (1): 使用 import 將 @Output 與 @EventEmitter 引入\n- (2): 使用 @Output( ) 裝飾一個 property，上面的例子中是 newItemEvent 是一個 EventEmitter 的類型，代表他是一個 event 並會傳遞一個型別為字串的數值\n- (3): 新增一個 method 當使用者點擊畫面的 button 後會觸發此 method 讓子層的數值傳遞給父層\n\n## Configuring the child's template\n接著我們來更改 child.component.html 的內容，我們新增兩個 `<button>` 讓使用者可以對這兩個物件進行操作\n```html\n<!-- child.component.html  -->\n<p>child component works!</p>\n\n<div class=\"button\">\n    <button (click)=\"parentValueChange(true)\">+</button>\n    <button (click)=\"parentValueChange(false)\">-</button>\n</div>\n```\n我們將畫面中的兩個 button 都綁定一個 click event，當點擊 + 這個按鍵就會觸發並將 true 做為參數傳給 parentValueChange，反之傳 false。\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png)\n\n## Configuring the parent component\n接著我們在父層中添加一個 property 讓我們可以透過子層操控這個屬性。\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent-component',\n  templateUrl: './parent.component.html'\n})\nexport class ParentComponent {\n  constructor() { }\n  counterValue = 0;\n\n  addOrSub(event: boolean) {       // (1)\n    if (event) {\n      this.counterValue++;\n    } else {\n      this.counterValue--;\n    }\n  }\n}\n```\n- (1): 在 parent.component.ts 中新增一個 method，當接收到子層傳遞上來的數值時，判斷要將 counterValue 增加或減少。\n\n## Configuring the parent's template\n接著在 parent.component.html 中將 method 綁定到 child's event 上，讓子層的事件可以觸發到父層的 method。\n```html\n<!-- parent.component.html -->\n<p>parent component works!</p>\n<div>parent component property counter: {{counterValue}}</div>\n\n<hr>\n<app-child-component (newItemEvent)=\"addOrSub($event)\"></app-child-component>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png](https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png)\n\n如同 @Input() 一樣，在 () 內的是在子層利用 @Output() 裝飾的 property，因為他是一個 event，所以當子層觸發 event 後會將子層更改的值透過 event 傳遞給父層的 method，而 source( 等號右邊 ) 是父層定義用來接子層傳上來數值的 method。\n\n當你要對同一個子層同時使用 @Input() 和 @Output() 時，可以使用 Tow-way Binding [()]，就可以不用像上面一樣寫得這麼長了，這個方法會在之後詳細講解。\n\n\n\n# Parent calls an @ViewChild()\n介紹完 @Input() 與 @Output() 後，接著要來介紹 @ViewChild() 這個東西，他的存在是因為在 Angular 中父層 Component 無法訪問到子層的 Component，因為`每個 Component 都是一個個獨立的 Class instance，所以在沒有互相連接的情況下是不能訪問到子層的 property 和 method`，所以當開發時遇到這類型的狀況時，需要將子層 Component 作為 ViewChild inject 給父層，在下面舉一個簡單的例子。\n\n## Configuring the child component\n首先先在 child.component.ts 新增一個 property 與 method，讓使用者點擊畫面的 button 時可以加減這個值。\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-child-component',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css']\n})\nexport class ChildComponent {\n  childCounter = 0;       // (1)\n  constructor() { }\n\n  parentValueChange(value: boolean) {     // (2)\n    if (value) {\n      this.childCounter++;\n    } else {\n      this.childCounter--;\n    }\n  }\n\n  childCounterValue() {                   // (3)\n    return this.childCounter;\n  }\n}\n```\n- (1): 新增一個 property 讓他可以被增加或減少\n- (2): 新增一個 method，當使用者點擊畫面按鈕時觸發\n- (3): 新增一個 method，他將回傳子層的 property\n\n## Configuring the child's template\n接著我們在 child.component.html 中新增兩個 `<button>` 並將我們的 childCounter 顯示出來。\n```html\n<!-- child.component.html  -->\n<p>child component works!</p>\n\n<p>Child component counter value: {{childCounter}}</p>\n<div class=\"button\">\n    <button (click)=\"parentValueChange(true)\">+</button>\n    <button (click)=\"parentValueChange(false)\">-</button>\n</div>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png)\n\n## Configuring the parent component\n接著我們在父層在 '@angular/core' 中引入 ViewChild 並將他綁定在子層上\n```typescript\nimport { Component, AfterViewInit, ViewChild } from '@angular/core';  // (1)\nimport { ChildComponent } from '../child/child.component';            // (2)\n\n@Component({\n  selector: 'app-parent-component',\n  templateUrl: './parent.component.html'\n})\nexport class ParentComponent implements AfterViewInit {\n  @ViewChild('childComponent')                                        // (3)\n  childComponent!: ChildComponent;                                   \n\n  constructor() { }\n  counterValue = 0;                                                  \n\n  ngAfterViewInit() {}\n\n  getChildCounterValue() {                                            // (4)\n    this.counterValue = this.childComponent.childCounterValue();      // (5)\n  }\n}\n```\n- (1): 透過 import 將 ViewChild 引入\n- (2): 透過 import 將 sub-component 引入\n- (3): 使用 @ViewChild 將 childComponent  property 裝飾為可以獲得子層內容，並將這個 property 的型態設定為 ChildComponent\n- (4): 新增一個 method，當使用者點擊畫面按鈕時觸發\n- (5): 將子層的 property 賦予給父層的 property\n\n## Configuring the parent's template\n接著我們在 parent.compoent.html 中新增一個 `<button>`，當使用這點擊時觸發將子層的 property 賦值給父層的 property 並將他顯示出來。\n```html\n<!-- parent.component.html -->\n<p>parent component works!</p>\n<div>Get child component counter value: {{counterValue}}</div>\n<button (click)=\"getChildCounterValue()\">Get child value</button>\n<hr>\n<app-child-component #childComponent></app-child-component>\n```\n\n可以看到當我們更改了子層的 property 後， 我們點擊了父層的 button 後，父層的 component 透過利用 ViewChild inject 到 parent.component.ts 的方法直接獲得了子層中的 method，並將內容賦予在父層的 property 上。\n\n要注意的是，當要用這個方法獲得子層的 property 或 method 時，需要在 ngAfterViewInit( ) 結束之後才拿得到，因為需要 Angular 需要完整的初始化完自身 Component 和 sub-component 的 view 之後才能拿到  sub-component 的內容，這點要非常注意。\n\n\n\n# 結論\n在本篇章中介紹了如何透過 @Input( ) 進行從父層傳遞資料給子層的動作，也介紹了如何使用 @Output( ) 將子層的事件向上傳遞給父層， Component 之間的溝通再開發 Angular app 之間是非常重要的，所以一定要知道該如何使用，最後也介紹了如何將 sub-component inject 給父層，讓父層可以直接調用到 sub-component 的 property 和 method，下一篇要來介紹 ng-content，就是將一個 component 投影到另一個 component 上，那我們就下一篇再見吧。\n\n\n\n# Reference \n- [Angular.io - input & output](https://angular.io/guide/inputs-outputs)\n","source":"_posts/Angular/angular-06.md","raw":"---\ntitle: Day6. Sharing data between child and parent directives and components\ndate: 2022-02-15 15:34:28\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n我們了解到 Angular app 是由無數個大大小小的 Component 所組成的，所以就會常常需要使用將 Component 嵌套，一個大個 Component 中包含了 10 個小的 Component 之類的，那麼讓資料在父子層 Component 之間傳遞就非常重要，要實現這個功能就需要使用到 Angular 中的 @Input() 和 @Output()。\n\n@Input() 是讓父層更新子層 Component 中的數據，相反的 @Output() 是為讓子層向父層 Component 發送數據的。\n\n下面我們會做一個簡單的例子來實際使用與講解如使用 @Input() 與 @Output()。\n![https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png](https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png)\n\n<!--more-->\n\n# Sending data to a child component\n大概知道了 Angular 是如何讓父子層 Component  之間傳遞數據的，接下來我們使用一個小小的例子來講解與操作這個功能吧。\n\n## Create child and parent components\n首先我們先透過 Angular CLI 建立兩個父子層關係的 Component。\n```bash\nng generate component parent\nng generate component child\n```\n創建完後，我們將在 parent.component.html 中加入 child.component .ts 中的 selector，建立兩個 Component 的父子層關係。\n```html\n<!-- parent.component.html -->\n<p>parent component works!</p>\n<hr>\n<app-child-component></app-child-component>\n```\n我們打開網頁的開發模式，來確認一下 DOM 是不是確實有將兩個 Component 建立為父子層關係。\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png)\n\n## Configuring the child component\n首先第一步我們要在 child.component.ts 中使用 `@Input()` 裝飾器，先把他透過 import 從 `@angular/core` 中引用進來然後使用它。\n```typescript\nimport { Component, Input } from '@angular/core';  // (1)\n\n@Component({\n  selector: 'app-child-component',\n  templateUrl: './child.component.html'\n})\nexport class ChildComponent {\n  @Input() item = ''; // (2)\n  constructor() { }\n}\n```\n- (1): 使用 import 將 @Input 引入\n- (2): 使用 @Input( ) 裝飾 property \"item\"\n\n可以看到我們使用了 @Input() 裝飾了 ChildComponent 中的 item 這個 property， 雖然在上面的例子中是將他初始化為 string，但是`不代表使用 @Input() 裝飾的 property 只能是字串型態`，他可以是任一種資料型態，代表著這個 property 來自父層。\n\n接下來我們將這個 property 放在 child.component.html 中讓我們可以觀察他的變化。\n```\n<!-- child.component.html  -->\n<p>child component works!</p>\n\n<div>Today's item: {{ item }}</div>\n```\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png)\n在畫面中我們會看到我們打上的 Today's item 後面並沒有東西（因為父層還沒傳資料下來啊～!\n\n## Configuring the parent component\n接下來我們來在父層的 HTML 中綁定屬性：\n1. 先 parent.component.ts 中定義一個 property 並將他賦值\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent-component',\n  templateUrl: './parent.component.html'\n})\nexport class ParentComponent {\n  constructor() { }\n  currentItem = 'Television';  // defind a property\n}\n```\n2. 在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層\n```html\n<app-child-component [item]=\"currentItem\"></app-child-component>\n```\n![https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png](https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png)\n\n在畫面中可以看到原本 Today's item 後面什麼都沒有的卻顯示了來自 parent.component.ts 中的 property 內容，這就是透過 @Input( ) 將父層的資料傳遞給子層。\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767EYEXWLzvqp.png](https://lh3.googleusercontent.com/NRaoUQUGHeo774fUM3u9g-s8BMPkiS-pfcrfArgAugzTrNx2OHlVISHGBjmfzGrophrKYmXKFDJeDCV4Apif3v0qpT3Vq5U0bp5_ALAJ7y4xVX9lFjxUlg2TNXiOINLAv-JOCfFZaERBBti_ku0Hr76v9964ZFXAssFbUjCexnaOlVZ64N41va0sAGxUSZ0RTHfarVsNn5fMU3ZKcFiURwxjpdypvb0G89UjExhAb8DflKFsV_RL2AH9FORmTfFi4kCOY0gv4VgMrOF2-OccsVn-1Proaq9GswprjAZN4WcsE9KtQKjNBHY2L4r6SVij5d1DBnloCpDJMprkCbPqNxubfAVHZZ7DSw4x1D1VQLl-SPzxsmmz-W5SrGLJ8tsFEK5DGu9JB6_gdsrFYbTyoWsAo7ylV8wW6_UZrOR2RN4PFbnYOfuzf3XL0MzTeO8sy6hq9_Nr_pmMiIuTJlLduff_WSdpON3wNBYD74gRk21cEDVA-Ih8MIhOmOUt-VEBqqB_-GbDOWIJb3YVD5R6GuNCTuEHy1d6HwCrcOd5z2KdHOVuomgHGsg2aQX81W9ZVQkvT_zOg1RgU5qDNd8MxMwieQasVVvmuh9EJ3b4S5iqN2R2WyrS9pLj0V2cOc6J4YZpBaZm7VXtsVyLX2yUZEv6y02bhrrZiTm8FglASN2s6xjx-ZmAJOo4U7qALg7gmfkwSkpa0DQcimTmlTgWV8ovSy90-dS2pmEBa9Cp0xblaRWT=w700-h180-no)\n上面的圖已看到，[ ] 中的目標是你在子層使用 @Input() 裝飾的 property，而 source (等好右邊的部分) 是父層要提供給子層數據的名稱，也就是在父層中為了要傳遞給子層數值所定義的 property。\n\n我們在 Lifecycle 中有提到，ngOnChange() 被調用的條件，除了 Component 剛被創建出來的第一次調用之外，其他的每一次都是在當有 input binding 發生改變時會被調用，這代表著如果父層要向下傳遞的 property 發生改變時，就會觸發子層的 ngOnChange()。\n\n\n\n# Sending data to a parent component\n講解完如何透過 @Input() 將父層的數據傳給子層後，接下來介紹如何透過 @Output() 讓子層的數據傳遞給父層。\n\n首先 @Output() 裝飾器它可以讓子層的 property 標記成為數據可以傳遞給父層的入口，子層透過使用被 @Output() 裝飾的 property 觸發 event 來通知父層數據已經被更改了，要觸發事件這個子層的 property 必須是 \"EventEmitter\" 型別，他可以從 '@angular/core' 中引入，下面我們一樣會用一個小例子舉例並講解。\n\n## Configuring the child component\n我們在 child 中設置一個可以點擊一個 `<button>` 來觸發 EventEmitter，並將數據傳遞給父層。\n```typescript\nimport { Component, Output, EventEmitter } from '@angular/core';  // (1)\n\n@Component({\n  selector: 'app-child-component',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css']\n})\nexport class ChildComponent {\n  @Output() newItemEvent = new EventEmitter<boolean>();  // (2)\n  constructor() { }\n\n  parentValueChange(value: boolean) {  // (3)\n    this.newItemEvent.emit(value);\n  }\n}\n```\n- (1): 使用 import 將 @Output 與 @EventEmitter 引入\n- (2): 使用 @Output( ) 裝飾一個 property，上面的例子中是 newItemEvent 是一個 EventEmitter 的類型，代表他是一個 event 並會傳遞一個型別為字串的數值\n- (3): 新增一個 method 當使用者點擊畫面的 button 後會觸發此 method 讓子層的數值傳遞給父層\n\n## Configuring the child's template\n接著我們來更改 child.component.html 的內容，我們新增兩個 `<button>` 讓使用者可以對這兩個物件進行操作\n```html\n<!-- child.component.html  -->\n<p>child component works!</p>\n\n<div class=\"button\">\n    <button (click)=\"parentValueChange(true)\">+</button>\n    <button (click)=\"parentValueChange(false)\">-</button>\n</div>\n```\n我們將畫面中的兩個 button 都綁定一個 click event，當點擊 + 這個按鍵就會觸發並將 true 做為參數傳給 parentValueChange，反之傳 false。\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png)\n\n## Configuring the parent component\n接著我們在父層中添加一個 property 讓我們可以透過子層操控這個屬性。\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-parent-component',\n  templateUrl: './parent.component.html'\n})\nexport class ParentComponent {\n  constructor() { }\n  counterValue = 0;\n\n  addOrSub(event: boolean) {       // (1)\n    if (event) {\n      this.counterValue++;\n    } else {\n      this.counterValue--;\n    }\n  }\n}\n```\n- (1): 在 parent.component.ts 中新增一個 method，當接收到子層傳遞上來的數值時，判斷要將 counterValue 增加或減少。\n\n## Configuring the parent's template\n接著在 parent.component.html 中將 method 綁定到 child's event 上，讓子層的事件可以觸發到父層的 method。\n```html\n<!-- parent.component.html -->\n<p>parent component works!</p>\n<div>parent component property counter: {{counterValue}}</div>\n\n<hr>\n<app-child-component (newItemEvent)=\"addOrSub($event)\"></app-child-component>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png](https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png)\n\n如同 @Input() 一樣，在 () 內的是在子層利用 @Output() 裝飾的 property，因為他是一個 event，所以當子層觸發 event 後會將子層更改的值透過 event 傳遞給父層的 method，而 source( 等號右邊 ) 是父層定義用來接子層傳上來數值的 method。\n\n當你要對同一個子層同時使用 @Input() 和 @Output() 時，可以使用 Tow-way Binding [()]，就可以不用像上面一樣寫得這麼長了，這個方法會在之後詳細講解。\n\n\n\n# Parent calls an @ViewChild()\n介紹完 @Input() 與 @Output() 後，接著要來介紹 @ViewChild() 這個東西，他的存在是因為在 Angular 中父層 Component 無法訪問到子層的 Component，因為`每個 Component 都是一個個獨立的 Class instance，所以在沒有互相連接的情況下是不能訪問到子層的 property 和 method`，所以當開發時遇到這類型的狀況時，需要將子層 Component 作為 ViewChild inject 給父層，在下面舉一個簡單的例子。\n\n## Configuring the child component\n首先先在 child.component.ts 新增一個 property 與 method，讓使用者點擊畫面的 button 時可以加減這個值。\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-child-component',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css']\n})\nexport class ChildComponent {\n  childCounter = 0;       // (1)\n  constructor() { }\n\n  parentValueChange(value: boolean) {     // (2)\n    if (value) {\n      this.childCounter++;\n    } else {\n      this.childCounter--;\n    }\n  }\n\n  childCounterValue() {                   // (3)\n    return this.childCounter;\n  }\n}\n```\n- (1): 新增一個 property 讓他可以被增加或減少\n- (2): 新增一個 method，當使用者點擊畫面按鈕時觸發\n- (3): 新增一個 method，他將回傳子層的 property\n\n## Configuring the child's template\n接著我們在 child.component.html 中新增兩個 `<button>` 並將我們的 childCounter 顯示出來。\n```html\n<!-- child.component.html  -->\n<p>child component works!</p>\n\n<p>Child component counter value: {{childCounter}}</p>\n<div class=\"button\">\n    <button (click)=\"parentValueChange(true)\">+</button>\n    <button (click)=\"parentValueChange(false)\">-</button>\n</div>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png](https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png)\n\n## Configuring the parent component\n接著我們在父層在 '@angular/core' 中引入 ViewChild 並將他綁定在子層上\n```typescript\nimport { Component, AfterViewInit, ViewChild } from '@angular/core';  // (1)\nimport { ChildComponent } from '../child/child.component';            // (2)\n\n@Component({\n  selector: 'app-parent-component',\n  templateUrl: './parent.component.html'\n})\nexport class ParentComponent implements AfterViewInit {\n  @ViewChild('childComponent')                                        // (3)\n  childComponent!: ChildComponent;                                   \n\n  constructor() { }\n  counterValue = 0;                                                  \n\n  ngAfterViewInit() {}\n\n  getChildCounterValue() {                                            // (4)\n    this.counterValue = this.childComponent.childCounterValue();      // (5)\n  }\n}\n```\n- (1): 透過 import 將 ViewChild 引入\n- (2): 透過 import 將 sub-component 引入\n- (3): 使用 @ViewChild 將 childComponent  property 裝飾為可以獲得子層內容，並將這個 property 的型態設定為 ChildComponent\n- (4): 新增一個 method，當使用者點擊畫面按鈕時觸發\n- (5): 將子層的 property 賦予給父層的 property\n\n## Configuring the parent's template\n接著我們在 parent.compoent.html 中新增一個 `<button>`，當使用這點擊時觸發將子層的 property 賦值給父層的 property 並將他顯示出來。\n```html\n<!-- parent.component.html -->\n<p>parent component works!</p>\n<div>Get child component counter value: {{counterValue}}</div>\n<button (click)=\"getChildCounterValue()\">Get child value</button>\n<hr>\n<app-child-component #childComponent></app-child-component>\n```\n\n可以看到當我們更改了子層的 property 後， 我們點擊了父層的 button 後，父層的 component 透過利用 ViewChild inject 到 parent.component.ts 的方法直接獲得了子層中的 method，並將內容賦予在父層的 property 上。\n\n要注意的是，當要用這個方法獲得子層的 property 或 method 時，需要在 ngAfterViewInit( ) 結束之後才拿得到，因為需要 Angular 需要完整的初始化完自身 Component 和 sub-component 的 view 之後才能拿到  sub-component 的內容，這點要非常注意。\n\n\n\n# 結論\n在本篇章中介紹了如何透過 @Input( ) 進行從父層傳遞資料給子層的動作，也介紹了如何使用 @Output( ) 將子層的事件向上傳遞給父層， Component 之間的溝通再開發 Angular app 之間是非常重要的，所以一定要知道該如何使用，最後也介紹了如何將 sub-component inject 給父層，讓父層可以直接調用到 sub-component 的 property 和 method，下一篇要來介紹 ng-content，就是將一個 component 投影到另一個 component 上，那我們就下一篇再見吧。\n\n\n\n# Reference \n- [Angular.io - input & output](https://angular.io/guide/inputs-outputs)\n","slug":"Angular/angular-06","published":1,"updated":"2022-02-15T10:15:52.477Z","_id":"ckznurmnl000dkww36xbj5wov","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我們了解到 Angular app 是由無數個大大小小的 Component 所組成的，所以就會常常需要使用將 Component 嵌套，一個大個 Component 中包含了 10 個小的 Component 之類的，那麼讓資料在父子層 Component 之間傳遞就非常重要，要實現這個功能就需要使用到 Angular 中的 @Input() 和 @Output()。</p>\n<p>@Input() 是讓父層更新子層 Component 中的數據，相反的 @Output() 是為讓子層向父層 Component 發送數據的。</p>\n<p>下面我們會做一個簡單的例子來實際使用與講解如使用 @Input() 與 @Output()。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Sending-data-to-a-child-component\"><a href=\"#Sending-data-to-a-child-component\" class=\"headerlink\" title=\"Sending data to a child component\"></a>Sending data to a child component</h1><p>大概知道了 Angular 是如何讓父子層 Component  之間傳遞數據的，接下來我們使用一個小小的例子來講解與操作這個功能吧。</p>\n<h2 id=\"Create-child-and-parent-components\"><a href=\"#Create-child-and-parent-components\" class=\"headerlink\" title=\"Create child and parent components\"></a>Create child and parent components</h2><p>首先我們先透過 Angular CLI 建立兩個父子層關係的 Component。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component parent</span><br><span class=\"line\">ng generate component child</span><br></pre></td></tr></table></figure>\n<p>創建完後，我們將在 parent.component.html 中加入 child.component .ts 中的 selector，建立兩個 Component 的父子層關係。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我們打開網頁的開發模式，來確認一下 DOM 是不是確實有將兩個 Component 建立為父子層關係。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png\"></p>\n<h2 id=\"Configuring-the-child-component\"><a href=\"#Configuring-the-child-component\" class=\"headerlink\" title=\"Configuring the child component\"></a>Configuring the child component</h2><p>首先第一步我們要在 child.component.ts 中使用 <code>@Input()</code> 裝飾器，先把他透過 import 從 <code>@angular/core</code> 中引用進來然後使用它。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;  <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() item = <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 使用 import 將 @Input 引入</li>\n<li>(2): 使用 @Input( ) 裝飾 property “item”</li>\n</ul>\n<p>可以看到我們使用了 @Input() 裝飾了 ChildComponent 中的 item 這個 property， 雖然在上面的例子中是將他初始化為 string，但是<code>不代表使用 @Input() 裝飾的 property 只能是字串型態</code>，他可以是任一種資料型態，代表著這個 property 來自父層。</p>\n<p>接下來我們將這個 property 放在 child.component.html 中讓我們可以觀察他的變化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- child.component.html  --&gt;</span><br><span class=\"line\">&lt;p&gt;child component works!&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;Today&#x27;s item: &#123;&#123; item &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png\"><br>在畫面中我們會看到我們打上的 Today’s item 後面並沒有東西（因為父層還沒傳資料下來啊～!</p>\n<h2 id=\"Configuring-the-parent-component\"><a href=\"#Configuring-the-parent-component\" class=\"headerlink\" title=\"Configuring the parent component\"></a>Configuring the parent component</h2><p>接下來我們來在父層的 HTML 中綁定屬性：</p>\n<ol>\n<li>先 parent.component.ts 中定義一個 property 並將他賦值<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  currentItem = <span class=\"string\">&#x27;Television&#x27;</span>;  <span class=\"comment\">// defind a property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> [<span class=\"attr\">item</span>]=<span class=\"string\">&quot;currentItem&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png\"></li>\n</ol>\n<p>在畫面中可以看到原本 Today’s item 後面什麼都沒有的卻顯示了來自 parent.component.ts 中的 property 內容，這就是透過 @Input( ) 將父層的資料傳遞給子層。<br><img src=\"https://lh3.googleusercontent.com/NRaoUQUGHeo774fUM3u9g-s8BMPkiS-pfcrfArgAugzTrNx2OHlVISHGBjmfzGrophrKYmXKFDJeDCV4Apif3v0qpT3Vq5U0bp5_ALAJ7y4xVX9lFjxUlg2TNXiOINLAv-JOCfFZaERBBti_ku0Hr76v9964ZFXAssFbUjCexnaOlVZ64N41va0sAGxUSZ0RTHfarVsNn5fMU3ZKcFiURwxjpdypvb0G89UjExhAb8DflKFsV_RL2AH9FORmTfFi4kCOY0gv4VgMrOF2-OccsVn-1Proaq9GswprjAZN4WcsE9KtQKjNBHY2L4r6SVij5d1DBnloCpDJMprkCbPqNxubfAVHZZ7DSw4x1D1VQLl-SPzxsmmz-W5SrGLJ8tsFEK5DGu9JB6_gdsrFYbTyoWsAo7ylV8wW6_UZrOR2RN4PFbnYOfuzf3XL0MzTeO8sy6hq9_Nr_pmMiIuTJlLduff_WSdpON3wNBYD74gRk21cEDVA-Ih8MIhOmOUt-VEBqqB_-GbDOWIJb3YVD5R6GuNCTuEHy1d6HwCrcOd5z2KdHOVuomgHGsg2aQX81W9ZVQkvT_zOg1RgU5qDNd8MxMwieQasVVvmuh9EJ3b4S5iqN2R2WyrS9pLj0V2cOc6J4YZpBaZm7VXtsVyLX2yUZEv6y02bhrrZiTm8FglASN2s6xjx-ZmAJOo4U7qALg7gmfkwSkpa0DQcimTmlTgWV8ovSy90-dS2pmEBa9Cp0xblaRWT=w700-h180-no\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767EYEXWLzvqp.png\"><br>上面的圖已看到，[ ] 中的目標是你在子層使用 @Input() 裝飾的 property，而 source (等好右邊的部分) 是父層要提供給子層數據的名稱，也就是在父層中為了要傳遞給子層數值所定義的 property。</p>\n<p>我們在 Lifecycle 中有提到，ngOnChange() 被調用的條件，除了 Component 剛被創建出來的第一次調用之外，其他的每一次都是在當有 input binding 發生改變時會被調用，這代表著如果父層要向下傳遞的 property 發生改變時，就會觸發子層的 ngOnChange()。</p>\n<h1 id=\"Sending-data-to-a-parent-component\"><a href=\"#Sending-data-to-a-parent-component\" class=\"headerlink\" title=\"Sending data to a parent component\"></a>Sending data to a parent component</h1><p>講解完如何透過 @Input() 將父層的數據傳給子層後，接下來介紹如何透過 @Output() 讓子層的數據傳遞給父層。</p>\n<p>首先 @Output() 裝飾器它可以讓子層的 property 標記成為數據可以傳遞給父層的入口，子層透過使用被 @Output() 裝飾的 property 觸發 event 來通知父層數據已經被更改了，要觸發事件這個子層的 property 必須是 “EventEmitter” 型別，他可以從 ‘@angular&#x2F;core’ 中引入，下面我們一樣會用一個小例子舉例並講解。</p>\n<h2 id=\"Configuring-the-child-component-1\"><a href=\"#Configuring-the-child-component-1\" class=\"headerlink\" title=\"Configuring the child component\"></a>Configuring the child component</h2><p>我們在 child 中設置一個可以點擊一個 <code>&lt;button&gt;</code> 來觸發 EventEmitter，並將數據傳遞給父層。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;  <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Output</span>() newItemEvent = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;<span class=\"built_in\">boolean</span>&gt;();  <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">parentValueChange</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) &#123;  <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">newItemEvent</span>.<span class=\"title function_\">emit</span>(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 使用 import 將 @Output 與 @EventEmitter 引入</li>\n<li>(2): 使用 @Output( ) 裝飾一個 property，上面的例子中是 newItemEvent 是一個 EventEmitter 的類型，代表他是一個 event 並會傳遞一個型別為字串的數值</li>\n<li>(3): 新增一個 method 當使用者點擊畫面的 button 後會觸發此 method 讓子層的數值傳遞給父層</li>\n</ul>\n<h2 id=\"Configuring-the-child’s-template\"><a href=\"#Configuring-the-child’s-template\" class=\"headerlink\" title=\"Configuring the child’s template\"></a>Configuring the child’s template</h2><p>接著我們來更改 child.component.html 的內容，我們新增兩個 <code>&lt;button&gt;</code> 讓使用者可以對這兩個物件進行操作</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- child.component.html  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>child component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(true)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(false)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我們將畫面中的兩個 button 都綁定一個 click event，當點擊 + 這個按鍵就會觸發並將 true 做為參數傳給 parentValueChange，反之傳 false。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png\"></p>\n<h2 id=\"Configuring-the-parent-component-1\"><a href=\"#Configuring-the-parent-component-1\" class=\"headerlink\" title=\"Configuring the parent component\"></a>Configuring the parent component</h2><p>接著我們在父層中添加一個 property 讓我們可以透過子層操控這個屬性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  counterValue = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addOrSub</span>(<span class=\"params\">event: <span class=\"built_in\">boolean</span></span>) &#123;       <span class=\"comment\">// (1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 在 parent.component.ts 中新增一個 method，當接收到子層傳遞上來的數值時，判斷要將 counterValue 增加或減少。</li>\n</ul>\n<h2 id=\"Configuring-the-parent’s-template\"><a href=\"#Configuring-the-parent’s-template\" class=\"headerlink\" title=\"Configuring the parent’s template\"></a>Configuring the parent’s template</h2><p>接著在 parent.component.html 中將 method 綁定到 child’s event 上，讓子層的事件可以觸發到父層的 method。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>parent component property counter: &#123;&#123;counterValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> (<span class=\"attr\">newItemEvent</span>)=<span class=\"string\">&quot;addOrSub($event)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png\"></p>\n<p>如同 @Input() 一樣，在 () 內的是在子層利用 @Output() 裝飾的 property，因為他是一個 event，所以當子層觸發 event 後會將子層更改的值透過 event 傳遞給父層的 method，而 source( 等號右邊 ) 是父層定義用來接子層傳上來數值的 method。</p>\n<p>當你要對同一個子層同時使用 @Input() 和 @Output() 時，可以使用 Tow-way Binding [()]，就可以不用像上面一樣寫得這麼長了，這個方法會在之後詳細講解。</p>\n<h1 id=\"Parent-calls-an-ViewChild\"><a href=\"#Parent-calls-an-ViewChild\" class=\"headerlink\" title=\"Parent calls an @ViewChild()\"></a>Parent calls an @ViewChild()</h1><p>介紹完 @Input() 與 @Output() 後，接著要來介紹 @ViewChild() 這個東西，他的存在是因為在 Angular 中父層 Component 無法訪問到子層的 Component，因為<code>每個 Component 都是一個個獨立的 Class instance，所以在沒有互相連接的情況下是不能訪問到子層的 property 和 method</code>，所以當開發時遇到這類型的狀況時，需要將子層 Component 作為 ViewChild inject 給父層，在下面舉一個簡單的例子。</p>\n<h2 id=\"Configuring-the-child-component-2\"><a href=\"#Configuring-the-child-component-2\" class=\"headerlink\" title=\"Configuring the child component\"></a>Configuring the child component</h2><p>首先先在 child.component.ts 新增一個 property 與 method，讓使用者點擊畫面的 button 時可以加減這個值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  childCounter = <span class=\"number\">0</span>;       <span class=\"comment\">// (1)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">parentValueChange</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) &#123;     <span class=\"comment\">// (2)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">childCounter</span>++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">childCounter</span>--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">childCounterValue</span>(<span class=\"params\"></span>) &#123;                   <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">childCounter</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 新增一個 property 讓他可以被增加或減少</li>\n<li>(2): 新增一個 method，當使用者點擊畫面按鈕時觸發</li>\n<li>(3): 新增一個 method，他將回傳子層的 property</li>\n</ul>\n<h2 id=\"Configuring-the-child’s-template-1\"><a href=\"#Configuring-the-child’s-template-1\" class=\"headerlink\" title=\"Configuring the child’s template\"></a>Configuring the child’s template</h2><p>接著我們在 child.component.html 中新增兩個 <code>&lt;button&gt;</code> 並將我們的 childCounter 顯示出來。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- child.component.html  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>child component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Child component counter value: &#123;&#123;childCounter&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(true)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(false)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png\"></p>\n<h2 id=\"Configuring-the-parent-component-2\"><a href=\"#Configuring-the-parent-component-2\" class=\"headerlink\" title=\"Configuring the parent component\"></a>Configuring the parent component</h2><p>接著我們在父層在 ‘@angular&#x2F;core’ 中引入 ViewChild 並將他綁定在子層上</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">AfterViewInit</span>, <span class=\"title class_\">ViewChild</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;  <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ChildComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../child/child.component&#x27;</span>;            <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AfterViewInit</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@ViewChild</span>(<span class=\"string\">&#x27;childComponent&#x27;</span>)                                        <span class=\"comment\">// (3)</span></span><br><span class=\"line\">  childComponent!: <span class=\"title class_\">ChildComponent</span>;                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  counterValue = <span class=\"number\">0</span>;                                                  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngAfterViewInit</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">getChildCounterValue</span>(<span class=\"params\"></span>) &#123;                                            <span class=\"comment\">// (4)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">childComponent</span>.<span class=\"title function_\">childCounterValue</span>();      <span class=\"comment\">// (5)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 透過 import 將 ViewChild 引入</li>\n<li>(2): 透過 import 將 sub-component 引入</li>\n<li>(3): 使用 @ViewChild 將 childComponent  property 裝飾為可以獲得子層內容，並將這個 property 的型態設定為 ChildComponent</li>\n<li>(4): 新增一個 method，當使用者點擊畫面按鈕時觸發</li>\n<li>(5): 將子層的 property 賦予給父層的 property</li>\n</ul>\n<h2 id=\"Configuring-the-parent’s-template-1\"><a href=\"#Configuring-the-parent’s-template-1\" class=\"headerlink\" title=\"Configuring the parent’s template\"></a>Configuring the parent’s template</h2><p>接著我們在 parent.compoent.html 中新增一個 <code>&lt;button&gt;</code>，當使用這點擊時觸發將子層的 property 賦值給父層的 property 並將他顯示出來。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Get child component counter value: &#123;&#123;counterValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;getChildCounterValue()&quot;</span>&gt;</span>Get child value<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> #<span class=\"attr\">childComponent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到當我們更改了子層的 property 後， 我們點擊了父層的 button 後，父層的 component 透過利用 ViewChild inject 到 parent.component.ts 的方法直接獲得了子層中的 method，並將內容賦予在父層的 property 上。</p>\n<p>要注意的是，當要用這個方法獲得子層的 property 或 method 時，需要在 ngAfterViewInit( ) 結束之後才拿得到，因為需要 Angular 需要完整的初始化完自身 Component 和 sub-component 的 view 之後才能拿到  sub-component 的內容，這點要非常注意。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本篇章中介紹了如何透過 @Input( ) 進行從父層傳遞資料給子層的動作，也介紹了如何使用 @Output( ) 將子層的事件向上傳遞給父層， Component 之間的溝通再開發 Angular app 之間是非常重要的，所以一定要知道該如何使用，最後也介紹了如何將 sub-component inject 給父層，讓父層可以直接調用到 sub-component 的 property 和 method，下一篇要來介紹 ng-content，就是將一個 component 投影到另一個 component 上，那我們就下一篇再見吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/inputs-outputs\">Angular.io - input &amp; output</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>我們了解到 Angular app 是由無數個大大小小的 Component 所組成的，所以就會常常需要使用將 Component 嵌套，一個大個 Component 中包含了 10 個小的 Component 之類的，那麼讓資料在父子層 Component 之間傳遞就非常重要，要實現這個功能就需要使用到 Angular 中的 @Input() 和 @Output()。</p>\n<p>@Input() 是讓父層更新子層 Component 中的數據，相反的 @Output() 是為讓子層向父層 Component 發送數據的。</p>\n<p>下面我們會做一個簡單的例子來實際使用與講解如使用 @Input() 與 @Output()。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247672eB7GrD26l.png\"></p>","more":"<h1 id=\"Sending-data-to-a-child-component\"><a href=\"#Sending-data-to-a-child-component\" class=\"headerlink\" title=\"Sending data to a child component\"></a>Sending data to a child component</h1><p>大概知道了 Angular 是如何讓父子層 Component  之間傳遞數據的，接下來我們使用一個小小的例子來講解與操作這個功能吧。</p>\n<h2 id=\"Create-child-and-parent-components\"><a href=\"#Create-child-and-parent-components\" class=\"headerlink\" title=\"Create child and parent components\"></a>Create child and parent components</h2><p>首先我們先透過 Angular CLI 建立兩個父子層關係的 Component。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component parent</span><br><span class=\"line\">ng generate component child</span><br></pre></td></tr></table></figure>\n<p>創建完後，我們將在 parent.component.html 中加入 child.component .ts 中的 selector，建立兩個 Component 的父子層關係。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我們打開網頁的開發模式，來確認一下 DOM 是不是確實有將兩個 Component 建立為父子層關係。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767ChY81vvKyk.png\"></p>\n<h2 id=\"Configuring-the-child-component\"><a href=\"#Configuring-the-child-component\" class=\"headerlink\" title=\"Configuring the child component\"></a>Configuring the child component</h2><p>首先第一步我們要在 child.component.ts 中使用 <code>@Input()</code> 裝飾器，先把他透過 import 從 <code>@angular/core</code> 中引用進來然後使用它。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;  <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() item = <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 使用 import 將 @Input 引入</li>\n<li>(2): 使用 @Input( ) 裝飾 property “item”</li>\n</ul>\n<p>可以看到我們使用了 @Input() 裝飾了 ChildComponent 中的 item 這個 property， 雖然在上面的例子中是將他初始化為 string，但是<code>不代表使用 @Input() 裝飾的 property 只能是字串型態</code>，他可以是任一種資料型態，代表著這個 property 來自父層。</p>\n<p>接下來我們將這個 property 放在 child.component.html 中讓我們可以觀察他的變化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- child.component.html  --&gt;</span><br><span class=\"line\">&lt;p&gt;child component works!&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;Today&#x27;s item: &#123;&#123; item &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767b4TcSxH9Bf.png\"><br>在畫面中我們會看到我們打上的 Today’s item 後面並沒有東西（因為父層還沒傳資料下來啊～!</p>\n<h2 id=\"Configuring-the-parent-component\"><a href=\"#Configuring-the-parent-component\" class=\"headerlink\" title=\"Configuring the parent component\"></a>Configuring the parent component</h2><p>接下來我們來在父層的 HTML 中綁定屬性：</p>\n<ol>\n<li>先 parent.component.ts 中定義一個 property 並將他賦值<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  currentItem = <span class=\"string\">&#x27;Television&#x27;</span>;  <span class=\"comment\">// defind a property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> [<span class=\"attr\">item</span>]=<span class=\"string\">&quot;currentItem&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247671HPuawu3l0.png\"></li>\n</ol>\n<p>在畫面中可以看到原本 Today’s item 後面什麼都沒有的卻顯示了來自 parent.component.ts 中的 property 內容，這就是透過 @Input( ) 將父層的資料傳遞給子層。<br><img src=\"https://lh3.googleusercontent.com/NRaoUQUGHeo774fUM3u9g-s8BMPkiS-pfcrfArgAugzTrNx2OHlVISHGBjmfzGrophrKYmXKFDJeDCV4Apif3v0qpT3Vq5U0bp5_ALAJ7y4xVX9lFjxUlg2TNXiOINLAv-JOCfFZaERBBti_ku0Hr76v9964ZFXAssFbUjCexnaOlVZ64N41va0sAGxUSZ0RTHfarVsNn5fMU3ZKcFiURwxjpdypvb0G89UjExhAb8DflKFsV_RL2AH9FORmTfFi4kCOY0gv4VgMrOF2-OccsVn-1Proaq9GswprjAZN4WcsE9KtQKjNBHY2L4r6SVij5d1DBnloCpDJMprkCbPqNxubfAVHZZ7DSw4x1D1VQLl-SPzxsmmz-W5SrGLJ8tsFEK5DGu9JB6_gdsrFYbTyoWsAo7ylV8wW6_UZrOR2RN4PFbnYOfuzf3XL0MzTeO8sy6hq9_Nr_pmMiIuTJlLduff_WSdpON3wNBYD74gRk21cEDVA-Ih8MIhOmOUt-VEBqqB_-GbDOWIJb3YVD5R6GuNCTuEHy1d6HwCrcOd5z2KdHOVuomgHGsg2aQX81W9ZVQkvT_zOg1RgU5qDNd8MxMwieQasVVvmuh9EJ3b4S5iqN2R2WyrS9pLj0V2cOc6J4YZpBaZm7VXtsVyLX2yUZEv6y02bhrrZiTm8FglASN2s6xjx-ZmAJOo4U7qALg7gmfkwSkpa0DQcimTmlTgWV8ovSy90-dS2pmEBa9Cp0xblaRWT=w700-h180-no\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767EYEXWLzvqp.png\"><br>上面的圖已看到，[ ] 中的目標是你在子層使用 @Input() 裝飾的 property，而 source (等好右邊的部分) 是父層要提供給子層數據的名稱，也就是在父層中為了要傳遞給子層數值所定義的 property。</p>\n<p>我們在 Lifecycle 中有提到，ngOnChange() 被調用的條件，除了 Component 剛被創建出來的第一次調用之外，其他的每一次都是在當有 input binding 發生改變時會被調用，這代表著如果父層要向下傳遞的 property 發生改變時，就會觸發子層的 ngOnChange()。</p>\n<h1 id=\"Sending-data-to-a-parent-component\"><a href=\"#Sending-data-to-a-parent-component\" class=\"headerlink\" title=\"Sending data to a parent component\"></a>Sending data to a parent component</h1><p>講解完如何透過 @Input() 將父層的數據傳給子層後，接下來介紹如何透過 @Output() 讓子層的數據傳遞給父層。</p>\n<p>首先 @Output() 裝飾器它可以讓子層的 property 標記成為數據可以傳遞給父層的入口，子層透過使用被 @Output() 裝飾的 property 觸發 event 來通知父層數據已經被更改了，要觸發事件這個子層的 property 必須是 “EventEmitter” 型別，他可以從 ‘@angular&#x2F;core’ 中引入，下面我們一樣會用一個小例子舉例並講解。</p>\n<h2 id=\"Configuring-the-child-component-1\"><a href=\"#Configuring-the-child-component-1\" class=\"headerlink\" title=\"Configuring the child component\"></a>Configuring the child component</h2><p>我們在 child 中設置一個可以點擊一個 <code>&lt;button&gt;</code> 來觸發 EventEmitter，並將數據傳遞給父層。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;  <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Output</span>() newItemEvent = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;<span class=\"built_in\">boolean</span>&gt;();  <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">parentValueChange</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) &#123;  <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">newItemEvent</span>.<span class=\"title function_\">emit</span>(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 使用 import 將 @Output 與 @EventEmitter 引入</li>\n<li>(2): 使用 @Output( ) 裝飾一個 property，上面的例子中是 newItemEvent 是一個 EventEmitter 的類型，代表他是一個 event 並會傳遞一個型別為字串的數值</li>\n<li>(3): 新增一個 method 當使用者點擊畫面的 button 後會觸發此 method 讓子層的數值傳遞給父層</li>\n</ul>\n<h2 id=\"Configuring-the-child’s-template\"><a href=\"#Configuring-the-child’s-template\" class=\"headerlink\" title=\"Configuring the child’s template\"></a>Configuring the child’s template</h2><p>接著我們來更改 child.component.html 的內容，我們新增兩個 <code>&lt;button&gt;</code> 讓使用者可以對這兩個物件進行操作</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- child.component.html  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>child component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(true)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(false)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我們將畫面中的兩個 button 都綁定一個 click event，當點擊 + 這個按鍵就會觸發並將 true 做為參數傳給 parentValueChange，反之傳 false。<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767HMoK6bEpxI.png\"></p>\n<h2 id=\"Configuring-the-parent-component-1\"><a href=\"#Configuring-the-parent-component-1\" class=\"headerlink\" title=\"Configuring the parent component\"></a>Configuring the parent component</h2><p>接著我們在父層中添加一個 property 讓我們可以透過子層操控這個屬性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  counterValue = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addOrSub</span>(<span class=\"params\">event: <span class=\"built_in\">boolean</span></span>) &#123;       <span class=\"comment\">// (1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 在 parent.component.ts 中新增一個 method，當接收到子層傳遞上來的數值時，判斷要將 counterValue 增加或減少。</li>\n</ul>\n<h2 id=\"Configuring-the-parent’s-template\"><a href=\"#Configuring-the-parent’s-template\" class=\"headerlink\" title=\"Configuring the parent’s template\"></a>Configuring the parent’s template</h2><p>接著在 parent.component.html 中將 method 綁定到 child’s event 上，讓子層的事件可以觸發到父層的 method。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>parent component property counter: &#123;&#123;counterValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> (<span class=\"attr\">newItemEvent</span>)=<span class=\"string\">&quot;addOrSub($event)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/201247676t6UI5GFIe.png\"></p>\n<p>如同 @Input() 一樣，在 () 內的是在子層利用 @Output() 裝飾的 property，因為他是一個 event，所以當子層觸發 event 後會將子層更改的值透過 event 傳遞給父層的 method，而 source( 等號右邊 ) 是父層定義用來接子層傳上來數值的 method。</p>\n<p>當你要對同一個子層同時使用 @Input() 和 @Output() 時，可以使用 Tow-way Binding [()]，就可以不用像上面一樣寫得這麼長了，這個方法會在之後詳細講解。</p>\n<h1 id=\"Parent-calls-an-ViewChild\"><a href=\"#Parent-calls-an-ViewChild\" class=\"headerlink\" title=\"Parent calls an @ViewChild()\"></a>Parent calls an @ViewChild()</h1><p>介紹完 @Input() 與 @Output() 後，接著要來介紹 @ViewChild() 這個東西，他的存在是因為在 Angular 中父層 Component 無法訪問到子層的 Component，因為<code>每個 Component 都是一個個獨立的 Class instance，所以在沒有互相連接的情況下是不能訪問到子層的 property 和 method</code>，所以當開發時遇到這類型的狀況時，需要將子層 Component 作為 ViewChild inject 給父層，在下面舉一個簡單的例子。</p>\n<h2 id=\"Configuring-the-child-component-2\"><a href=\"#Configuring-the-child-component-2\" class=\"headerlink\" title=\"Configuring the child component\"></a>Configuring the child component</h2><p>首先先在 child.component.ts 新增一個 property 與 method，讓使用者點擊畫面的 button 時可以加減這個值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  childCounter = <span class=\"number\">0</span>;       <span class=\"comment\">// (1)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">parentValueChange</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) &#123;     <span class=\"comment\">// (2)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">childCounter</span>++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">childCounter</span>--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">childCounterValue</span>(<span class=\"params\"></span>) &#123;                   <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">childCounter</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 新增一個 property 讓他可以被增加或減少</li>\n<li>(2): 新增一個 method，當使用者點擊畫面按鈕時觸發</li>\n<li>(3): 新增一個 method，他將回傳子層的 property</li>\n</ul>\n<h2 id=\"Configuring-the-child’s-template-1\"><a href=\"#Configuring-the-child’s-template-1\" class=\"headerlink\" title=\"Configuring the child’s template\"></a>Configuring the child’s template</h2><p>接著我們在 child.component.html 中新增兩個 <code>&lt;button&gt;</code> 並將我們的 childCounter 顯示出來。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- child.component.html  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>child component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Child component counter value: &#123;&#123;childCounter&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(true)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(false)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210731/20124767SgNEkRZBMp.png\"></p>\n<h2 id=\"Configuring-the-parent-component-2\"><a href=\"#Configuring-the-parent-component-2\" class=\"headerlink\" title=\"Configuring the parent component\"></a>Configuring the parent component</h2><p>接著我們在父層在 ‘@angular&#x2F;core’ 中引入 ViewChild 並將他綁定在子層上</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">AfterViewInit</span>, <span class=\"title class_\">ViewChild</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;  <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ChildComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../child/child.component&#x27;</span>;            <span class=\"comment\">// (2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AfterViewInit</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@ViewChild</span>(<span class=\"string\">&#x27;childComponent&#x27;</span>)                                        <span class=\"comment\">// (3)</span></span><br><span class=\"line\">  childComponent!: <span class=\"title class_\">ChildComponent</span>;                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  counterValue = <span class=\"number\">0</span>;                                                  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">ngAfterViewInit</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">getChildCounterValue</span>(<span class=\"params\"></span>) &#123;                                            <span class=\"comment\">// (4)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">childComponent</span>.<span class=\"title function_\">childCounterValue</span>();      <span class=\"comment\">// (5)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(1): 透過 import 將 ViewChild 引入</li>\n<li>(2): 透過 import 將 sub-component 引入</li>\n<li>(3): 使用 @ViewChild 將 childComponent  property 裝飾為可以獲得子層內容，並將這個 property 的型態設定為 ChildComponent</li>\n<li>(4): 新增一個 method，當使用者點擊畫面按鈕時觸發</li>\n<li>(5): 將子層的 property 賦予給父層的 property</li>\n</ul>\n<h2 id=\"Configuring-the-parent’s-template-1\"><a href=\"#Configuring-the-parent’s-template-1\" class=\"headerlink\" title=\"Configuring the parent’s template\"></a>Configuring the parent’s template</h2><p>接著我們在 parent.compoent.html 中新增一個 <code>&lt;button&gt;</code>，當使用這點擊時觸發將子層的 property 賦值給父層的 property 並將他顯示出來。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Get child component counter value: &#123;&#123;counterValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;getChildCounterValue()&quot;</span>&gt;</span>Get child value<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> #<span class=\"attr\">childComponent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到當我們更改了子層的 property 後， 我們點擊了父層的 button 後，父層的 component 透過利用 ViewChild inject 到 parent.component.ts 的方法直接獲得了子層中的 method，並將內容賦予在父層的 property 上。</p>\n<p>要注意的是，當要用這個方法獲得子層的 property 或 method 時，需要在 ngAfterViewInit( ) 結束之後才拿得到，因為需要 Angular 需要完整的初始化完自身 Component 和 sub-component 的 view 之後才能拿到  sub-component 的內容，這點要非常注意。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本篇章中介紹了如何透過 @Input( ) 進行從父層傳遞資料給子層的動作，也介紹了如何使用 @Output( ) 將子層的事件向上傳遞給父層， Component 之間的溝通再開發 Angular app 之間是非常重要的，所以一定要知道該如何使用，最後也介紹了如何將 sub-component inject 給父層，讓父層可以直接調用到 sub-component 的 property 和 method，下一篇要來介紹 ng-content，就是將一個 component 投影到另一個 component 上，那我們就下一篇再見吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/inputs-outputs\">Angular.io - input &amp; output</a></li>\n</ul>"},{"title":"Day7. Content projection","date":"2022-02-15T08:09:04.000Z","_content":"\n本章節將要介紹如何使用 ng-content 將一個 Component 的內容投影到另一個 Component 中，創建靈活且可被重複使用的 Component，來滿足程式設計中 DRY (Don't repeat yourself) 的觀念。\n\n在 Angular 中 Content 是一種呈現的模式，可以在其中插入或投影另一個 Component 的內容，簡單來說，當我們在寫 HTML 時常常會有這樣的結構：\n```html\n<div>\n\t<p> Hello World!</p>\n</div>\n```\n在 Angular 的概念中可以把它想像成，有一個 `<p>` tag 被投影到 `<div>` 之中，雖然不是原理可能不這樣子，但是類似的模式。\n\n在 Angular 中有幾種常見的 ng-content 例子：\n\n- **Signle-slot content projection**: 投影來自單一 Source 的 Component 內容\n- **Multi-slot content projection**: 一個 Component 接收來自多個 Source 的 Component 內容\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg](https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg)\n\n<!--more-->\n\n# Single-slot content projection\n在 Angular 的 ng-content 中最基本的就是 single-slot content projection，他是指`將一個 Component 的內容投影在另一個 Component 之中`，我們做一個簡單的小例子來解釋這個行為。\n\n1. 首先我們先使用 Angular CLI 建立一個 Component\n\n    ```bash\n    ng generate component zippy-basic\n    ng g c zippy-basic\n    ```\n2. 在 zippy-basic.component.html 中添加 ng-content 到你希望投影內容出現的位置\n\n    ```html\n    <!-- zippy basic.component.html -->\n    <h2>Single-slot content projection</h2>\n    <div>\n        ng-content content: \n        <ng-content></ng-content>\n    </div>\n    ```\n\n3. 接著我們在 app.component.html 中使用 zippy-basic 的 selector\n\n    ```html\n    <!-- app.component.html -->\n    <app-zippy-basic></app-zippy-basic>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png)\n\n在畫面中我們看到，我們使用 ng-content 的位置什麼都沒有，是出了什麼 bug 嗎？其實不是!，是因為我們還沒決定該把什麼內容投影在 <ng-content> 的位置上，我們來更改一下 app.component.html 的內容\n\n```html\n<!-- app.component.html -->\n<app-zippy-basic>\n    <p>From app.component.html projection content to zippy-basic component</p>\n</app-zippy-basic>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png)\n\n當更改玩 app.component.html 的內容後，可以在畫面中看到，Angular 把我們夾在 `<app-zippy-basic>` 的內容放到 `<ng-content>` 的位置了，\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png)\n\n當然可能有人會問了，那...我直接把 `<p>` 放在 zippy-basic.component.html 不就好了嗎？\n\n```html\n<!-- zippy basic.component.html -->\n<h2>Single-slot content projection</h2>\n<div>\n    ng-content content: \n    <p>From app.component.html projection content to zippy-basic component</p>\n</div>\n```\n\n沒有錯，但是其實 ng-content 通常不是讓你放 html tag 的，我們來舉個例子，想像一下一個場景，當你在開發專案時，有沒有遇到在一個地方需要放置三種不同類型的 button ? 如果是這樣的話你是不是會這麼做\n\n```html\n<div>\n\t<!-- style1 button -->\n\t<label>This is style 1 button</label>\n\t<p>Hello world</p>\n\t<button>button</button>\n<div>\n<div>\n\t<!-- style2 button -->\n\t<label> This is style 2 button </label>\n\t<p>Hello world</p>\n\t<button>button</button>\n<div>\n<div>\n\t<!-- style3 button -->\n\t<label> This is style 3 button </label>\n\t<p>Hello world</p>\n\t<button>button</button>\n<div>\n```\n\n有沒有發現當使用上面這種 HTML 結構雖然可以達到我們要的目的，但是 `<label>`、`<p>`、`<button>` 一直在重複出現但內容卻是一樣的，就違背了 DRY 的原則了，這時候我們就可以使用 ng-content 先將模板做好，再把不同 style 的 `<button>` 投影進去就好，來舉個例子吧：\n\n1. 首先我們先建立一個模板 Component\n\n    ```bash\n    ng generate component content-template\n    ng g c content-template\n    ```\n2. 接著我們在 content-template.component.html 中把我們的模板寫好\n\n    ```html\n    <!-- content-template.component.html -->\n\n    <h1>Content projection number {{styleCount}}</h1>\n    <label>This is style {{styleCount}} button</label>\n    <p>Hello world</p>\n    <ng-content></ng-content>\n    ```\n\n    我們在原本放置不同 style 的地方使用 <ng-content> 變成將別的內容投影到這個位置上，對了還記得昨天提到的 @Input( ) 嗎？ 這邊我們來複習一下，`使用 ng-content 一樣可以由父層傳遞數據到子層喔`。\n\n    ```typescript\n    import { Component, Input } from '@angular/core';\n\n    @Component({\n      selector: 'app-content-template',\n      templateUrl: './content-template.component.html',\n    })\n    export class ContentTemplateComponent {\n      @Input() styleCount: string = '';\n      constructor() { }\n    }\n    ```\n3. 接著我們來更改一下 app.component.html 的內容，讓不同 style 的 button 投影到 content-template 吧\n\n    ```html\n    <!-- app.component.html -->\n    <app-content-template [styleCount]=\"'1'\">\n        <button class=\"style1\">Click Me</button>\n    </app-content-template>\n\n    <app-content-template [styleCount]=\"'2'\">\n        <button class=\"style2\">Click Me</button>\n    </app-content-template>\n\n    <app-content-template [styleCount]=\"'3'\">\n        <button class=\"style3\">Click Me</button>\n    </app-content-template>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png)\n\n這樣就完成了我們的目的，簡單的幾行就可以達到相同的目的，透過`先建立模板再將不同樣式或不同的 Component 投影進這個模板 Component 之中`，就可以讓這個模板 Component 在各個地方都被使用並且達到減少重複程式碼的目的。\n\n\n# Multi-slot content projection\n第二種其實與第一種非常相似，只不過變成了一個 Component 中投影了多個不同的內容，不過值得注意的是，由於是多個不同的內容投影在一個 Component 之中，所以就會有順序位置問題，於是 Angular 提供了 `select` 屬性讓你加在 ng-content 上，讓你可以`將某一個內容放在指定的位置上`，一樣舉個例子吧。\n\n1. 首先一樣創建一個新的 Component\n\n    ```bash\n    ng generate component zippy-basic\n    ng g c zippy-basic\n    ```\n2. 接著我們在 zippy-basic.component.html 中添加 ng-content 到想要的位置\n\n    ```html\n    <!-- zippy-basic.component.html -->\n\n    <h2>Multi-slot content projection</h2>\n    Default:\n    <ng-content></ng-content>\n    Question:\n    <ng-content></ng-content>\n    ```\n3. 接著我們把想要的位置添加一個 select 屬性，讓投影的位置固定在我們想要的地方\n\n    ```html\n    <!-- zippy-basic.component.html -->\n\n    <h2>Multi-slot content projection</h2>\n    Default:\n    <ng-content></ng-content>\n    Question:\n    <ng-content select=\"[question]\"></ng-content>\n    ```\n4. 最後我們在 app.component.html  中將我們像要投影的內容放進去，記得！指定位置的內容需要加上 select 的內容喔\n\n    ```html\n    <!-- app.component.html -->\n\n    <app-zippy-basic>\n      <p question>Is content projection cool?</p>\n      <p>Let's learn about content projection!</p>\n    </app-zippy-basic>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png)\n\n可以看到我們在 app.component.html 中 <p> 的順序與 UI 呈現的順序是顛倒的，就因為我們指定了有 question 這個 select  放置的地方。\n\n與 Single-slot content projection 一樣，Multi-slot content projection 的目的不在於放入原生 HTML 的 Tag，目的與上一個一樣，都是可以先建立一個模板之後將不同的內容投影到這個模板中，只不過多了`可以透過 select 讓你選擇放置的位置`與讓你`可以放多個投影`，這邊就不在做一次練習了，有興趣的話可以自己挑戰一下利用 Multi-slot content projection 完成與上面的例子一樣的內容。\n\n\n\n# 結論\n\n在本章中介紹了什麼是 content projection 以及該如何使用它，在官方文檔中其實除了 Single-slot content projection 與 Multi-slot content projection 之外其實還有第三個常見的投影 `Conditional content projection`，但是因為他牽扯的概念跟本篇章使用 ng-content 比較不一樣，他是透過使用 `ng-template` 來做到這個功能，所以就先不將它納入本章的範圍，這個方法會在之後介紹到。\n\n下一篇將會分享 template 是什麼，他在 Angular 中是 HTML 的角色，而可以在 template 中使用許多語法來達到靈活建立畫面的功能，那我們就下一篇再見吧。\n\n\n# Referece\n- [Angular.io - content-projection](https://angular.io/guide/content-projection)\n","source":"_posts/Angular/angular-07.md","raw":"---\ntitle: Day7. Content projection\ndate: 2022-02-15 16:09:04\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n本章節將要介紹如何使用 ng-content 將一個 Component 的內容投影到另一個 Component 中，創建靈活且可被重複使用的 Component，來滿足程式設計中 DRY (Don't repeat yourself) 的觀念。\n\n在 Angular 中 Content 是一種呈現的模式，可以在其中插入或投影另一個 Component 的內容，簡單來說，當我們在寫 HTML 時常常會有這樣的結構：\n```html\n<div>\n\t<p> Hello World!</p>\n</div>\n```\n在 Angular 的概念中可以把它想像成，有一個 `<p>` tag 被投影到 `<div>` 之中，雖然不是原理可能不這樣子，但是類似的模式。\n\n在 Angular 中有幾種常見的 ng-content 例子：\n\n- **Signle-slot content projection**: 投影來自單一 Source 的 Component 內容\n- **Multi-slot content projection**: 一個 Component 接收來自多個 Source 的 Component 內容\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg](https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg)\n\n<!--more-->\n\n# Single-slot content projection\n在 Angular 的 ng-content 中最基本的就是 single-slot content projection，他是指`將一個 Component 的內容投影在另一個 Component 之中`，我們做一個簡單的小例子來解釋這個行為。\n\n1. 首先我們先使用 Angular CLI 建立一個 Component\n\n    ```bash\n    ng generate component zippy-basic\n    ng g c zippy-basic\n    ```\n2. 在 zippy-basic.component.html 中添加 ng-content 到你希望投影內容出現的位置\n\n    ```html\n    <!-- zippy basic.component.html -->\n    <h2>Single-slot content projection</h2>\n    <div>\n        ng-content content: \n        <ng-content></ng-content>\n    </div>\n    ```\n\n3. 接著我們在 app.component.html 中使用 zippy-basic 的 selector\n\n    ```html\n    <!-- app.component.html -->\n    <app-zippy-basic></app-zippy-basic>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png)\n\n在畫面中我們看到，我們使用 ng-content 的位置什麼都沒有，是出了什麼 bug 嗎？其實不是!，是因為我們還沒決定該把什麼內容投影在 <ng-content> 的位置上，我們來更改一下 app.component.html 的內容\n\n```html\n<!-- app.component.html -->\n<app-zippy-basic>\n    <p>From app.component.html projection content to zippy-basic component</p>\n</app-zippy-basic>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png)\n\n當更改玩 app.component.html 的內容後，可以在畫面中看到，Angular 把我們夾在 `<app-zippy-basic>` 的內容放到 `<ng-content>` 的位置了，\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png)\n\n當然可能有人會問了，那...我直接把 `<p>` 放在 zippy-basic.component.html 不就好了嗎？\n\n```html\n<!-- zippy basic.component.html -->\n<h2>Single-slot content projection</h2>\n<div>\n    ng-content content: \n    <p>From app.component.html projection content to zippy-basic component</p>\n</div>\n```\n\n沒有錯，但是其實 ng-content 通常不是讓你放 html tag 的，我們來舉個例子，想像一下一個場景，當你在開發專案時，有沒有遇到在一個地方需要放置三種不同類型的 button ? 如果是這樣的話你是不是會這麼做\n\n```html\n<div>\n\t<!-- style1 button -->\n\t<label>This is style 1 button</label>\n\t<p>Hello world</p>\n\t<button>button</button>\n<div>\n<div>\n\t<!-- style2 button -->\n\t<label> This is style 2 button </label>\n\t<p>Hello world</p>\n\t<button>button</button>\n<div>\n<div>\n\t<!-- style3 button -->\n\t<label> This is style 3 button </label>\n\t<p>Hello world</p>\n\t<button>button</button>\n<div>\n```\n\n有沒有發現當使用上面這種 HTML 結構雖然可以達到我們要的目的，但是 `<label>`、`<p>`、`<button>` 一直在重複出現但內容卻是一樣的，就違背了 DRY 的原則了，這時候我們就可以使用 ng-content 先將模板做好，再把不同 style 的 `<button>` 投影進去就好，來舉個例子吧：\n\n1. 首先我們先建立一個模板 Component\n\n    ```bash\n    ng generate component content-template\n    ng g c content-template\n    ```\n2. 接著我們在 content-template.component.html 中把我們的模板寫好\n\n    ```html\n    <!-- content-template.component.html -->\n\n    <h1>Content projection number {{styleCount}}</h1>\n    <label>This is style {{styleCount}} button</label>\n    <p>Hello world</p>\n    <ng-content></ng-content>\n    ```\n\n    我們在原本放置不同 style 的地方使用 <ng-content> 變成將別的內容投影到這個位置上，對了還記得昨天提到的 @Input( ) 嗎？ 這邊我們來複習一下，`使用 ng-content 一樣可以由父層傳遞數據到子層喔`。\n\n    ```typescript\n    import { Component, Input } from '@angular/core';\n\n    @Component({\n      selector: 'app-content-template',\n      templateUrl: './content-template.component.html',\n    })\n    export class ContentTemplateComponent {\n      @Input() styleCount: string = '';\n      constructor() { }\n    }\n    ```\n3. 接著我們來更改一下 app.component.html 的內容，讓不同 style 的 button 投影到 content-template 吧\n\n    ```html\n    <!-- app.component.html -->\n    <app-content-template [styleCount]=\"'1'\">\n        <button class=\"style1\">Click Me</button>\n    </app-content-template>\n\n    <app-content-template [styleCount]=\"'2'\">\n        <button class=\"style2\">Click Me</button>\n    </app-content-template>\n\n    <app-content-template [styleCount]=\"'3'\">\n        <button class=\"style3\">Click Me</button>\n    </app-content-template>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png)\n\n這樣就完成了我們的目的，簡單的幾行就可以達到相同的目的，透過`先建立模板再將不同樣式或不同的 Component 投影進這個模板 Component 之中`，就可以讓這個模板 Component 在各個地方都被使用並且達到減少重複程式碼的目的。\n\n\n# Multi-slot content projection\n第二種其實與第一種非常相似，只不過變成了一個 Component 中投影了多個不同的內容，不過值得注意的是，由於是多個不同的內容投影在一個 Component 之中，所以就會有順序位置問題，於是 Angular 提供了 `select` 屬性讓你加在 ng-content 上，讓你可以`將某一個內容放在指定的位置上`，一樣舉個例子吧。\n\n1. 首先一樣創建一個新的 Component\n\n    ```bash\n    ng generate component zippy-basic\n    ng g c zippy-basic\n    ```\n2. 接著我們在 zippy-basic.component.html 中添加 ng-content 到想要的位置\n\n    ```html\n    <!-- zippy-basic.component.html -->\n\n    <h2>Multi-slot content projection</h2>\n    Default:\n    <ng-content></ng-content>\n    Question:\n    <ng-content></ng-content>\n    ```\n3. 接著我們把想要的位置添加一個 select 屬性，讓投影的位置固定在我們想要的地方\n\n    ```html\n    <!-- zippy-basic.component.html -->\n\n    <h2>Multi-slot content projection</h2>\n    Default:\n    <ng-content></ng-content>\n    Question:\n    <ng-content select=\"[question]\"></ng-content>\n    ```\n4. 最後我們在 app.component.html  中將我們像要投影的內容放進去，記得！指定位置的內容需要加上 select 的內容喔\n\n    ```html\n    <!-- app.component.html -->\n\n    <app-zippy-basic>\n      <p question>Is content projection cool?</p>\n      <p>Let's learn about content projection!</p>\n    </app-zippy-basic>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png](https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png)\n\n可以看到我們在 app.component.html 中 <p> 的順序與 UI 呈現的順序是顛倒的，就因為我們指定了有 question 這個 select  放置的地方。\n\n與 Single-slot content projection 一樣，Multi-slot content projection 的目的不在於放入原生 HTML 的 Tag，目的與上一個一樣，都是可以先建立一個模板之後將不同的內容投影到這個模板中，只不過多了`可以透過 select 讓你選擇放置的位置`與讓你`可以放多個投影`，這邊就不在做一次練習了，有興趣的話可以自己挑戰一下利用 Multi-slot content projection 完成與上面的例子一樣的內容。\n\n\n\n# 結論\n\n在本章中介紹了什麼是 content projection 以及該如何使用它，在官方文檔中其實除了 Single-slot content projection 與 Multi-slot content projection 之外其實還有第三個常見的投影 `Conditional content projection`，但是因為他牽扯的概念跟本篇章使用 ng-content 比較不一樣，他是透過使用 `ng-template` 來做到這個功能，所以就先不將它納入本章的範圍，這個方法會在之後介紹到。\n\n下一篇將會分享 template 是什麼，他在 Angular 中是 HTML 的角色，而可以在 template 中使用許多語法來達到靈活建立畫面的功能，那我們就下一篇再見吧。\n\n\n# Referece\n- [Angular.io - content-projection](https://angular.io/guide/content-projection)\n","slug":"Angular/angular-07","published":1,"updated":"2022-02-15T08:11:41.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznurmnm000ekww3ehqsfmtv","content":"<p>本章節將要介紹如何使用 ng-content 將一個 Component 的內容投影到另一個 Component 中，創建靈活且可被重複使用的 Component，來滿足程式設計中 DRY (Don’t repeat yourself) 的觀念。</p>\n<p>在 Angular 中 Content 是一種呈現的模式，可以在其中插入或投影另一個 Component 的內容，簡單來說，當我們在寫 HTML 時常常會有這樣的結構：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> Hello World!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 Angular 的概念中可以把它想像成，有一個 <code>&lt;p&gt;</code> tag 被投影到 <code>&lt;div&gt;</code> 之中，雖然不是原理可能不這樣子，但是類似的模式。</p>\n<p>在 Angular 中有幾種常見的 ng-content 例子：</p>\n<ul>\n<li><strong>Signle-slot content projection</strong>: 投影來自單一 Source 的 Component 內容</li>\n<li><strong>Multi-slot content projection</strong>: 一個 Component 接收來自多個 Source 的 Component 內容</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Single-slot-content-projection\"><a href=\"#Single-slot-content-projection\" class=\"headerlink\" title=\"Single-slot content projection\"></a>Single-slot content projection</h1><p>在 Angular 的 ng-content 中最基本的就是 single-slot content projection，他是指<code>將一個 Component 的內容投影在另一個 Component 之中</code>，我們做一個簡單的小例子來解釋這個行為。</p>\n<ol>\n<li><p>首先我們先使用 Angular CLI 建立一個 Component</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component zippy-basic</span><br><span class=\"line\">ng g c zippy-basic</span><br></pre></td></tr></table></figure></li>\n<li><p>在 zippy-basic.component.html 中添加 ng-content 到你希望投影內容出現的位置</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy basic.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Single-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    ng-content content: </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接著我們在 app.component.html 中使用 zippy-basic 的 selector</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-zippy-basic</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png\"></p>\n<p>在畫面中我們看到，我們使用 ng-content 的位置什麼都沒有，是出了什麼 bug 嗎？其實不是!，是因為我們還沒決定該把什麼內容投影在 <ng-content> 的位置上，我們來更改一下 app.component.html 的內容</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>From app.component.html projection content to zippy-basic component<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png\"></p>\n<p>當更改玩 app.component.html 的內容後，可以在畫面中看到，Angular 把我們夾在 <code>&lt;app-zippy-basic&gt;</code> 的內容放到 <code>&lt;ng-content&gt;</code> 的位置了，<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png\"></p>\n<p>當然可能有人會問了，那…我直接把 <code>&lt;p&gt;</code> 放在 zippy-basic.component.html 不就好了嗎？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy basic.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Single-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    ng-content content: </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>From app.component.html projection content to zippy-basic component<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>沒有錯，但是其實 ng-content 通常不是讓你放 html tag 的，我們來舉個例子，想像一下一個場景，當你在開發專案時，有沒有遇到在一個地方需要放置三種不同類型的 button ? 如果是這樣的話你是不是會這麼做</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- style1 button --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>This is style 1 button<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- style2 button --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span> This is style 2 button <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- style3 button --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span> This is style 3 button <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>有沒有發現當使用上面這種 HTML 結構雖然可以達到我們要的目的，但是 <code>&lt;label&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;button&gt;</code> 一直在重複出現但內容卻是一樣的，就違背了 DRY 的原則了，這時候我們就可以使用 ng-content 先將模板做好，再把不同 style 的 <code>&lt;button&gt;</code> 投影進去就好，來舉個例子吧：</p>\n<ol>\n<li><p>首先我們先建立一個模板 Component</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component content-template</span><br><span class=\"line\">ng g c content-template</span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們在 content-template.component.html 中把我們的模板寫好</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- content-template.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Content projection number &#123;&#123;styleCount&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>This is style &#123;&#123;styleCount&#125;&#125; button<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> 我們在原本放置不同 style 的地方使用 <ng-content> 變成將別的內容投影到這個位置上，對了還記得昨天提到的 @Input( ) 嗎？ 這邊我們來複習一下，<code>使用 ng-content 一樣可以由父層傳遞數據到子層喔</code>。</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-content-template&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./content-template.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ContentTemplateComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() <span class=\"attr\">styleCount</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們來更改一下 app.component.html 的內容，讓不同 style 的 button 投影到 content-template 吧</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-content-template</span> [<span class=\"attr\">styleCount</span>]=<span class=\"string\">&quot;&#x27;1&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style1&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-content-template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-content-template</span> [<span class=\"attr\">styleCount</span>]=<span class=\"string\">&quot;&#x27;2&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style2&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-content-template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-content-template</span> [<span class=\"attr\">styleCount</span>]=<span class=\"string\">&quot;&#x27;3&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style3&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-content-template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png\"></p>\n<p>這樣就完成了我們的目的，簡單的幾行就可以達到相同的目的，透過<code>先建立模板再將不同樣式或不同的 Component 投影進這個模板 Component 之中</code>，就可以讓這個模板 Component 在各個地方都被使用並且達到減少重複程式碼的目的。</p>\n<h1 id=\"Multi-slot-content-projection\"><a href=\"#Multi-slot-content-projection\" class=\"headerlink\" title=\"Multi-slot content projection\"></a>Multi-slot content projection</h1><p>第二種其實與第一種非常相似，只不過變成了一個 Component 中投影了多個不同的內容，不過值得注意的是，由於是多個不同的內容投影在一個 Component 之中，所以就會有順序位置問題，於是 Angular 提供了 <code>select</code> 屬性讓你加在 ng-content 上，讓你可以<code>將某一個內容放在指定的位置上</code>，一樣舉個例子吧。</p>\n<ol>\n<li><p>首先一樣創建一個新的 Component</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component zippy-basic</span><br><span class=\"line\">ng g c zippy-basic</span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們在 zippy-basic.component.html 中添加 ng-content 到想要的位置</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy-basic.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Multi-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">Default:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\">Question:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們把想要的位置添加一個 select 屬性，讓投影的位置固定在我們想要的地方</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy-basic.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Multi-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">Default:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\">Question:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span> <span class=\"attr\">select</span>=<span class=\"string\">&quot;[question]&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>最後我們在 app.component.html  中將我們像要投影的內容放進去，記得！指定位置的內容需要加上 select 的內容喔</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">question</span>&gt;</span>Is content projection cool?<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Let&#x27;s learn about content projection!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png\"></p>\n<p>可以看到我們在 app.component.html 中 <p> 的順序與 UI 呈現的順序是顛倒的，就因為我們指定了有 question 這個 select  放置的地方。</p>\n<p>與 Single-slot content projection 一樣，Multi-slot content projection 的目的不在於放入原生 HTML 的 Tag，目的與上一個一樣，都是可以先建立一個模板之後將不同的內容投影到這個模板中，只不過多了<code>可以透過 select 讓你選擇放置的位置</code>與讓你<code>可以放多個投影</code>，這邊就不在做一次練習了，有興趣的話可以自己挑戰一下利用 Multi-slot content projection 完成與上面的例子一樣的內容。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本章中介紹了什麼是 content projection 以及該如何使用它，在官方文檔中其實除了 Single-slot content projection 與 Multi-slot content projection 之外其實還有第三個常見的投影 <code>Conditional content projection</code>，但是因為他牽扯的概念跟本篇章使用 ng-content 比較不一樣，他是透過使用 <code>ng-template</code> 來做到這個功能，所以就先不將它納入本章的範圍，這個方法會在之後介紹到。</p>\n<p>下一篇將會分享 template 是什麼，他在 Angular 中是 HTML 的角色，而可以在 template 中使用許多語法來達到靈活建立畫面的功能，那我們就下一篇再見吧。</p>\n<h1 id=\"Referece\"><a href=\"#Referece\" class=\"headerlink\" title=\"Referece\"></a>Referece</h1><ul>\n<li><a href=\"https://angular.io/guide/content-projection\">Angular.io - content-projection</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本章節將要介紹如何使用 ng-content 將一個 Component 的內容投影到另一個 Component 中，創建靈活且可被重複使用的 Component，來滿足程式設計中 DRY (Don’t repeat yourself) 的觀念。</p>\n<p>在 Angular 中 Content 是一種呈現的模式，可以在其中插入或投影另一個 Component 的內容，簡單來說，當我們在寫 HTML 時常常會有這樣的結構：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> Hello World!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 Angular 的概念中可以把它想像成，有一個 <code>&lt;p&gt;</code> tag 被投影到 <code>&lt;div&gt;</code> 之中，雖然不是原理可能不這樣子，但是類似的模式。</p>\n<p>在 Angular 中有幾種常見的 ng-content 例子：</p>\n<ul>\n<li><strong>Signle-slot content projection</strong>: 投影來自單一 Source 的 Component 內容</li>\n<li><strong>Multi-slot content projection</strong>: 一個 Component 接收來自多個 Source 的 Component 內容</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767Bs01NpTA05.jpg\"></p>","more":"<h1 id=\"Single-slot-content-projection\"><a href=\"#Single-slot-content-projection\" class=\"headerlink\" title=\"Single-slot content projection\"></a>Single-slot content projection</h1><p>在 Angular 的 ng-content 中最基本的就是 single-slot content projection，他是指<code>將一個 Component 的內容投影在另一個 Component 之中</code>，我們做一個簡單的小例子來解釋這個行為。</p>\n<ol>\n<li><p>首先我們先使用 Angular CLI 建立一個 Component</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component zippy-basic</span><br><span class=\"line\">ng g c zippy-basic</span><br></pre></td></tr></table></figure></li>\n<li><p>在 zippy-basic.component.html 中添加 ng-content 到你希望投影內容出現的位置</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy basic.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Single-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    ng-content content: </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接著我們在 app.component.html 中使用 zippy-basic 的 selector</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-zippy-basic</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767DnHr1yIlhY.png\"></p>\n<p>在畫面中我們看到，我們使用 ng-content 的位置什麼都沒有，是出了什麼 bug 嗎？其實不是!，是因為我們還沒決定該把什麼內容投影在 <ng-content> 的位置上，我們來更改一下 app.component.html 的內容</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>From app.component.html projection content to zippy-basic component<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767EQg91a8KNp.png\"></p>\n<p>當更改玩 app.component.html 的內容後，可以在畫面中看到，Angular 把我們夾在 <code>&lt;app-zippy-basic&gt;</code> 的內容放到 <code>&lt;ng-content&gt;</code> 的位置了，<br><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767bUsgQrsaND.png\"></p>\n<p>當然可能有人會問了，那…我直接把 <code>&lt;p&gt;</code> 放在 zippy-basic.component.html 不就好了嗎？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy basic.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Single-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    ng-content content: </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>From app.component.html projection content to zippy-basic component<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>沒有錯，但是其實 ng-content 通常不是讓你放 html tag 的，我們來舉個例子，想像一下一個場景，當你在開發專案時，有沒有遇到在一個地方需要放置三種不同類型的 button ? 如果是這樣的話你是不是會這麼做</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- style1 button --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>This is style 1 button<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- style2 button --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span> This is style 2 button <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- style3 button --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span> This is style 3 button <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>button<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>有沒有發現當使用上面這種 HTML 結構雖然可以達到我們要的目的，但是 <code>&lt;label&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;button&gt;</code> 一直在重複出現但內容卻是一樣的，就違背了 DRY 的原則了，這時候我們就可以使用 ng-content 先將模板做好，再把不同 style 的 <code>&lt;button&gt;</code> 投影進去就好，來舉個例子吧：</p>\n<ol>\n<li><p>首先我們先建立一個模板 Component</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component content-template</span><br><span class=\"line\">ng g c content-template</span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們在 content-template.component.html 中把我們的模板寫好</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- content-template.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Content projection number &#123;&#123;styleCount&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>This is style &#123;&#123;styleCount&#125;&#125; button<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> 我們在原本放置不同 style 的地方使用 <ng-content> 變成將別的內容投影到這個位置上，對了還記得昨天提到的 @Input( ) 嗎？ 這邊我們來複習一下，<code>使用 ng-content 一樣可以由父層傳遞數據到子層喔</code>。</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-content-template&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./content-template.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ContentTemplateComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() <span class=\"attr\">styleCount</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們來更改一下 app.component.html 的內容，讓不同 style 的 button 投影到 content-template 吧</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-content-template</span> [<span class=\"attr\">styleCount</span>]=<span class=\"string\">&quot;&#x27;1&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style1&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-content-template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-content-template</span> [<span class=\"attr\">styleCount</span>]=<span class=\"string\">&quot;&#x27;2&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style2&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-content-template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-content-template</span> [<span class=\"attr\">styleCount</span>]=<span class=\"string\">&quot;&#x27;3&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style3&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-content-template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767W7aNxciNY5.png\"></p>\n<p>這樣就完成了我們的目的，簡單的幾行就可以達到相同的目的，透過<code>先建立模板再將不同樣式或不同的 Component 投影進這個模板 Component 之中</code>，就可以讓這個模板 Component 在各個地方都被使用並且達到減少重複程式碼的目的。</p>\n<h1 id=\"Multi-slot-content-projection\"><a href=\"#Multi-slot-content-projection\" class=\"headerlink\" title=\"Multi-slot content projection\"></a>Multi-slot content projection</h1><p>第二種其實與第一種非常相似，只不過變成了一個 Component 中投影了多個不同的內容，不過值得注意的是，由於是多個不同的內容投影在一個 Component 之中，所以就會有順序位置問題，於是 Angular 提供了 <code>select</code> 屬性讓你加在 ng-content 上，讓你可以<code>將某一個內容放在指定的位置上</code>，一樣舉個例子吧。</p>\n<ol>\n<li><p>首先一樣創建一個新的 Component</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate component zippy-basic</span><br><span class=\"line\">ng g c zippy-basic</span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們在 zippy-basic.component.html 中添加 ng-content 到想要的位置</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy-basic.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Multi-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">Default:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\">Question:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>接著我們把想要的位置添加一個 select 屬性，讓投影的位置固定在我們想要的地方</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- zippy-basic.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Multi-slot content projection<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">Default:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\">Question:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span> <span class=\"attr\">select</span>=<span class=\"string\">&quot;[question]&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>最後我們在 app.component.html  中將我們像要投影的內容放進去，記得！指定位置的內容需要加上 select 的內容喔</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">question</span>&gt;</span>Is content projection cool?<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Let&#x27;s learn about content projection!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-zippy-basic</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210801/20124767IFrm7OvyYX.png\"></p>\n<p>可以看到我們在 app.component.html 中 <p> 的順序與 UI 呈現的順序是顛倒的，就因為我們指定了有 question 這個 select  放置的地方。</p>\n<p>與 Single-slot content projection 一樣，Multi-slot content projection 的目的不在於放入原生 HTML 的 Tag，目的與上一個一樣，都是可以先建立一個模板之後將不同的內容投影到這個模板中，只不過多了<code>可以透過 select 讓你選擇放置的位置</code>與讓你<code>可以放多個投影</code>，這邊就不在做一次練習了，有興趣的話可以自己挑戰一下利用 Multi-slot content projection 完成與上面的例子一樣的內容。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本章中介紹了什麼是 content projection 以及該如何使用它，在官方文檔中其實除了 Single-slot content projection 與 Multi-slot content projection 之外其實還有第三個常見的投影 <code>Conditional content projection</code>，但是因為他牽扯的概念跟本篇章使用 ng-content 比較不一樣，他是透過使用 <code>ng-template</code> 來做到這個功能，所以就先不將它納入本章的範圍，這個方法會在之後介紹到。</p>\n<p>下一篇將會分享 template 是什麼，他在 Angular 中是 HTML 的角色，而可以在 template 中使用許多語法來達到靈活建立畫面的功能，那我們就下一篇再見吧。</p>\n<h1 id=\"Referece\"><a href=\"#Referece\" class=\"headerlink\" title=\"Referece\"></a>Referece</h1><ul>\n<li><a href=\"https://angular.io/guide/content-projection\">Angular.io - content-projection</a></li>\n</ul>"},{"title":"Day8. Templates and Text interpolation","date":"2022-02-15T08:14:32.000Z","_content":"\n前幾天大概講完了 Angular 的 Component 的基本功能與介紹，在很多例子中可以看到在 component.html 中使用了滿多沒看過的語法，比如 `{{ value }}` 或 `(clicl)=\"onClick()\"` 等等的，在前幾天可能會對他覺得非常陌生，別擔心接下來我們會對這些語法有詳細的說明。\n\n在 Angular 中，Templates 是一段 HTML，可以在 Templates 中使用特殊的語法來構建 Angular app 的畫面，那就讓我們繼續往下看吧。\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png](https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png)\n\n<!-- more -->\n\n\n# Empower your HTML\n在我們開發 Angular app 時，可以在 Templates 使用特殊的語法來擴展 HTML 的詞彙表，舉例來說可以在 Angular 通過內置模板函數、變量、event  和數據綁定，可以幫助你在開發過程中動態的獲得和設置 DOM 的值。\n\n雖然說 Angular 的 Template 是一段 HTML，但是所有的 templates 都只是整個網頁的一部分，而不是整個頁面，所以不需要在每一個 templates 中添加 `<html>`、`<body>` 或 `<base>` 之類的元素，而出於安全考量 Angular 也不允許在 templates 中加入 `<script>` 。\n\n\n\n# Text interpolation\n介紹完什麼是 Templates 後接著要來介紹一些 templates 的語法，首先我們要介紹的是 Text interpolation，顧名思義就是將 component.ts 中的變量插入到 templates 中，`當這個變量在 component.ts 中發生變化時，也會同步在 template 中發生變化`，意味著畫面也會跟著變化。\n\n在默認情況下，插值是使用雙花括號 `{{` 和 `}}` 將插值夾在其中，來舉個簡單的例子：\n1. 首先先在 app.component.ts 中添加一個變量\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      currentCustomer = 'Fandix'\n    }\n    ```\n2. 在 app.component.html 中將這個值插入到 template 中\n\n    ```typescript\n    <!-- app.component.html -->\n\n    <h3>Current customer: {{ currentCustomer }}</h3>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png)\n\n在畫面可以看到確實有將 component.ts 當中的變量（currentCustomer）的內容呈現出來，那我們將變量的值更改一下\n\n```typescript\ncurrentCustomer = 'Tako'\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png)\n當 component.ts 中的變量內容改變後會動態的顯示在畫面中，這就是 Text interpolation 的用途。\n\n\n# Template expressions\n可以在 template expressions 在雙花括號中`{{ }}`產生一個值，Angular 會自動解析表達式並將解析過後的內容分配給綁定目標的屬性，這個目標可以是 HTML Tag、Component selector 或 directive。\n\n## Resolving expressions with interpolation\n\n一般來說在雙花括號之間填入一個模板表達式的話，Angular 會先將他做計算，得到結果後將它轉成字串並顯示出來，舉個簡單的例子，透過差值將兩個數字相加並呈現出來：\n\n```html\n<!-- app.component.html -->\n\n<h3>The sum of 1 + 1 is {{1 + 1}}</h3>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png)\n\nAngular 在 templates 的雙花括號中收到了一個表達式，他會自動將這個表達式做計算，像上面的例子中的 `1 + 1`，得到結果後將它轉成字串並顯示出來，所以畫面中會顯示 1 + 1 = 2。\n\n而表達式也可以調用這個 component.ts 中的 method，比如說：\n\n1. 在  app.component.ts 中新增一個 method\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      getValue() {\n        return 'Fandix';\n      }\n    }\n    ```\n2. 在 app.component.html 中將調用 method 的表達式填入到雙花括號中\n\n    ```html\n    <!-- app.component.html -->\n\n    <h3>Hello {{ getValue() }}</h3>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png)\n\n可以看到 Angular 在 template 調用了 component.ts 中的 method ，獲得到的值將他呈現在畫面中，而 Angular 在遇到差值時會執行以下的任務：\n1. 計算雙花括號中的所有表達式\n2. 將表達式的結果轉換為字串\n3. 將結果鏈接到任何相鄰的文字字串\n4. 將組合分配給element 或 directive 屬性\n\n## Syntas\n\n一樣的，要運用一個新的程式語言之前，需要先充分熟悉他的語法，不然會產生意料之外的錯誤喔，其實 templates expressions 的語法基本上都跟 Javascript expressions 一樣，但是有幾個特例：\n\n- 你不能使用有會產生 side effects 的 javascript expressions\n    - 賦值（=, +=, -=, ...）\n    - 運算符（new, typeof, instanceof）\n    - 用分號（;）鏈結 expressions\n    - 遞增或遞減運算符（++,  --）\n    - 還有一些 ES6 的運算符\n- 與 javascript 語法有明顯差異的：\n    - 不支援 bit 的運算符（|,  &）\n    - 新的 template expressions（|,  ?,  !, ...）\n\n\n\n# Preventing name collisions\n\n介紹完如何將 component 中的變量插入 template 讓畫面隨著變量動態改變後，要注意的是在使用這個功能時要防止名稱衝突，因為當你使用了 Text interpolationt 插入變量後， Angular 對這個表達式的計算 context 是從 `template variable`、`directive` 和 `component member` 的聯合，所以當你插入了一個名稱到 template 但這個名稱在多個地方都有定義的話， Angular 會用以下的邏輯來確定 context：\n\n1. 在 template 中的變量名稱 (ngFor 中的變量)\n2. 在 directive 中的 context 名稱\n3. Component 中的變量名稱\n\n所以當你在使用 Text interpolationt  時盡量保持所有變量名稱唯一，不然可能會被 shadowing 掉你原本想要呈現內容，我們舉個例子：\n\n這邊先提早介紹 *ngFor，他也是使用在 template 當中，用法與 javascript 的 for loop 一樣，當你的 component 中的變量是一個 arr 時，想要把這個 arr 中的數值都呈現在畫面上就可以使用這個方法，一樣舉個簡單的例子吧：\n\n1. 首先先在 app.component.ts 中宣告一個 arr 變數並將裡面填上要呈現的內容。\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      displayArray = ['Hello', 'world', 'Angular', 'good'];\n    }\n    ```\n\n2. 接著在 app.component.html 中使用 *ngFor 將他們全部呈現在畫面上\n\n    ```html\n    <!-- app.component.html -->\n\n    <div *ngFor=\"let content of displayArray\">\n        {{content}}\n    </div>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png)\n\n在畫面中可以看到透過 *ngFor 不斷的遞迴將 displayArray 中的內容都顯示出來，這邊暫時介紹到這邊，之後會更詳細的介紹他的使用方法。\n\n大概了解的 *ngFor 的使用方法後，將畫面回到命名衝突，當你使用 *ngFor 命名迭代出來的每一個值得名稱時要注意這個名稱有沒有在其他地方被引用到，如果有則會將其他相同名稱的內容 shadowing 掉，舉個小例子吧。\n\n1. 先在 app.component.ts 中定義兩個變量\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      customers = [ 'Ebony', 'Chiho'];\n      customer = 'Padma';\n    }\n    ```\n\n2. 在 app.component.html 中將這兩個變量呈現在畫面中\n\n    ```html\n    <!-- app.component.html -->\n\n    <div>\n      <ul>\n        <li *ngFor=\"let customer of customers\">\n    \t\t\t<h1>Hello, {{ customer }}</h1>\n    \t\t\t{{ customer }}\n    \t\t</li>\n      </ul>\n    </div>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png)\n在畫面中可以看到，原本我們希望在每次迭代 customers 中的值時，都將 customer = 'Padma' 添加在上面，但是由於 *ngFor 中的變量 shadowing 了 customer 所以導致 'Padma' 無法呈現出來，所以在使用 Text interpolationt 插入變量時要注意有沒有相同的名稱喔！\n\n\n\n# 結論\n\n本篇中介紹了如何在 template 中插入 component 的變量以及該注意的事情，最後介紹幾個在使用 Text interpolationt 時最好的設計規範以避免發生錯誤或是增加程式的可閱讀性：\n\n- **使用簡短的表達**：盡可能使用 component 中 property 的名稱或 method 調用。將應用程序和業務邏輯保留在 component 中而 template 只負責調用就可以，這樣以便進行開發和測試。\n- **快速執行**：Angular 會在在每個變更檢測週期後執行模板表達式，許多非同步的行為都會觸發變更檢測週期，比如 Promise、HTTP 的結果、timer events、按鍵與滑鼠的移動等等，expression 應該快速的完成不然會讓使用者體驗下降，所以當需要進行長時間計算的事情時，請考慮使用緩存值。\n- **沒有明顯的 side effect**：模板表達式不應該更改除了目標屬性值之外的任何應用程序狀態，讀取 component 的值時不應更改到其他的顯示值。\n\n\n\n# Reference\n\n- [Angular.io - interpolation](https://angular.io/guide/interpolation)","source":"_posts/Angular/angular-08.md","raw":"---\ntitle: Day8. Templates and Text interpolation\ndate: 2022-02-15 16:14:32\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n前幾天大概講完了 Angular 的 Component 的基本功能與介紹，在很多例子中可以看到在 component.html 中使用了滿多沒看過的語法，比如 `{{ value }}` 或 `(clicl)=\"onClick()\"` 等等的，在前幾天可能會對他覺得非常陌生，別擔心接下來我們會對這些語法有詳細的說明。\n\n在 Angular 中，Templates 是一段 HTML，可以在 Templates 中使用特殊的語法來構建 Angular app 的畫面，那就讓我們繼續往下看吧。\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png](https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png)\n\n<!-- more -->\n\n\n# Empower your HTML\n在我們開發 Angular app 時，可以在 Templates 使用特殊的語法來擴展 HTML 的詞彙表，舉例來說可以在 Angular 通過內置模板函數、變量、event  和數據綁定，可以幫助你在開發過程中動態的獲得和設置 DOM 的值。\n\n雖然說 Angular 的 Template 是一段 HTML，但是所有的 templates 都只是整個網頁的一部分，而不是整個頁面，所以不需要在每一個 templates 中添加 `<html>`、`<body>` 或 `<base>` 之類的元素，而出於安全考量 Angular 也不允許在 templates 中加入 `<script>` 。\n\n\n\n# Text interpolation\n介紹完什麼是 Templates 後接著要來介紹一些 templates 的語法，首先我們要介紹的是 Text interpolation，顧名思義就是將 component.ts 中的變量插入到 templates 中，`當這個變量在 component.ts 中發生變化時，也會同步在 template 中發生變化`，意味著畫面也會跟著變化。\n\n在默認情況下，插值是使用雙花括號 `{{` 和 `}}` 將插值夾在其中，來舉個簡單的例子：\n1. 首先先在 app.component.ts 中添加一個變量\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      currentCustomer = 'Fandix'\n    }\n    ```\n2. 在 app.component.html 中將這個值插入到 template 中\n\n    ```typescript\n    <!-- app.component.html -->\n\n    <h3>Current customer: {{ currentCustomer }}</h3>\n    ```\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png)\n\n在畫面可以看到確實有將 component.ts 當中的變量（currentCustomer）的內容呈現出來，那我們將變量的值更改一下\n\n```typescript\ncurrentCustomer = 'Tako'\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png)\n當 component.ts 中的變量內容改變後會動態的顯示在畫面中，這就是 Text interpolation 的用途。\n\n\n# Template expressions\n可以在 template expressions 在雙花括號中`{{ }}`產生一個值，Angular 會自動解析表達式並將解析過後的內容分配給綁定目標的屬性，這個目標可以是 HTML Tag、Component selector 或 directive。\n\n## Resolving expressions with interpolation\n\n一般來說在雙花括號之間填入一個模板表達式的話，Angular 會先將他做計算，得到結果後將它轉成字串並顯示出來，舉個簡單的例子，透過差值將兩個數字相加並呈現出來：\n\n```html\n<!-- app.component.html -->\n\n<h3>The sum of 1 + 1 is {{1 + 1}}</h3>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png)\n\nAngular 在 templates 的雙花括號中收到了一個表達式，他會自動將這個表達式做計算，像上面的例子中的 `1 + 1`，得到結果後將它轉成字串並顯示出來，所以畫面中會顯示 1 + 1 = 2。\n\n而表達式也可以調用這個 component.ts 中的 method，比如說：\n\n1. 在  app.component.ts 中新增一個 method\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      getValue() {\n        return 'Fandix';\n      }\n    }\n    ```\n2. 在 app.component.html 中將調用 method 的表達式填入到雙花括號中\n\n    ```html\n    <!-- app.component.html -->\n\n    <h3>Hello {{ getValue() }}</h3>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png)\n\n可以看到 Angular 在 template 調用了 component.ts 中的 method ，獲得到的值將他呈現在畫面中，而 Angular 在遇到差值時會執行以下的任務：\n1. 計算雙花括號中的所有表達式\n2. 將表達式的結果轉換為字串\n3. 將結果鏈接到任何相鄰的文字字串\n4. 將組合分配給element 或 directive 屬性\n\n## Syntas\n\n一樣的，要運用一個新的程式語言之前，需要先充分熟悉他的語法，不然會產生意料之外的錯誤喔，其實 templates expressions 的語法基本上都跟 Javascript expressions 一樣，但是有幾個特例：\n\n- 你不能使用有會產生 side effects 的 javascript expressions\n    - 賦值（=, +=, -=, ...）\n    - 運算符（new, typeof, instanceof）\n    - 用分號（;）鏈結 expressions\n    - 遞增或遞減運算符（++,  --）\n    - 還有一些 ES6 的運算符\n- 與 javascript 語法有明顯差異的：\n    - 不支援 bit 的運算符（|,  &）\n    - 新的 template expressions（|,  ?,  !, ...）\n\n\n\n# Preventing name collisions\n\n介紹完如何將 component 中的變量插入 template 讓畫面隨著變量動態改變後，要注意的是在使用這個功能時要防止名稱衝突，因為當你使用了 Text interpolationt 插入變量後， Angular 對這個表達式的計算 context 是從 `template variable`、`directive` 和 `component member` 的聯合，所以當你插入了一個名稱到 template 但這個名稱在多個地方都有定義的話， Angular 會用以下的邏輯來確定 context：\n\n1. 在 template 中的變量名稱 (ngFor 中的變量)\n2. 在 directive 中的 context 名稱\n3. Component 中的變量名稱\n\n所以當你在使用 Text interpolationt  時盡量保持所有變量名稱唯一，不然可能會被 shadowing 掉你原本想要呈現內容，我們舉個例子：\n\n這邊先提早介紹 *ngFor，他也是使用在 template 當中，用法與 javascript 的 for loop 一樣，當你的 component 中的變量是一個 arr 時，想要把這個 arr 中的數值都呈現在畫面上就可以使用這個方法，一樣舉個簡單的例子吧：\n\n1. 首先先在 app.component.ts 中宣告一個 arr 變數並將裡面填上要呈現的內容。\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      displayArray = ['Hello', 'world', 'Angular', 'good'];\n    }\n    ```\n\n2. 接著在 app.component.html 中使用 *ngFor 將他們全部呈現在畫面上\n\n    ```html\n    <!-- app.component.html -->\n\n    <div *ngFor=\"let content of displayArray\">\n        {{content}}\n    </div>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png)\n\n在畫面中可以看到透過 *ngFor 不斷的遞迴將 displayArray 中的內容都顯示出來，這邊暫時介紹到這邊，之後會更詳細的介紹他的使用方法。\n\n大概了解的 *ngFor 的使用方法後，將畫面回到命名衝突，當你使用 *ngFor 命名迭代出來的每一個值得名稱時要注意這個名稱有沒有在其他地方被引用到，如果有則會將其他相同名稱的內容 shadowing 掉，舉個小例子吧。\n\n1. 先在 app.component.ts 中定義兩個變量\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      customers = [ 'Ebony', 'Chiho'];\n      customer = 'Padma';\n    }\n    ```\n\n2. 在 app.component.html 中將這兩個變量呈現在畫面中\n\n    ```html\n    <!-- app.component.html -->\n\n    <div>\n      <ul>\n        <li *ngFor=\"let customer of customers\">\n    \t\t\t<h1>Hello, {{ customer }}</h1>\n    \t\t\t{{ customer }}\n    \t\t</li>\n      </ul>\n    </div>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png](https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png)\n在畫面中可以看到，原本我們希望在每次迭代 customers 中的值時，都將 customer = 'Padma' 添加在上面，但是由於 *ngFor 中的變量 shadowing 了 customer 所以導致 'Padma' 無法呈現出來，所以在使用 Text interpolationt 插入變量時要注意有沒有相同的名稱喔！\n\n\n\n# 結論\n\n本篇中介紹了如何在 template 中插入 component 的變量以及該注意的事情，最後介紹幾個在使用 Text interpolationt 時最好的設計規範以避免發生錯誤或是增加程式的可閱讀性：\n\n- **使用簡短的表達**：盡可能使用 component 中 property 的名稱或 method 調用。將應用程序和業務邏輯保留在 component 中而 template 只負責調用就可以，這樣以便進行開發和測試。\n- **快速執行**：Angular 會在在每個變更檢測週期後執行模板表達式，許多非同步的行為都會觸發變更檢測週期，比如 Promise、HTTP 的結果、timer events、按鍵與滑鼠的移動等等，expression 應該快速的完成不然會讓使用者體驗下降，所以當需要進行長時間計算的事情時，請考慮使用緩存值。\n- **沒有明顯的 side effect**：模板表達式不應該更改除了目標屬性值之外的任何應用程序狀態，讀取 component 的值時不應更改到其他的顯示值。\n\n\n\n# Reference\n\n- [Angular.io - interpolation](https://angular.io/guide/interpolation)","slug":"Angular/angular-08","published":1,"updated":"2022-02-15T08:19:21.450Z","_id":"ckznurmnn000jkww3et9t3tk5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前幾天大概講完了 Angular 的 Component 的基本功能與介紹，在很多例子中可以看到在 component.html 中使用了滿多沒看過的語法，比如 <code>&#123;&#123; value &#125;&#125;</code> 或 <code>(clicl)=&quot;onClick()&quot;</code> 等等的，在前幾天可能會對他覺得非常陌生，別擔心接下來我們會對這些語法有詳細的說明。</p>\n<p>在 Angular 中，Templates 是一段 HTML，可以在 Templates 中使用特殊的語法來構建 Angular app 的畫面，那就讓我們繼續往下看吧。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png\"></p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"Empower-your-HTML\"><a href=\"#Empower-your-HTML\" class=\"headerlink\" title=\"Empower your HTML\"></a>Empower your HTML</h1><p>在我們開發 Angular app 時，可以在 Templates 使用特殊的語法來擴展 HTML 的詞彙表，舉例來說可以在 Angular 通過內置模板函數、變量、event  和數據綁定，可以幫助你在開發過程中動態的獲得和設置 DOM 的值。</p>\n<p>雖然說 Angular 的 Template 是一段 HTML，但是所有的 templates 都只是整個網頁的一部分，而不是整個頁面，所以不需要在每一個 templates 中添加 <code>&lt;html&gt;</code>、<code>&lt;body&gt;</code> 或 <code>&lt;base&gt;</code> 之類的元素，而出於安全考量 Angular 也不允許在 templates 中加入 <code>&lt;script&gt;</code> 。</p>\n<h1 id=\"Text-interpolation\"><a href=\"#Text-interpolation\" class=\"headerlink\" title=\"Text interpolation\"></a>Text interpolation</h1><p>介紹完什麼是 Templates 後接著要來介紹一些 templates 的語法，首先我們要介紹的是 Text interpolation，顧名思義就是將 component.ts 中的變量插入到 templates 中，<code>當這個變量在 component.ts 中發生變化時，也會同步在 template 中發生變化</code>，意味著畫面也會跟著變化。</p>\n<p>在默認情況下，插值是使用雙花括號 <code>&#123;&#123;` 和 `&#125;&#125;</code> 將插值夾在其中，來舉個簡單的例子：</p>\n<ol>\n<li><p>首先先在 app.component.ts 中添加一個變量</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  currentCustomer = <span class=\"string\">&#x27;Fandix&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在 app.component.html 中將這個值插入到 template 中</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- app.<span class=\"property\">component</span>.<span class=\"property\">html</span> --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Current customer: &#123;&#123; currentCustomer &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png\"></p>\n<p>在畫面可以看到確實有將 component.ts 當中的變量（currentCustomer）的內容呈現出來，那我們將變量的值更改一下</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentCustomer = <span class=\"string\">&#x27;Tako&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png\"><br>當 component.ts 中的變量內容改變後會動態的顯示在畫面中，這就是 Text interpolation 的用途。</p>\n<h1 id=\"Template-expressions\"><a href=\"#Template-expressions\" class=\"headerlink\" title=\"Template expressions\"></a>Template expressions</h1><p>可以在 template expressions 在雙花括號中<code>&#123;&#123; &#125;&#125;</code>產生一個值，Angular 會自動解析表達式並將解析過後的內容分配給綁定目標的屬性，這個目標可以是 HTML Tag、Component selector 或 directive。</p>\n<h2 id=\"Resolving-expressions-with-interpolation\"><a href=\"#Resolving-expressions-with-interpolation\" class=\"headerlink\" title=\"Resolving expressions with interpolation\"></a>Resolving expressions with interpolation</h2><p>一般來說在雙花括號之間填入一個模板表達式的話，Angular 會先將他做計算，得到結果後將它轉成字串並顯示出來，舉個簡單的例子，透過差值將兩個數字相加並呈現出來：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>The sum of 1 + 1 is &#123;&#123;1 + 1&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png\"></p>\n<p>Angular 在 templates 的雙花括號中收到了一個表達式，他會自動將這個表達式做計算，像上面的例子中的 <code>1 + 1</code>，得到結果後將它轉成字串並顯示出來，所以畫面中會顯示 1 + 1 &#x3D; 2。</p>\n<p>而表達式也可以調用這個 component.ts 中的 method，比如說：</p>\n<ol>\n<li><p>在  app.component.ts 中新增一個 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getValue</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Fandix&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在 app.component.html 中將調用 method 的表達式填入到雙花括號中</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Hello &#123;&#123; getValue() &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png\"></p>\n<p>可以看到 Angular 在 template 調用了 component.ts 中的 method ，獲得到的值將他呈現在畫面中，而 Angular 在遇到差值時會執行以下的任務：</p>\n<ol>\n<li>計算雙花括號中的所有表達式</li>\n<li>將表達式的結果轉換為字串</li>\n<li>將結果鏈接到任何相鄰的文字字串</li>\n<li>將組合分配給element 或 directive 屬性</li>\n</ol>\n<h2 id=\"Syntas\"><a href=\"#Syntas\" class=\"headerlink\" title=\"Syntas\"></a>Syntas</h2><p>一樣的，要運用一個新的程式語言之前，需要先充分熟悉他的語法，不然會產生意料之外的錯誤喔，其實 templates expressions 的語法基本上都跟 Javascript expressions 一樣，但是有幾個特例：</p>\n<ul>\n<li>你不能使用有會產生 side effects 的 javascript expressions<ul>\n<li>賦值（&#x3D;, +&#x3D;, -&#x3D;, …）</li>\n<li>運算符（new, typeof, instanceof）</li>\n<li>用分號（;）鏈結 expressions</li>\n<li>遞增或遞減運算符（++,  –）</li>\n<li>還有一些 ES6 的運算符</li>\n</ul>\n</li>\n<li>與 javascript 語法有明顯差異的：<ul>\n<li>不支援 bit 的運算符（|,  &amp;）</li>\n<li>新的 template expressions（|,  ?,  !, …）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Preventing-name-collisions\"><a href=\"#Preventing-name-collisions\" class=\"headerlink\" title=\"Preventing name collisions\"></a>Preventing name collisions</h1><p>介紹完如何將 component 中的變量插入 template 讓畫面隨著變量動態改變後，要注意的是在使用這個功能時要防止名稱衝突，因為當你使用了 Text interpolationt 插入變量後， Angular 對這個表達式的計算 context 是從 <code>template variable</code>、<code>directive</code> 和 <code>component member</code> 的聯合，所以當你插入了一個名稱到 template 但這個名稱在多個地方都有定義的話， Angular 會用以下的邏輯來確定 context：</p>\n<ol>\n<li>在 template 中的變量名稱 (ngFor 中的變量)</li>\n<li>在 directive 中的 context 名稱</li>\n<li>Component 中的變量名稱</li>\n</ol>\n<p>所以當你在使用 Text interpolationt  時盡量保持所有變量名稱唯一，不然可能會被 shadowing 掉你原本想要呈現內容，我們舉個例子：</p>\n<p>這邊先提早介紹 *ngFor，他也是使用在 template 當中，用法與 javascript 的 for loop 一樣，當你的 component 中的變量是一個 arr 時，想要把這個 arr 中的數值都呈現在畫面上就可以使用這個方法，一樣舉個簡單的例子吧：</p>\n<ol>\n<li><p>首先先在 app.component.ts 中宣告一個 arr 變數並將裡面填上要呈現的內容。</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  displayArray = [<span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"string\">&#x27;world&#x27;</span>, <span class=\"string\">&#x27;Angular&#x27;</span>, <span class=\"string\">&#x27;good&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接著在 app.component.html 中使用 *ngFor 將他們全部呈現在畫面上</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let content of displayArray&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;content&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png\"></p>\n<p>在畫面中可以看到透過 *ngFor 不斷的遞迴將 displayArray 中的內容都顯示出來，這邊暫時介紹到這邊，之後會更詳細的介紹他的使用方法。</p>\n<p>大概了解的 *ngFor 的使用方法後，將畫面回到命名衝突，當你使用 *ngFor 命名迭代出來的每一個值得名稱時要注意這個名稱有沒有在其他地方被引用到，如果有則會將其他相同名稱的內容 shadowing 掉，舉個小例子吧。</p>\n<ol>\n<li><p>先在 app.component.ts 中定義兩個變量</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  customers = [ <span class=\"string\">&#x27;Ebony&#x27;</span>, <span class=\"string\">&#x27;Chiho&#x27;</span>];</span><br><span class=\"line\">  customer = <span class=\"string\">&#x27;Padma&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中將這兩個變量呈現在畫面中</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let customer of customers&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;&#123; customer &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">\t\t\t&#123;&#123; customer &#125;&#125;</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png\"><br>在畫面中可以看到，原本我們希望在每次迭代 customers 中的值時，都將 customer &#x3D; ‘Padma’ 添加在上面，但是由於 *ngFor 中的變量 shadowing 了 customer 所以導致 ‘Padma’ 無法呈現出來，所以在使用 Text interpolationt 插入變量時要注意有沒有相同的名稱喔！</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇中介紹了如何在 template 中插入 component 的變量以及該注意的事情，最後介紹幾個在使用 Text interpolationt 時最好的設計規範以避免發生錯誤或是增加程式的可閱讀性：</p>\n<ul>\n<li><strong>使用簡短的表達</strong>：盡可能使用 component 中 property 的名稱或 method 調用。將應用程序和業務邏輯保留在 component 中而 template 只負責調用就可以，這樣以便進行開發和測試。</li>\n<li><strong>快速執行</strong>：Angular 會在在每個變更檢測週期後執行模板表達式，許多非同步的行為都會觸發變更檢測週期，比如 Promise、HTTP 的結果、timer events、按鍵與滑鼠的移動等等，expression 應該快速的完成不然會讓使用者體驗下降，所以當需要進行長時間計算的事情時，請考慮使用緩存值。</li>\n<li><strong>沒有明顯的 side effect</strong>：模板表達式不應該更改除了目標屬性值之外的任何應用程序狀態，讀取 component 的值時不應更改到其他的顯示值。</li>\n</ul>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/interpolation\">Angular.io - interpolation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>前幾天大概講完了 Angular 的 Component 的基本功能與介紹，在很多例子中可以看到在 component.html 中使用了滿多沒看過的語法，比如 <code>&#123;&#123; value &#125;&#125;</code> 或 <code>(clicl)=&quot;onClick()&quot;</code> 等等的，在前幾天可能會對他覺得非常陌生，別擔心接下來我們會對這些語法有詳細的說明。</p>\n<p>在 Angular 中，Templates 是一段 HTML，可以在 Templates 中使用特殊的語法來構建 Angular app 的畫面，那就讓我們繼續往下看吧。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/201247672iUKFGyC6V.png\"></p>","more":"<h1 id=\"Empower-your-HTML\"><a href=\"#Empower-your-HTML\" class=\"headerlink\" title=\"Empower your HTML\"></a>Empower your HTML</h1><p>在我們開發 Angular app 時，可以在 Templates 使用特殊的語法來擴展 HTML 的詞彙表，舉例來說可以在 Angular 通過內置模板函數、變量、event  和數據綁定，可以幫助你在開發過程中動態的獲得和設置 DOM 的值。</p>\n<p>雖然說 Angular 的 Template 是一段 HTML，但是所有的 templates 都只是整個網頁的一部分，而不是整個頁面，所以不需要在每一個 templates 中添加 <code>&lt;html&gt;</code>、<code>&lt;body&gt;</code> 或 <code>&lt;base&gt;</code> 之類的元素，而出於安全考量 Angular 也不允許在 templates 中加入 <code>&lt;script&gt;</code> 。</p>\n<h1 id=\"Text-interpolation\"><a href=\"#Text-interpolation\" class=\"headerlink\" title=\"Text interpolation\"></a>Text interpolation</h1><p>介紹完什麼是 Templates 後接著要來介紹一些 templates 的語法，首先我們要介紹的是 Text interpolation，顧名思義就是將 component.ts 中的變量插入到 templates 中，<code>當這個變量在 component.ts 中發生變化時，也會同步在 template 中發生變化</code>，意味著畫面也會跟著變化。</p>\n<p>在默認情況下，插值是使用雙花括號 <code>&#123;&#123;` 和 `&#125;&#125;</code> 將插值夾在其中，來舉個簡單的例子：</p>\n<ol>\n<li><p>首先先在 app.component.ts 中添加一個變量</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  currentCustomer = <span class=\"string\">&#x27;Fandix&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在 app.component.html 中將這個值插入到 template 中</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- app.<span class=\"property\">component</span>.<span class=\"property\">html</span> --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Current customer: &#123;&#123; currentCustomer &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767SfgZjpfW0a.png\"></p>\n<p>在畫面可以看到確實有將 component.ts 當中的變量（currentCustomer）的內容呈現出來，那我們將變量的值更改一下</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentCustomer = <span class=\"string\">&#x27;Tako&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767zWCwZTqGtJ.png\"><br>當 component.ts 中的變量內容改變後會動態的顯示在畫面中，這就是 Text interpolation 的用途。</p>\n<h1 id=\"Template-expressions\"><a href=\"#Template-expressions\" class=\"headerlink\" title=\"Template expressions\"></a>Template expressions</h1><p>可以在 template expressions 在雙花括號中<code>&#123;&#123; &#125;&#125;</code>產生一個值，Angular 會自動解析表達式並將解析過後的內容分配給綁定目標的屬性，這個目標可以是 HTML Tag、Component selector 或 directive。</p>\n<h2 id=\"Resolving-expressions-with-interpolation\"><a href=\"#Resolving-expressions-with-interpolation\" class=\"headerlink\" title=\"Resolving expressions with interpolation\"></a>Resolving expressions with interpolation</h2><p>一般來說在雙花括號之間填入一個模板表達式的話，Angular 會先將他做計算，得到結果後將它轉成字串並顯示出來，舉個簡單的例子，透過差值將兩個數字相加並呈現出來：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>The sum of 1 + 1 is &#123;&#123;1 + 1&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767CF8r7xaM47.png\"></p>\n<p>Angular 在 templates 的雙花括號中收到了一個表達式，他會自動將這個表達式做計算，像上面的例子中的 <code>1 + 1</code>，得到結果後將它轉成字串並顯示出來，所以畫面中會顯示 1 + 1 &#x3D; 2。</p>\n<p>而表達式也可以調用這個 component.ts 中的 method，比如說：</p>\n<ol>\n<li><p>在  app.component.ts 中新增一個 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getValue</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Fandix&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在 app.component.html 中將調用 method 的表達式填入到雙花括號中</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Hello &#123;&#123; getValue() &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767dSHzApckq2.png\"></p>\n<p>可以看到 Angular 在 template 調用了 component.ts 中的 method ，獲得到的值將他呈現在畫面中，而 Angular 在遇到差值時會執行以下的任務：</p>\n<ol>\n<li>計算雙花括號中的所有表達式</li>\n<li>將表達式的結果轉換為字串</li>\n<li>將結果鏈接到任何相鄰的文字字串</li>\n<li>將組合分配給element 或 directive 屬性</li>\n</ol>\n<h2 id=\"Syntas\"><a href=\"#Syntas\" class=\"headerlink\" title=\"Syntas\"></a>Syntas</h2><p>一樣的，要運用一個新的程式語言之前，需要先充分熟悉他的語法，不然會產生意料之外的錯誤喔，其實 templates expressions 的語法基本上都跟 Javascript expressions 一樣，但是有幾個特例：</p>\n<ul>\n<li>你不能使用有會產生 side effects 的 javascript expressions<ul>\n<li>賦值（&#x3D;, +&#x3D;, -&#x3D;, …）</li>\n<li>運算符（new, typeof, instanceof）</li>\n<li>用分號（;）鏈結 expressions</li>\n<li>遞增或遞減運算符（++,  –）</li>\n<li>還有一些 ES6 的運算符</li>\n</ul>\n</li>\n<li>與 javascript 語法有明顯差異的：<ul>\n<li>不支援 bit 的運算符（|,  &amp;）</li>\n<li>新的 template expressions（|,  ?,  !, …）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Preventing-name-collisions\"><a href=\"#Preventing-name-collisions\" class=\"headerlink\" title=\"Preventing name collisions\"></a>Preventing name collisions</h1><p>介紹完如何將 component 中的變量插入 template 讓畫面隨著變量動態改變後，要注意的是在使用這個功能時要防止名稱衝突，因為當你使用了 Text interpolationt 插入變量後， Angular 對這個表達式的計算 context 是從 <code>template variable</code>、<code>directive</code> 和 <code>component member</code> 的聯合，所以當你插入了一個名稱到 template 但這個名稱在多個地方都有定義的話， Angular 會用以下的邏輯來確定 context：</p>\n<ol>\n<li>在 template 中的變量名稱 (ngFor 中的變量)</li>\n<li>在 directive 中的 context 名稱</li>\n<li>Component 中的變量名稱</li>\n</ol>\n<p>所以當你在使用 Text interpolationt  時盡量保持所有變量名稱唯一，不然可能會被 shadowing 掉你原本想要呈現內容，我們舉個例子：</p>\n<p>這邊先提早介紹 *ngFor，他也是使用在 template 當中，用法與 javascript 的 for loop 一樣，當你的 component 中的變量是一個 arr 時，想要把這個 arr 中的數值都呈現在畫面上就可以使用這個方法，一樣舉個簡單的例子吧：</p>\n<ol>\n<li><p>首先先在 app.component.ts 中宣告一個 arr 變數並將裡面填上要呈現的內容。</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  displayArray = [<span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"string\">&#x27;world&#x27;</span>, <span class=\"string\">&#x27;Angular&#x27;</span>, <span class=\"string\">&#x27;good&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接著在 app.component.html 中使用 *ngFor 將他們全部呈現在畫面上</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let content of displayArray&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;content&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Dasf05ADZV.png\"></p>\n<p>在畫面中可以看到透過 *ngFor 不斷的遞迴將 displayArray 中的內容都顯示出來，這邊暫時介紹到這邊，之後會更詳細的介紹他的使用方法。</p>\n<p>大概了解的 *ngFor 的使用方法後，將畫面回到命名衝突，當你使用 *ngFor 命名迭代出來的每一個值得名稱時要注意這個名稱有沒有在其他地方被引用到，如果有則會將其他相同名稱的內容 shadowing 掉，舉個小例子吧。</p>\n<ol>\n<li><p>先在 app.component.ts 中定義兩個變量</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  customers = [ <span class=\"string\">&#x27;Ebony&#x27;</span>, <span class=\"string\">&#x27;Chiho&#x27;</span>];</span><br><span class=\"line\">  customer = <span class=\"string\">&#x27;Padma&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中將這兩個變量呈現在畫面中</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let customer of customers&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;&#123; customer &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">\t\t\t&#123;&#123; customer &#125;&#125;</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210802/20124767Gofwpc8OrA.png\"><br>在畫面中可以看到，原本我們希望在每次迭代 customers 中的值時，都將 customer &#x3D; ‘Padma’ 添加在上面，但是由於 *ngFor 中的變量 shadowing 了 customer 所以導致 ‘Padma’ 無法呈現出來，所以在使用 Text interpolationt 插入變量時要注意有沒有相同的名稱喔！</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇中介紹了如何在 template 中插入 component 的變量以及該注意的事情，最後介紹幾個在使用 Text interpolationt 時最好的設計規範以避免發生錯誤或是增加程式的可閱讀性：</p>\n<ul>\n<li><strong>使用簡短的表達</strong>：盡可能使用 component 中 property 的名稱或 method 調用。將應用程序和業務邏輯保留在 component 中而 template 只負責調用就可以，這樣以便進行開發和測試。</li>\n<li><strong>快速執行</strong>：Angular 會在在每個變更檢測週期後執行模板表達式，許多非同步的行為都會觸發變更檢測週期，比如 Promise、HTTP 的結果、timer events、按鍵與滑鼠的移動等等，expression 應該快速的完成不然會讓使用者體驗下降，所以當需要進行長時間計算的事情時，請考慮使用緩存值。</li>\n<li><strong>沒有明顯的 side effect</strong>：模板表達式不應該更改除了目標屬性值之外的任何應用程序狀態，讀取 component 的值時不應更改到其他的顯示值。</li>\n</ul>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/interpolation\">Angular.io - interpolation</a></li>\n</ul>"},{"title":"Day9. Transforming Data Using Pipes","date":"2022-02-15T08:18:05.000Z","_content":"\n在上一章中介紹了如何在 template 中插入 component 的變量，而本章節要介紹如何使用 angular 的 pipes 來轉換插入的值（字串、貨幣金額、日期或其他數據）， pipes 是在模板表達式中的簡單函數，用於接受輸入值並返迴轉換後的值，而 Anngular 提供了幾個預設的 pipes 提供使用：\n\n- **DatePipe**：根據區域設置規則格式化日期值\n- **UpperCasePipe**：將內容都變更為大寫\n- **LowerCasePipe**：將內容都變更為小寫\n- **CurrencyPipe**：將數字轉換為貨幣字串，根據區域設置規則進行格式化。\n- **DecimalPipe**：將數字轉換為帶小數點的字串，並根據區域設置規則進行格式化。\n- **PercentPipe**：將數字轉換為百分比字串，根據區域設置規則進行格式化。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png)\n\n<!-- more -->\n\n# Using a pipe in a template\n要在 template 中使用 pipes 功能請使用管道運算符 ( | )，一樣舉個例子吧：\n\n1. 在 app.component.ts 中新增一個變數，賦予它 javescript 的 Date 型別資料\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      birthday = new Date(1995, 9, 25);\n    }\n    ```\n\n2. 在 app.component.html 中將 birthday 插入並將其中一個使用 pipes 改變他的型態\n\n    ```html\n    <!-- app.component.html -->\n\n    <p>My birthday is {{birthday}}</p>\n    <p>My birthday is {{birthday | date }}</p>\n    ```\n    \n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png)\n\n在畫面中可以看到，沒有使用 pipes 轉換過的數值就是 javascript Date 型態的內容，而使用了 pipes 轉換過的數值看起來就好看多了，而這就是 pipes 的用法。\n\n\n\n# Transforming data with parameters and chained pipes\n\n在使用 pipes 改變呈現內容時，可以輸入可選的參數來微調 pipes 輸出的結果，比如說可以將國家單位（EUR）當作參數傳遞給 CurrencyPipe，將轉換過的貨幣單位以歐元顯示 `{{ amount | currency:'EUR' }}`，如果要對一個 pipes 使用多個參數時請使用冒號分隔這些參數，比如 `{{ amount | currency:'EUR':'Euros '}}`，也可以使用任何一個有效的模板表達式作為參數。\n\n有些 pipes 需要至少一個參數才可以使用，比如說 SlicePipe ，`{{ slice:1:5 }}` 會創建一個新陣列或字串，其中包含從  element-1 開始到 element-5 結束的元素子集。\n\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n  sayHello = 'Hello world'\n}\n```\n\n```html\n<!-- app.component.html -->\n\n<h2>{{ sayHello | slice:1:5 }}</h2>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png)\n\n畫面中原本要呈現的 `Hello world`，變成了 ello ，是因為透過 slice 選擇了 index[1] ~ index[5] 的資料。\n\n\n\n# Creating pipes for custom data transformations\n\n在開頭時提到了 Angular 有提供幾個預設的 pipes 可以使用，但這些不夠應付我們可能面面臨到的問題，這時候客製化 pipes 就很重要了，客製化的 pipes 也和預設的一樣，接收一個輸入將他轉換過後輸出，那麼就來看看該如何使用客製化 pipes 吧。\n\n## Marking a class as a pipe\n\n要建立一個客製化的 pipes，首先需要向建立 component 一樣先建立一個 typescript 的 class，但是不同的是，當我們創建 Component Class 時使用的裝飾器是 `@Component`，代表這個 Class 是屬於 Component 的，但是要建立 pipis class 則需要使用 `@Pipe` 這個裝飾器，而對這個 Class 的命名請使用 `駝峰命名法`，不要在名稱中間使用連字符號( - )，舉個例子吧，可以建立一個 pipes 接收一個數值作為輸入與一個參數，將輸入的數值做參數的次方，比如輸入 = 2 參數 = 10 那麼就會等於 2^10 = 1024。\n\n1. 使用 Angular CLI 建立一個 pipes class\n\n    ```bash\n    ng generate pipe exponential-strength\n    ```\n\n2. 在 exponential-strength.pipe.ts 中添加轉換 method\n\n    ```typescript\n    import { Pipe, PipeTransform } from '@angular/core';\n\n    @Pipe({name: 'exponentialStrength'})\n    export class ExponentialStrengthPipe implements PipeTransform {\n      transform(value: number, exponent: number = 1): number {\n        return Math.pow(value, exponent);\n      }\n    }\n    ```\n\n3. 如果你是使用 Angular CLI 他會自動將這個 pipes class 放到 app.module.ts 的 declarations 中，如果你是手動建立的話要記得將它放到 app.module.ts 的 declarations 裡面喔！\n\n    ```typescript\n    import { NgModule } from '@angular/core';\n    import { AppComponent } from './app.component';\n    import { ExponentialStrengthPipe } from './exponential-strengh.pipe';\n\n    @NgModule({\n      declarations: [\n        AppComponent,\n        ExponentialStrengthPipe,\n      ]\n    })\n    export class AppModule { }\n    ```\n4. 在 app.component.html 中使用客製化的 pipe 轉換資料\n\n    ```html\n    <!-- app.component.html -->\n\n    <h2>Power boost: {{ 2 | exponentialStrength:10 }}</h2>\n    ```\n    \n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png)\n\n\n\n# Detecting changes with data binding in pipes\n\n還記得昨天提到的 Text interpolation 的特性嗎？他可以隨著 class 的 property 變化而動態的顯示，而這個動態變化也可以套用到 pipe 中，所以當客製化的 pipe 輸入是 `string` 或 `number` 時且發生改變時，會動態的作為輸入進到 pipe 中進行轉換，但如果是 `Date` 或 `Array` 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換，舉個例子吧\n\n1. 在 app.component.ts 中定義兩個 property，一個代表要被轉換的值（輸入）另一個代表輸入要做幾次方\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n      styles: ['input {margin: .5rem 0;}']\n    })\n    export class AppComponent {\n      power = 2;\n      factor = 1;\n    }\n    ```\n\n2. 在 app.component.module.ts 的 imports 中加入 `FormsModule` ，這個是因為要在這個例子中使用到 form，所以要加入這個（之後會詳細的介紹 form）\n\n    ```typescript\n    import { NgModule } from '@angular/core';\n    import { BrowserModule } from '@angular/platform-browser';\n\n    import { AppRoutingModule } from './app-routing.module';\n    import { AppComponent } from './app.component';\n    import { FormsModule } from '@angular/forms';\n    import { ExponentialStrengthPipe } from './exponential-strengh.pipe';\n\n    @NgModule({\n      declarations: [\n        AppComponent,\n        ExponentialStrengthPipe,\n      ],\n      imports: [\n        BrowserModule,\n        AppRoutingModule,\n        FormsModule\n      ],\n      providers: [],\n      bootstrap: [AppComponent]\n    })\n    export class AppModule { }\n    ```\n\n3. 在 app.component.html 中使用 pipe\n\n    ```html\n    <!-- app.component.html -->\n\n    <h2>Power Boost Calculator</h2>\n    <label for=\"power-input\">Normal power: </label>\n    <input id=\"power-input\" type=\"text\" [(ngModel)]=\"power\" />\n    <label for=\"boost-input\">Boost factor: </label>\n    <input id=\"boost-input\" type=\"text\" [(ngModel)]=\"factor\" />\n    <p>Super Hero Power: {{ power | exponentialStrength: factor }}</p>\n    ```\n\n    這邊可能會有疑問，`[(ngModel)]` 這個是什麼？這邊大概介紹一下，如果將 component 中的 property 使用 `[(ngModel)]` 綁定，代表當 user 在畫面中的 `<input>` 中改變數值時，他會同步改變到 Component 中的 property，當然如果你改 Component 中的 property 的數值一樣會同步更改到畫面 `<input>` 中的值，這稱為 `雙向綁定`，之後會詳細講解，這邊先有大概的概念就好。\n    \n![img](https://i.imgur.com/Y92boUn.gif)\n\n在畫面中可以看到，當我們每次更改 factor 的值時，pipe 都會自動重新計算結果。\n\n\n\n# Detecting pure changes to primitives and object references\n\n在上面提到 `如果是 `Date` 或 `Array` 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換` 這邊要來詳細的說明一下。\n\n在默認情況下 pipe 要被定義成 pure 的，以便 Angular 只有在檢測到輸入值變化時才執行 pipe ，所以必須要是沒有 side effect 的 pure function，而如果是將複合對象當作輸入送進 pipe （現有的 arr 添加新元素）時，因為檢查他的 reference 比深入到 arr 中遞迴的檢查每個元素快得多，所以 Angular 會通過檢查他的 reference 來判定是否發生改變，所以當你將一個 arr 作為輸入送進一個 pipe 時，可能會發生意料之外的錯誤，下面來句個例子：\n\n對了！如果是新手對 javascript 的 object reference 不熟悉的話，建議先去了解一下為什麼對 arr 使用 push 時不算對 reference 的改變，這也是為什麼使用 const 宣告 arr 卻可以對他新增內容的原因\n\n，我在 [ES6 學習筆記_01(let & const)](https://ithelp.ithome.com.tw/articles/10231666)  中提到 const 的本質是什麼，有興趣可以去看一下。\n\n1. 首先一樣先創建一個 pipe \n\n    ```typescript\n    import { Pipe, PipeTransform } from '@angular/core';\n\n    @Pipe({name: 'flyingHeros'})\n    export class FlyingHerosPipe implements PipeTransform {\n      transform(allHeroes: any) {\n        return allHeroes.filter((hero: any) => hero.caFly);\n      }\n    }\n    ```\n\n2. 在 app.component.ts 中定義 Hero list\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n    })\n    export class AppComponent {\n      Hero = [\n        { id: 11, name: 'Dr Nice', canFly: true },\n        { id: 12, name: 'Narco', canFly: false },\n        { id: 13, name: 'Bombasto',  canFly: false },\n        { id: 14, name: 'Celeritas',  canFly: true },\n        { id: 15, name: 'Magneta',  canFly: false },\n        { id: 16, name: 'RubberMan',  canFly: true },\n        { id: 17, name: 'Dynama',  canFly: true },\n        { id: 18, name: 'Dr IQ',  canFly: true },\n        { id: 19, name: 'Magma',  canFly: false },\n        { id: 20, name: 'Tornado',  canFly: true },\n      ];\n    }\n    ```\n\n3. 在 app.component.html 中使用 pipe 將可以飛的英雄顯示出來\n\n    ```html\n    <!-- app.component.html -->\n\n    <div *ngFor=\"let hero of ( heros | flyingHeros )\">\n        {{hero.name}}\n    </div>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png](https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png)\n\n在畫面中可以看到只有會飛的英雄顯示出來，這時我們在 heros 中使用 push 新增英雄。\n\n```typescript\nonAddHero() {\n  this.heros.push({ id: 1, name: 'Fandix', canFly: true });\n}\n```\n\n當我將新的英雄 push 近 heros 中，卻發現畫面沒有更改，是壞掉了嗎？ 讓我們將 heros console 出來確認是否真的有將他 push 進去。\n\n```typescript\nonAddHero() {\n  this.heros.push({ id: 1, name: 'Fandix', canFly: true });\n\tconsole.log(this.heros);\n}\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png)\n\n在 console 中可以看到我們確實有將新英雄 push 進 heros 中，這就是剛剛提到的 Angular 在面對 arr 時，只有在他的 reference 發生改變時才會觸發 pipe，有興趣的可以自己嘗試一下，把 `onAddHero()` 變成\n\n```typescript\nonAddHero() {\n  this.heros = [\n      { id: 11, name: 'Dr Nice', canFly: true },\n      { id: 12, name: 'Narco', canFly: false },\n      { id: 13, name: 'Bombasto', canFly: false },\n      { id: 14, name: 'Celeritas', canFly: true },\n      { id: 15, name: 'Magneta', canFly: false },\n      { id: 16, name: 'RubberMan', canFly: true },\n      { id: 17, name: 'Dynama', canFly: true },\n      { id: 18, name: 'Dr IQ', canFly: true },\n      { id: 19, name: 'Magma', canFly: false },\n      { id: 20, name: 'Tornado', canFly: true },\n      { id: 1, name: 'Fandix', canFly: true },\n    ];\n}\n```\n\n會發生什麼事。\n\n所以在使用者種複合型的資料時，需要特別注意`只有當輸入的 Reference 發生改變時，才會觸發 pipe `。\n\n\n\n# Detecting impure changes within composite objects\n\n那你可能想說，我不要啊我天生反骨我就是想要使用 push 就可以觸發 pipe 可不可以？\n\n當然可以，Angular 提供了當複合數據內發生改變時也可以觸發 pipe 的方法，首先你`需要將這個 pipe 變得 impure`，這樣才可以檢測到 impure 的變化，所以 Angular 只要檢測到每次按鍵或滑鼠的變化時都會觸發一個 impure 的 pipe，要做的很簡單，只要在 pipe.ts 中增加一個屬性就可以了\n\n```typescript\n@Pipe({name: 'flyingHeros', pure: false})\n```\n\n一樣有興趣的可以拿上面的例子直接將他變成 impure 試試看，這邊就不再做一次了。\n\n\n\n# Pipes and precedence\n\n介紹了這麼多的 pipe 用法，可能有人會問：既然 pipe 是透過 ｜ 加在數值後面的，那如果這個數值在進行其他的 Javascript expressions 怎麼辦？\n\n其實在 Angular 中 pipe 運算符的優先級是高於三元運算子（: ?），這意味著如果你有一個 Text interpolation 長這樣 `{{ a ? b : c | x }}` ，那麼他會被解析成 `{{ a ? b : (c | x) }}` 而這個結果可能不是你所希望的，如果你希望達到 `{{ a ? b : c | x }}` 這個結果，請使用括號將前面的三元運算子括起來 `{{ (a ? b : c) | x }}`\n\n\n\n# 結論\n\n本篇章中介紹了什麼是 pipe、該怎麼使用它以及客製化自己的 pipe，了解 pipe 對於開發專案是有幫助的，也要特別注意在預設情況下 pipe 是 pure 的，當傳入的輸入是複合型資料時，只有在他的 reference 發生改變時才會觸發，如果想要避免這個問題可以將 pipe 更改為 impure 就可以了。\n\n在官方文檔中還有介紹 `observable` 與 `HTTP` 的 pipe，但是因為牽扯到太多其他的技巧不太符合我們新手入門的領域，所以不在這邊介紹，不過了解了pipe 的基本原理之後，當遇到類似問題再去看就會比較容易看懂，所以就允許我偷懶一下吧\n\n下一篇會介紹 template 的 property binding，它的作用是可以讓你設置 HTML Tag 或 directive 的屬性質，詳細的介紹就期待明天吧。\n\n\n\n# Reference\n\n- [Angular.io - pipes](https://angular.io/guide/pipes)\n","source":"_posts/Angular/angular-09.md","raw":"---\ntitle: Day9. Transforming Data Using Pipes\ndate: 2022-02-15 16:18:05\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n在上一章中介紹了如何在 template 中插入 component 的變量，而本章節要介紹如何使用 angular 的 pipes 來轉換插入的值（字串、貨幣金額、日期或其他數據）， pipes 是在模板表達式中的簡單函數，用於接受輸入值並返迴轉換後的值，而 Anngular 提供了幾個預設的 pipes 提供使用：\n\n- **DatePipe**：根據區域設置規則格式化日期值\n- **UpperCasePipe**：將內容都變更為大寫\n- **LowerCasePipe**：將內容都變更為小寫\n- **CurrencyPipe**：將數字轉換為貨幣字串，根據區域設置規則進行格式化。\n- **DecimalPipe**：將數字轉換為帶小數點的字串，並根據區域設置規則進行格式化。\n- **PercentPipe**：將數字轉換為百分比字串，根據區域設置規則進行格式化。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png)\n\n<!-- more -->\n\n# Using a pipe in a template\n要在 template 中使用 pipes 功能請使用管道運算符 ( | )，一樣舉個例子吧：\n\n1. 在 app.component.ts 中新增一個變數，賦予它 javescript 的 Date 型別資料\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html'\n    })\n    export class AppComponent {\n      birthday = new Date(1995, 9, 25);\n    }\n    ```\n\n2. 在 app.component.html 中將 birthday 插入並將其中一個使用 pipes 改變他的型態\n\n    ```html\n    <!-- app.component.html -->\n\n    <p>My birthday is {{birthday}}</p>\n    <p>My birthday is {{birthday | date }}</p>\n    ```\n    \n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png)\n\n在畫面中可以看到，沒有使用 pipes 轉換過的數值就是 javascript Date 型態的內容，而使用了 pipes 轉換過的數值看起來就好看多了，而這就是 pipes 的用法。\n\n\n\n# Transforming data with parameters and chained pipes\n\n在使用 pipes 改變呈現內容時，可以輸入可選的參數來微調 pipes 輸出的結果，比如說可以將國家單位（EUR）當作參數傳遞給 CurrencyPipe，將轉換過的貨幣單位以歐元顯示 `{{ amount | currency:'EUR' }}`，如果要對一個 pipes 使用多個參數時請使用冒號分隔這些參數，比如 `{{ amount | currency:'EUR':'Euros '}}`，也可以使用任何一個有效的模板表達式作為參數。\n\n有些 pipes 需要至少一個參數才可以使用，比如說 SlicePipe ，`{{ slice:1:5 }}` 會創建一個新陣列或字串，其中包含從  element-1 開始到 element-5 結束的元素子集。\n\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n  sayHello = 'Hello world'\n}\n```\n\n```html\n<!-- app.component.html -->\n\n<h2>{{ sayHello | slice:1:5 }}</h2>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png)\n\n畫面中原本要呈現的 `Hello world`，變成了 ello ，是因為透過 slice 選擇了 index[1] ~ index[5] 的資料。\n\n\n\n# Creating pipes for custom data transformations\n\n在開頭時提到了 Angular 有提供幾個預設的 pipes 可以使用，但這些不夠應付我們可能面面臨到的問題，這時候客製化 pipes 就很重要了，客製化的 pipes 也和預設的一樣，接收一個輸入將他轉換過後輸出，那麼就來看看該如何使用客製化 pipes 吧。\n\n## Marking a class as a pipe\n\n要建立一個客製化的 pipes，首先需要向建立 component 一樣先建立一個 typescript 的 class，但是不同的是，當我們創建 Component Class 時使用的裝飾器是 `@Component`，代表這個 Class 是屬於 Component 的，但是要建立 pipis class 則需要使用 `@Pipe` 這個裝飾器，而對這個 Class 的命名請使用 `駝峰命名法`，不要在名稱中間使用連字符號( - )，舉個例子吧，可以建立一個 pipes 接收一個數值作為輸入與一個參數，將輸入的數值做參數的次方，比如輸入 = 2 參數 = 10 那麼就會等於 2^10 = 1024。\n\n1. 使用 Angular CLI 建立一個 pipes class\n\n    ```bash\n    ng generate pipe exponential-strength\n    ```\n\n2. 在 exponential-strength.pipe.ts 中添加轉換 method\n\n    ```typescript\n    import { Pipe, PipeTransform } from '@angular/core';\n\n    @Pipe({name: 'exponentialStrength'})\n    export class ExponentialStrengthPipe implements PipeTransform {\n      transform(value: number, exponent: number = 1): number {\n        return Math.pow(value, exponent);\n      }\n    }\n    ```\n\n3. 如果你是使用 Angular CLI 他會自動將這個 pipes class 放到 app.module.ts 的 declarations 中，如果你是手動建立的話要記得將它放到 app.module.ts 的 declarations 裡面喔！\n\n    ```typescript\n    import { NgModule } from '@angular/core';\n    import { AppComponent } from './app.component';\n    import { ExponentialStrengthPipe } from './exponential-strengh.pipe';\n\n    @NgModule({\n      declarations: [\n        AppComponent,\n        ExponentialStrengthPipe,\n      ]\n    })\n    export class AppModule { }\n    ```\n4. 在 app.component.html 中使用客製化的 pipe 轉換資料\n\n    ```html\n    <!-- app.component.html -->\n\n    <h2>Power boost: {{ 2 | exponentialStrength:10 }}</h2>\n    ```\n    \n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png)\n\n\n\n# Detecting changes with data binding in pipes\n\n還記得昨天提到的 Text interpolation 的特性嗎？他可以隨著 class 的 property 變化而動態的顯示，而這個動態變化也可以套用到 pipe 中，所以當客製化的 pipe 輸入是 `string` 或 `number` 時且發生改變時，會動態的作為輸入進到 pipe 中進行轉換，但如果是 `Date` 或 `Array` 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換，舉個例子吧\n\n1. 在 app.component.ts 中定義兩個 property，一個代表要被轉換的值（輸入）另一個代表輸入要做幾次方\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n      styles: ['input {margin: .5rem 0;}']\n    })\n    export class AppComponent {\n      power = 2;\n      factor = 1;\n    }\n    ```\n\n2. 在 app.component.module.ts 的 imports 中加入 `FormsModule` ，這個是因為要在這個例子中使用到 form，所以要加入這個（之後會詳細的介紹 form）\n\n    ```typescript\n    import { NgModule } from '@angular/core';\n    import { BrowserModule } from '@angular/platform-browser';\n\n    import { AppRoutingModule } from './app-routing.module';\n    import { AppComponent } from './app.component';\n    import { FormsModule } from '@angular/forms';\n    import { ExponentialStrengthPipe } from './exponential-strengh.pipe';\n\n    @NgModule({\n      declarations: [\n        AppComponent,\n        ExponentialStrengthPipe,\n      ],\n      imports: [\n        BrowserModule,\n        AppRoutingModule,\n        FormsModule\n      ],\n      providers: [],\n      bootstrap: [AppComponent]\n    })\n    export class AppModule { }\n    ```\n\n3. 在 app.component.html 中使用 pipe\n\n    ```html\n    <!-- app.component.html -->\n\n    <h2>Power Boost Calculator</h2>\n    <label for=\"power-input\">Normal power: </label>\n    <input id=\"power-input\" type=\"text\" [(ngModel)]=\"power\" />\n    <label for=\"boost-input\">Boost factor: </label>\n    <input id=\"boost-input\" type=\"text\" [(ngModel)]=\"factor\" />\n    <p>Super Hero Power: {{ power | exponentialStrength: factor }}</p>\n    ```\n\n    這邊可能會有疑問，`[(ngModel)]` 這個是什麼？這邊大概介紹一下，如果將 component 中的 property 使用 `[(ngModel)]` 綁定，代表當 user 在畫面中的 `<input>` 中改變數值時，他會同步改變到 Component 中的 property，當然如果你改 Component 中的 property 的數值一樣會同步更改到畫面 `<input>` 中的值，這稱為 `雙向綁定`，之後會詳細講解，這邊先有大概的概念就好。\n    \n![img](https://i.imgur.com/Y92boUn.gif)\n\n在畫面中可以看到，當我們每次更改 factor 的值時，pipe 都會自動重新計算結果。\n\n\n\n# Detecting pure changes to primitives and object references\n\n在上面提到 `如果是 `Date` 或 `Array` 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換` 這邊要來詳細的說明一下。\n\n在默認情況下 pipe 要被定義成 pure 的，以便 Angular 只有在檢測到輸入值變化時才執行 pipe ，所以必須要是沒有 side effect 的 pure function，而如果是將複合對象當作輸入送進 pipe （現有的 arr 添加新元素）時，因為檢查他的 reference 比深入到 arr 中遞迴的檢查每個元素快得多，所以 Angular 會通過檢查他的 reference 來判定是否發生改變，所以當你將一個 arr 作為輸入送進一個 pipe 時，可能會發生意料之外的錯誤，下面來句個例子：\n\n對了！如果是新手對 javascript 的 object reference 不熟悉的話，建議先去了解一下為什麼對 arr 使用 push 時不算對 reference 的改變，這也是為什麼使用 const 宣告 arr 卻可以對他新增內容的原因\n\n，我在 [ES6 學習筆記_01(let & const)](https://ithelp.ithome.com.tw/articles/10231666)  中提到 const 的本質是什麼，有興趣可以去看一下。\n\n1. 首先一樣先創建一個 pipe \n\n    ```typescript\n    import { Pipe, PipeTransform } from '@angular/core';\n\n    @Pipe({name: 'flyingHeros'})\n    export class FlyingHerosPipe implements PipeTransform {\n      transform(allHeroes: any) {\n        return allHeroes.filter((hero: any) => hero.caFly);\n      }\n    }\n    ```\n\n2. 在 app.component.ts 中定義 Hero list\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n    })\n    export class AppComponent {\n      Hero = [\n        { id: 11, name: 'Dr Nice', canFly: true },\n        { id: 12, name: 'Narco', canFly: false },\n        { id: 13, name: 'Bombasto',  canFly: false },\n        { id: 14, name: 'Celeritas',  canFly: true },\n        { id: 15, name: 'Magneta',  canFly: false },\n        { id: 16, name: 'RubberMan',  canFly: true },\n        { id: 17, name: 'Dynama',  canFly: true },\n        { id: 18, name: 'Dr IQ',  canFly: true },\n        { id: 19, name: 'Magma',  canFly: false },\n        { id: 20, name: 'Tornado',  canFly: true },\n      ];\n    }\n    ```\n\n3. 在 app.component.html 中使用 pipe 將可以飛的英雄顯示出來\n\n    ```html\n    <!-- app.component.html -->\n\n    <div *ngFor=\"let hero of ( heros | flyingHeros )\">\n        {{hero.name}}\n    </div>\n    ```\n\n![https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png](https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png)\n\n在畫面中可以看到只有會飛的英雄顯示出來，這時我們在 heros 中使用 push 新增英雄。\n\n```typescript\nonAddHero() {\n  this.heros.push({ id: 1, name: 'Fandix', canFly: true });\n}\n```\n\n當我將新的英雄 push 近 heros 中，卻發現畫面沒有更改，是壞掉了嗎？ 讓我們將 heros console 出來確認是否真的有將他 push 進去。\n\n```typescript\nonAddHero() {\n  this.heros.push({ id: 1, name: 'Fandix', canFly: true });\n\tconsole.log(this.heros);\n}\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png](https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png)\n\n在 console 中可以看到我們確實有將新英雄 push 進 heros 中，這就是剛剛提到的 Angular 在面對 arr 時，只有在他的 reference 發生改變時才會觸發 pipe，有興趣的可以自己嘗試一下，把 `onAddHero()` 變成\n\n```typescript\nonAddHero() {\n  this.heros = [\n      { id: 11, name: 'Dr Nice', canFly: true },\n      { id: 12, name: 'Narco', canFly: false },\n      { id: 13, name: 'Bombasto', canFly: false },\n      { id: 14, name: 'Celeritas', canFly: true },\n      { id: 15, name: 'Magneta', canFly: false },\n      { id: 16, name: 'RubberMan', canFly: true },\n      { id: 17, name: 'Dynama', canFly: true },\n      { id: 18, name: 'Dr IQ', canFly: true },\n      { id: 19, name: 'Magma', canFly: false },\n      { id: 20, name: 'Tornado', canFly: true },\n      { id: 1, name: 'Fandix', canFly: true },\n    ];\n}\n```\n\n會發生什麼事。\n\n所以在使用者種複合型的資料時，需要特別注意`只有當輸入的 Reference 發生改變時，才會觸發 pipe `。\n\n\n\n# Detecting impure changes within composite objects\n\n那你可能想說，我不要啊我天生反骨我就是想要使用 push 就可以觸發 pipe 可不可以？\n\n當然可以，Angular 提供了當複合數據內發生改變時也可以觸發 pipe 的方法，首先你`需要將這個 pipe 變得 impure`，這樣才可以檢測到 impure 的變化，所以 Angular 只要檢測到每次按鍵或滑鼠的變化時都會觸發一個 impure 的 pipe，要做的很簡單，只要在 pipe.ts 中增加一個屬性就可以了\n\n```typescript\n@Pipe({name: 'flyingHeros', pure: false})\n```\n\n一樣有興趣的可以拿上面的例子直接將他變成 impure 試試看，這邊就不再做一次了。\n\n\n\n# Pipes and precedence\n\n介紹了這麼多的 pipe 用法，可能有人會問：既然 pipe 是透過 ｜ 加在數值後面的，那如果這個數值在進行其他的 Javascript expressions 怎麼辦？\n\n其實在 Angular 中 pipe 運算符的優先級是高於三元運算子（: ?），這意味著如果你有一個 Text interpolation 長這樣 `{{ a ? b : c | x }}` ，那麼他會被解析成 `{{ a ? b : (c | x) }}` 而這個結果可能不是你所希望的，如果你希望達到 `{{ a ? b : c | x }}` 這個結果，請使用括號將前面的三元運算子括起來 `{{ (a ? b : c) | x }}`\n\n\n\n# 結論\n\n本篇章中介紹了什麼是 pipe、該怎麼使用它以及客製化自己的 pipe，了解 pipe 對於開發專案是有幫助的，也要特別注意在預設情況下 pipe 是 pure 的，當傳入的輸入是複合型資料時，只有在他的 reference 發生改變時才會觸發，如果想要避免這個問題可以將 pipe 更改為 impure 就可以了。\n\n在官方文檔中還有介紹 `observable` 與 `HTTP` 的 pipe，但是因為牽扯到太多其他的技巧不太符合我們新手入門的領域，所以不在這邊介紹，不過了解了pipe 的基本原理之後，當遇到類似問題再去看就會比較容易看懂，所以就允許我偷懶一下吧\n\n下一篇會介紹 template 的 property binding，它的作用是可以讓你設置 HTML Tag 或 directive 的屬性質，詳細的介紹就期待明天吧。\n\n\n\n# Reference\n\n- [Angular.io - pipes](https://angular.io/guide/pipes)\n","slug":"Angular/angular-09","published":1,"updated":"2022-02-15T08:20:35.438Z","_id":"ckznus5dt001ckww30je6escn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在上一章中介紹了如何在 template 中插入 component 的變量，而本章節要介紹如何使用 angular 的 pipes 來轉換插入的值（字串、貨幣金額、日期或其他數據）， pipes 是在模板表達式中的簡單函數，用於接受輸入值並返迴轉換後的值，而 Anngular 提供了幾個預設的 pipes 提供使用：</p>\n<ul>\n<li><strong>DatePipe</strong>：根據區域設置規則格式化日期值</li>\n<li><strong>UpperCasePipe</strong>：將內容都變更為大寫</li>\n<li><strong>LowerCasePipe</strong>：將內容都變更為小寫</li>\n<li><strong>CurrencyPipe</strong>：將數字轉換為貨幣字串，根據區域設置規則進行格式化。</li>\n<li><strong>DecimalPipe</strong>：將數字轉換為帶小數點的字串，並根據區域設置規則進行格式化。</li>\n<li><strong>PercentPipe</strong>：將數字轉換為百分比字串，根據區域設置規則進行格式化。</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Using-a-pipe-in-a-template\"><a href=\"#Using-a-pipe-in-a-template\" class=\"headerlink\" title=\"Using a pipe in a template\"></a>Using a pipe in a template</h1><p>要在 template 中使用 pipes 功能請使用管道運算符 ( | )，一樣舉個例子吧：</p>\n<ol>\n<li><p>在 app.component.ts 中新增一個變數，賦予它 javescript 的 Date 型別資料</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  birthday = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(<span class=\"number\">1995</span>, <span class=\"number\">9</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中將 birthday 插入並將其中一個使用 pipes 改變他的型態</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>My birthday is &#123;&#123;birthday&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>My birthday is &#123;&#123;birthday | date &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png\"></p>\n<p>在畫面中可以看到，沒有使用 pipes 轉換過的數值就是 javascript Date 型態的內容，而使用了 pipes 轉換過的數值看起來就好看多了，而這就是 pipes 的用法。</p>\n<h1 id=\"Transforming-data-with-parameters-and-chained-pipes\"><a href=\"#Transforming-data-with-parameters-and-chained-pipes\" class=\"headerlink\" title=\"Transforming data with parameters and chained pipes\"></a>Transforming data with parameters and chained pipes</h1><p>在使用 pipes 改變呈現內容時，可以輸入可選的參數來微調 pipes 輸出的結果，比如說可以將國家單位（EUR）當作參數傳遞給 CurrencyPipe，將轉換過的貨幣單位以歐元顯示 <code>&#123;&#123; amount | currency:'EUR' &#125;&#125;</code>，如果要對一個 pipes 使用多個參數時請使用冒號分隔這些參數，比如 <code>&#123;&#123; amount | currency:'EUR':'Euros '&#125;&#125;</code>，也可以使用任何一個有效的模板表達式作為參數。</p>\n<p>有些 pipes 需要至少一個參數才可以使用，比如說 SlicePipe ，<code>&#123;&#123; slice:1:5 &#125;&#125;</code> 會創建一個新陣列或字串，其中包含從  element-1 開始到 element-5 結束的元素子集。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  sayHello = <span class=\"string\">&#x27;Hello world&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; sayHello | slice:1:5 &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png\"></p>\n<p>畫面中原本要呈現的 <code>Hello world</code>，變成了 ello ，是因為透過 slice 選擇了 index[1] ~ index[5] 的資料。</p>\n<h1 id=\"Creating-pipes-for-custom-data-transformations\"><a href=\"#Creating-pipes-for-custom-data-transformations\" class=\"headerlink\" title=\"Creating pipes for custom data transformations\"></a>Creating pipes for custom data transformations</h1><p>在開頭時提到了 Angular 有提供幾個預設的 pipes 可以使用，但這些不夠應付我們可能面面臨到的問題，這時候客製化 pipes 就很重要了，客製化的 pipes 也和預設的一樣，接收一個輸入將他轉換過後輸出，那麼就來看看該如何使用客製化 pipes 吧。</p>\n<h2 id=\"Marking-a-class-as-a-pipe\"><a href=\"#Marking-a-class-as-a-pipe\" class=\"headerlink\" title=\"Marking a class as a pipe\"></a>Marking a class as a pipe</h2><p>要建立一個客製化的 pipes，首先需要向建立 component 一樣先建立一個 typescript 的 class，但是不同的是，當我們創建 Component Class 時使用的裝飾器是 <code>@Component</code>，代表這個 Class 是屬於 Component 的，但是要建立 pipis class 則需要使用 <code>@Pipe</code> 這個裝飾器，而對這個 Class 的命名請使用 <code>駝峰命名法</code>，不要在名稱中間使用連字符號( - )，舉個例子吧，可以建立一個 pipes 接收一個數值作為輸入與一個參數，將輸入的數值做參數的次方，比如輸入 &#x3D; 2 參數 &#x3D; 10 那麼就會等於 2^10 &#x3D; 1024。</p>\n<ol>\n<li><p>使用 Angular CLI 建立一個 pipes class</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate pipe exponential-strength</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 exponential-strength.pipe.ts 中添加轉換 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Pipe</span>, <span class=\"title class_\">PipeTransform</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;exponentialStrength&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExponentialStrengthPipe</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">PipeTransform</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">transform</span>(<span class=\"attr\">value</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">exponent</span>: <span class=\"built_in\">number</span> = <span class=\"number\">1</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(value, exponent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你是使用 Angular CLI 他會自動將這個 pipes class 放到 app.module.ts 的 declarations 中，如果你是手動建立的話要記得將它放到 app.module.ts 的 declarations 裡面喔！</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">NgModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ExponentialStrengthPipe</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./exponential-strengh.pipe&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">declarations</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">AppComponent</span>,</span><br><span class=\"line\">    <span class=\"title class_\">ExponentialStrengthPipe</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在 app.component.html 中使用客製化的 pipe 轉換資料</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Power boost: &#123;&#123; 2 | exponentialStrength:10 &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png\"></p>\n<h1 id=\"Detecting-changes-with-data-binding-in-pipes\"><a href=\"#Detecting-changes-with-data-binding-in-pipes\" class=\"headerlink\" title=\"Detecting changes with data binding in pipes\"></a>Detecting changes with data binding in pipes</h1><p>還記得昨天提到的 Text interpolation 的特性嗎？他可以隨著 class 的 property 變化而動態的顯示，而這個動態變化也可以套用到 pipe 中，所以當客製化的 pipe 輸入是 <code>string</code> 或 <code>number</code> 時且發生改變時，會動態的作為輸入進到 pipe 中進行轉換，但如果是 <code>Date</code> 或 <code>Array</code> 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換，舉個例子吧</p>\n<ol>\n<li><p>在 app.component.ts 中定義兩個 property，一個代表要被轉換的值（輸入）另一個代表輸入要做幾次方</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styles</span>: [<span class=\"string\">&#x27;input &#123;margin: .5rem 0;&#125;&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  power = <span class=\"number\">2</span>;</span><br><span class=\"line\">  factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.module.ts 的 imports 中加入 <code>FormsModule</code> ，這個是因為要在這個例子中使用到 form，所以要加入這個（之後會詳細的介紹 form）</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">NgModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">BrowserModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppRoutingModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app-routing.module&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">FormsModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ExponentialStrengthPipe</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./exponential-strengh.pipe&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">declarations</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">AppComponent</span>,</span><br><span class=\"line\">    <span class=\"title class_\">ExponentialStrengthPipe</span>,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">BrowserModule</span>,</span><br><span class=\"line\">    <span class=\"title class_\">AppRoutingModule</span>,</span><br><span class=\"line\">    <span class=\"title class_\">FormsModule</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [],</span><br><span class=\"line\">  <span class=\"attr\">bootstrap</span>: [<span class=\"title class_\">AppComponent</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中使用 pipe</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Power Boost Calculator<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;power-input&quot;</span>&gt;</span>Normal power: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;power-input&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;power&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;boost-input&quot;</span>&gt;</span>Boost factor: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;boost-input&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;factor&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Super Hero Power: &#123;&#123; power | exponentialStrength: factor &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> 這邊可能會有疑問，<code>[(ngModel)]</code> 這個是什麼？這邊大概介紹一下，如果將 component 中的 property 使用 <code>[(ngModel)]</code> 綁定，代表當 user 在畫面中的 <code>&lt;input&gt;</code> 中改變數值時，他會同步改變到 Component 中的 property，當然如果你改 Component 中的 property 的數值一樣會同步更改到畫面 <code>&lt;input&gt;</code> 中的值，這稱為 <code>雙向綁定</code>，之後會詳細講解，這邊先有大概的概念就好。</p>\n</li>\n</ol>\n<p><img src=\"https://i.imgur.com/Y92boUn.gif\" alt=\"img\"></p>\n<p>在畫面中可以看到，當我們每次更改 factor 的值時，pipe 都會自動重新計算結果。</p>\n<h1 id=\"Detecting-pure-changes-to-primitives-and-object-references\"><a href=\"#Detecting-pure-changes-to-primitives-and-object-references\" class=\"headerlink\" title=\"Detecting pure changes to primitives and object references\"></a>Detecting pure changes to primitives and object references</h1><p>在上面提到 <code>如果是 </code>Date<code>或</code>Array<code> 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換</code> 這邊要來詳細的說明一下。</p>\n<p>在默認情況下 pipe 要被定義成 pure 的，以便 Angular 只有在檢測到輸入值變化時才執行 pipe ，所以必須要是沒有 side effect 的 pure function，而如果是將複合對象當作輸入送進 pipe （現有的 arr 添加新元素）時，因為檢查他的 reference 比深入到 arr 中遞迴的檢查每個元素快得多，所以 Angular 會通過檢查他的 reference 來判定是否發生改變，所以當你將一個 arr 作為輸入送進一個 pipe 時，可能會發生意料之外的錯誤，下面來句個例子：</p>\n<p>對了！如果是新手對 javascript 的 object reference 不熟悉的話，建議先去了解一下為什麼對 arr 使用 push 時不算對 reference 的改變，這也是為什麼使用 const 宣告 arr 卻可以對他新增內容的原因</p>\n<p>，我在 <a href=\"https://ithelp.ithome.com.tw/articles/10231666\">ES6 學習筆記_01(let &amp; const)</a>  中提到 const 的本質是什麼，有興趣可以去看一下。</p>\n<ol>\n<li><p>首先一樣先創建一個 pipe </p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Pipe</span>, <span class=\"title class_\">PipeTransform</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyingHeros&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyingHerosPipe</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">PipeTransform</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">transform</span>(<span class=\"params\">allHeroes: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> allHeroes.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">hero: <span class=\"built_in\">any</span></span>) =&gt;</span> hero.<span class=\"property\">caFly</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.ts 中定義 Hero list</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Hero</span> = [</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">11</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr Nice&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">12</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Narco&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">13</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Bombasto&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">14</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Celeritas&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">15</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magneta&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">16</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;RubberMan&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">17</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dynama&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">18</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr IQ&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">19</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magma&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">20</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tornado&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中使用 pipe 將可以飛的英雄顯示出來</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let hero of ( heros | flyingHeros )&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;hero.name&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png\"></p>\n<p>在畫面中可以看到只有會飛的英雄顯示出來，這時我們在 heros 中使用 push 新增英雄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onAddHero</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">heros</span>.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>當我將新的英雄 push 近 heros 中，卻發現畫面沒有更改，是壞掉了嗎？ 讓我們將 heros console 出來確認是否真的有將他 push 進去。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onAddHero</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">heros</span>.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">heros</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png\"></p>\n<p>在 console 中可以看到我們確實有將新英雄 push 進 heros 中，這就是剛剛提到的 Angular 在面對 arr 時，只有在他的 reference 發生改變時才會觸發 pipe，有興趣的可以自己嘗試一下，把 <code>onAddHero()</code> 變成</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onAddHero</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">heros</span> = [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">11</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr Nice&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">12</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Narco&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">13</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Bombasto&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">14</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Celeritas&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">15</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magneta&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">16</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;RubberMan&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">17</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dynama&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">18</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr IQ&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">19</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magma&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">20</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tornado&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>會發生什麼事。</p>\n<p>所以在使用者種複合型的資料時，需要特別注意<code>只有當輸入的 Reference 發生改變時，才會觸發 pipe </code>。</p>\n<h1 id=\"Detecting-impure-changes-within-composite-objects\"><a href=\"#Detecting-impure-changes-within-composite-objects\" class=\"headerlink\" title=\"Detecting impure changes within composite objects\"></a>Detecting impure changes within composite objects</h1><p>那你可能想說，我不要啊我天生反骨我就是想要使用 push 就可以觸發 pipe 可不可以？</p>\n<p>當然可以，Angular 提供了當複合數據內發生改變時也可以觸發 pipe 的方法，首先你<code>需要將這個 pipe 變得 impure</code>，這樣才可以檢測到 impure 的變化，所以 Angular 只要檢測到每次按鍵或滑鼠的變化時都會觸發一個 impure 的 pipe，要做的很簡單，只要在 pipe.ts 中增加一個屬性就可以了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyingHeros&#x27;</span>, <span class=\"attr\">pure</span>: <span class=\"literal\">false</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>一樣有興趣的可以拿上面的例子直接將他變成 impure 試試看，這邊就不再做一次了。</p>\n<h1 id=\"Pipes-and-precedence\"><a href=\"#Pipes-and-precedence\" class=\"headerlink\" title=\"Pipes and precedence\"></a>Pipes and precedence</h1><p>介紹了這麼多的 pipe 用法，可能有人會問：既然 pipe 是透過 ｜ 加在數值後面的，那如果這個數值在進行其他的 Javascript expressions 怎麼辦？</p>\n<p>其實在 Angular 中 pipe 運算符的優先級是高於三元運算子（: ?），這意味著如果你有一個 Text interpolation 長這樣 <code>&#123;&#123; a ? b : c | x &#125;&#125;</code> ，那麼他會被解析成 <code>&#123;&#123; a ? b : (c | x) &#125;&#125;</code> 而這個結果可能不是你所希望的，如果你希望達到 <code>&#123;&#123; a ? b : c | x &#125;&#125;</code> 這個結果，請使用括號將前面的三元運算子括起來 <code>&#123;&#123; (a ? b : c) | x &#125;&#125;</code></p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇章中介紹了什麼是 pipe、該怎麼使用它以及客製化自己的 pipe，了解 pipe 對於開發專案是有幫助的，也要特別注意在預設情況下 pipe 是 pure 的，當傳入的輸入是複合型資料時，只有在他的 reference 發生改變時才會觸發，如果想要避免這個問題可以將 pipe 更改為 impure 就可以了。</p>\n<p>在官方文檔中還有介紹 <code>observable</code> 與 <code>HTTP</code> 的 pipe，但是因為牽扯到太多其他的技巧不太符合我們新手入門的領域，所以不在這邊介紹，不過了解了pipe 的基本原理之後，當遇到類似問題再去看就會比較容易看懂，所以就允許我偷懶一下吧</p>\n<p>下一篇會介紹 template 的 property binding，它的作用是可以讓你設置 HTML Tag 或 directive 的屬性質，詳細的介紹就期待明天吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/pipes\">Angular.io - pipes</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在上一章中介紹了如何在 template 中插入 component 的變量，而本章節要介紹如何使用 angular 的 pipes 來轉換插入的值（字串、貨幣金額、日期或其他數據）， pipes 是在模板表達式中的簡單函數，用於接受輸入值並返迴轉換後的值，而 Anngular 提供了幾個預設的 pipes 提供使用：</p>\n<ul>\n<li><strong>DatePipe</strong>：根據區域設置規則格式化日期值</li>\n<li><strong>UpperCasePipe</strong>：將內容都變更為大寫</li>\n<li><strong>LowerCasePipe</strong>：將內容都變更為小寫</li>\n<li><strong>CurrencyPipe</strong>：將數字轉換為貨幣字串，根據區域設置規則進行格式化。</li>\n<li><strong>DecimalPipe</strong>：將數字轉換為帶小數點的字串，並根據區域設置規則進行格式化。</li>\n<li><strong>PercentPipe</strong>：將數字轉換為百分比字串，根據區域設置規則進行格式化。</li>\n</ul>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767iCR0nyUNiR.png\"></p>","more":"<h1 id=\"Using-a-pipe-in-a-template\"><a href=\"#Using-a-pipe-in-a-template\" class=\"headerlink\" title=\"Using a pipe in a template\"></a>Using a pipe in a template</h1><p>要在 template 中使用 pipes 功能請使用管道運算符 ( | )，一樣舉個例子吧：</p>\n<ol>\n<li><p>在 app.component.ts 中新增一個變數，賦予它 javescript 的 Date 型別資料</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  birthday = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(<span class=\"number\">1995</span>, <span class=\"number\">9</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中將 birthday 插入並將其中一個使用 pipes 改變他的型態</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>My birthday is &#123;&#123;birthday&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>My birthday is &#123;&#123;birthday | date &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767GlSkfWn7Na.png\"></p>\n<p>在畫面中可以看到，沒有使用 pipes 轉換過的數值就是 javascript Date 型態的內容，而使用了 pipes 轉換過的數值看起來就好看多了，而這就是 pipes 的用法。</p>\n<h1 id=\"Transforming-data-with-parameters-and-chained-pipes\"><a href=\"#Transforming-data-with-parameters-and-chained-pipes\" class=\"headerlink\" title=\"Transforming data with parameters and chained pipes\"></a>Transforming data with parameters and chained pipes</h1><p>在使用 pipes 改變呈現內容時，可以輸入可選的參數來微調 pipes 輸出的結果，比如說可以將國家單位（EUR）當作參數傳遞給 CurrencyPipe，將轉換過的貨幣單位以歐元顯示 <code>&#123;&#123; amount | currency:'EUR' &#125;&#125;</code>，如果要對一個 pipes 使用多個參數時請使用冒號分隔這些參數，比如 <code>&#123;&#123; amount | currency:'EUR':'Euros '&#125;&#125;</code>，也可以使用任何一個有效的模板表達式作為參數。</p>\n<p>有些 pipes 需要至少一個參數才可以使用，比如說 SlicePipe ，<code>&#123;&#123; slice:1:5 &#125;&#125;</code> 會創建一個新陣列或字串，其中包含從  element-1 開始到 element-5 結束的元素子集。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  sayHello = <span class=\"string\">&#x27;Hello world&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; sayHello | slice:1:5 &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767cAsa3R4sC4.png\"></p>\n<p>畫面中原本要呈現的 <code>Hello world</code>，變成了 ello ，是因為透過 slice 選擇了 index[1] ~ index[5] 的資料。</p>\n<h1 id=\"Creating-pipes-for-custom-data-transformations\"><a href=\"#Creating-pipes-for-custom-data-transformations\" class=\"headerlink\" title=\"Creating pipes for custom data transformations\"></a>Creating pipes for custom data transformations</h1><p>在開頭時提到了 Angular 有提供幾個預設的 pipes 可以使用，但這些不夠應付我們可能面面臨到的問題，這時候客製化 pipes 就很重要了，客製化的 pipes 也和預設的一樣，接收一個輸入將他轉換過後輸出，那麼就來看看該如何使用客製化 pipes 吧。</p>\n<h2 id=\"Marking-a-class-as-a-pipe\"><a href=\"#Marking-a-class-as-a-pipe\" class=\"headerlink\" title=\"Marking a class as a pipe\"></a>Marking a class as a pipe</h2><p>要建立一個客製化的 pipes，首先需要向建立 component 一樣先建立一個 typescript 的 class，但是不同的是，當我們創建 Component Class 時使用的裝飾器是 <code>@Component</code>，代表這個 Class 是屬於 Component 的，但是要建立 pipis class 則需要使用 <code>@Pipe</code> 這個裝飾器，而對這個 Class 的命名請使用 <code>駝峰命名法</code>，不要在名稱中間使用連字符號( - )，舉個例子吧，可以建立一個 pipes 接收一個數值作為輸入與一個參數，將輸入的數值做參數的次方，比如輸入 &#x3D; 2 參數 &#x3D; 10 那麼就會等於 2^10 &#x3D; 1024。</p>\n<ol>\n<li><p>使用 Angular CLI 建立一個 pipes class</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng generate pipe exponential-strength</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 exponential-strength.pipe.ts 中添加轉換 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Pipe</span>, <span class=\"title class_\">PipeTransform</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;exponentialStrength&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExponentialStrengthPipe</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">PipeTransform</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">transform</span>(<span class=\"attr\">value</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">exponent</span>: <span class=\"built_in\">number</span> = <span class=\"number\">1</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(value, exponent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你是使用 Angular CLI 他會自動將這個 pipes class 放到 app.module.ts 的 declarations 中，如果你是手動建立的話要記得將它放到 app.module.ts 的 declarations 裡面喔！</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">NgModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ExponentialStrengthPipe</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./exponential-strengh.pipe&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">declarations</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">AppComponent</span>,</span><br><span class=\"line\">    <span class=\"title class_\">ExponentialStrengthPipe</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在 app.component.html 中使用客製化的 pipe 轉換資料</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Power boost: &#123;&#123; 2 | exponentialStrength:10 &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767RueRFUir7N.png\"></p>\n<h1 id=\"Detecting-changes-with-data-binding-in-pipes\"><a href=\"#Detecting-changes-with-data-binding-in-pipes\" class=\"headerlink\" title=\"Detecting changes with data binding in pipes\"></a>Detecting changes with data binding in pipes</h1><p>還記得昨天提到的 Text interpolation 的特性嗎？他可以隨著 class 的 property 變化而動態的顯示，而這個動態變化也可以套用到 pipe 中，所以當客製化的 pipe 輸入是 <code>string</code> 或 <code>number</code> 時且發生改變時，會動態的作為輸入進到 pipe 中進行轉換，但如果是 <code>Date</code> 或 <code>Array</code> 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換，舉個例子吧</p>\n<ol>\n<li><p>在 app.component.ts 中定義兩個 property，一個代表要被轉換的值（輸入）另一個代表輸入要做幾次方</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styles</span>: [<span class=\"string\">&#x27;input &#123;margin: .5rem 0;&#125;&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  power = <span class=\"number\">2</span>;</span><br><span class=\"line\">  factor = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.module.ts 的 imports 中加入 <code>FormsModule</code> ，這個是因為要在這個例子中使用到 form，所以要加入這個（之後會詳細的介紹 form）</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">NgModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">BrowserModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppRoutingModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app-routing.module&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AppComponent</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./app.component&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">FormsModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ExponentialStrengthPipe</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./exponential-strengh.pipe&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@NgModule</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">declarations</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">AppComponent</span>,</span><br><span class=\"line\">    <span class=\"title class_\">ExponentialStrengthPipe</span>,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">imports</span>: [</span><br><span class=\"line\">    <span class=\"title class_\">BrowserModule</span>,</span><br><span class=\"line\">    <span class=\"title class_\">AppRoutingModule</span>,</span><br><span class=\"line\">    <span class=\"title class_\">FormsModule</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"attr\">providers</span>: [],</span><br><span class=\"line\">  <span class=\"attr\">bootstrap</span>: [<span class=\"title class_\">AppComponent</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppModule</span> &#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中使用 pipe</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Power Boost Calculator<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;power-input&quot;</span>&gt;</span>Normal power: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;power-input&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;power&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;boost-input&quot;</span>&gt;</span>Boost factor: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;boost-input&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;factor&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Super Hero Power: &#123;&#123; power | exponentialStrength: factor &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> 這邊可能會有疑問，<code>[(ngModel)]</code> 這個是什麼？這邊大概介紹一下，如果將 component 中的 property 使用 <code>[(ngModel)]</code> 綁定，代表當 user 在畫面中的 <code>&lt;input&gt;</code> 中改變數值時，他會同步改變到 Component 中的 property，當然如果你改 Component 中的 property 的數值一樣會同步更改到畫面 <code>&lt;input&gt;</code> 中的值，這稱為 <code>雙向綁定</code>，之後會詳細講解，這邊先有大概的概念就好。</p>\n</li>\n</ol>\n<p><img src=\"https://i.imgur.com/Y92boUn.gif\" alt=\"img\"></p>\n<p>在畫面中可以看到，當我們每次更改 factor 的值時，pipe 都會自動重新計算結果。</p>\n<h1 id=\"Detecting-pure-changes-to-primitives-and-object-references\"><a href=\"#Detecting-pure-changes-to-primitives-and-object-references\" class=\"headerlink\" title=\"Detecting pure changes to primitives and object references\"></a>Detecting pure changes to primitives and object references</h1><p>在上面提到 <code>如果是 </code>Date<code>或</code>Array<code> 類型時，Angular 會檢測到 reference 發生改變時才會觸發執行 pipe 的轉換</code> 這邊要來詳細的說明一下。</p>\n<p>在默認情況下 pipe 要被定義成 pure 的，以便 Angular 只有在檢測到輸入值變化時才執行 pipe ，所以必須要是沒有 side effect 的 pure function，而如果是將複合對象當作輸入送進 pipe （現有的 arr 添加新元素）時，因為檢查他的 reference 比深入到 arr 中遞迴的檢查每個元素快得多，所以 Angular 會通過檢查他的 reference 來判定是否發生改變，所以當你將一個 arr 作為輸入送進一個 pipe 時，可能會發生意料之外的錯誤，下面來句個例子：</p>\n<p>對了！如果是新手對 javascript 的 object reference 不熟悉的話，建議先去了解一下為什麼對 arr 使用 push 時不算對 reference 的改變，這也是為什麼使用 const 宣告 arr 卻可以對他新增內容的原因</p>\n<p>，我在 <a href=\"https://ithelp.ithome.com.tw/articles/10231666\">ES6 學習筆記_01(let &amp; const)</a>  中提到 const 的本質是什麼，有興趣可以去看一下。</p>\n<ol>\n<li><p>首先一樣先創建一個 pipe </p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Pipe</span>, <span class=\"title class_\">PipeTransform</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyingHeros&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlyingHerosPipe</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">PipeTransform</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">transform</span>(<span class=\"params\">allHeroes: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> allHeroes.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">hero: <span class=\"built_in\">any</span></span>) =&gt;</span> hero.<span class=\"property\">caFly</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.ts 中定義 Hero list</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Hero</span> = [</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">11</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr Nice&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">12</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Narco&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">13</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Bombasto&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">14</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Celeritas&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">15</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magneta&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">16</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;RubberMan&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">17</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dynama&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">18</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr IQ&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">19</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magma&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">id</span>: <span class=\"number\">20</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tornado&#x27;</span>,  <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中使用 pipe 將可以飛的英雄顯示出來</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let hero of ( heros | flyingHeros )&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;hero.name&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/201247677rVVugO8sm.png\"></p>\n<p>在畫面中可以看到只有會飛的英雄顯示出來，這時我們在 heros 中使用 push 新增英雄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onAddHero</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">heros</span>.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>當我將新的英雄 push 近 heros 中，卻發現畫面沒有更改，是壞掉了嗎？ 讓我們將 heros console 出來確認是否真的有將他 push 進去。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onAddHero</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">heros</span>.<span class=\"title function_\">push</span>(&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">heros</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210803/20124767DNrdyLkdv3.png\"></p>\n<p>在 console 中可以看到我們確實有將新英雄 push 進 heros 中，這就是剛剛提到的 Angular 在面對 arr 時，只有在他的 reference 發生改變時才會觸發 pipe，有興趣的可以自己嘗試一下，把 <code>onAddHero()</code> 變成</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">onAddHero</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">heros</span> = [</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">11</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr Nice&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">12</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Narco&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">13</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Bombasto&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">14</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Celeritas&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">15</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magneta&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">16</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;RubberMan&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">17</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dynama&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">18</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Dr IQ&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">19</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Magma&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">false</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">20</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Tornado&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Fandix&#x27;</span>, <span class=\"attr\">canFly</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>會發生什麼事。</p>\n<p>所以在使用者種複合型的資料時，需要特別注意<code>只有當輸入的 Reference 發生改變時，才會觸發 pipe </code>。</p>\n<h1 id=\"Detecting-impure-changes-within-composite-objects\"><a href=\"#Detecting-impure-changes-within-composite-objects\" class=\"headerlink\" title=\"Detecting impure changes within composite objects\"></a>Detecting impure changes within composite objects</h1><p>那你可能想說，我不要啊我天生反骨我就是想要使用 push 就可以觸發 pipe 可不可以？</p>\n<p>當然可以，Angular 提供了當複合數據內發生改變時也可以觸發 pipe 的方法，首先你<code>需要將這個 pipe 變得 impure</code>，這樣才可以檢測到 impure 的變化，所以 Angular 只要檢測到每次按鍵或滑鼠的變化時都會觸發一個 impure 的 pipe，要做的很簡單，只要在 pipe.ts 中增加一個屬性就可以了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pipe</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyingHeros&#x27;</span>, <span class=\"attr\">pure</span>: <span class=\"literal\">false</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>一樣有興趣的可以拿上面的例子直接將他變成 impure 試試看，這邊就不再做一次了。</p>\n<h1 id=\"Pipes-and-precedence\"><a href=\"#Pipes-and-precedence\" class=\"headerlink\" title=\"Pipes and precedence\"></a>Pipes and precedence</h1><p>介紹了這麼多的 pipe 用法，可能有人會問：既然 pipe 是透過 ｜ 加在數值後面的，那如果這個數值在進行其他的 Javascript expressions 怎麼辦？</p>\n<p>其實在 Angular 中 pipe 運算符的優先級是高於三元運算子（: ?），這意味著如果你有一個 Text interpolation 長這樣 <code>&#123;&#123; a ? b : c | x &#125;&#125;</code> ，那麼他會被解析成 <code>&#123;&#123; a ? b : (c | x) &#125;&#125;</code> 而這個結果可能不是你所希望的，如果你希望達到 <code>&#123;&#123; a ? b : c | x &#125;&#125;</code> 這個結果，請使用括號將前面的三元運算子括起來 <code>&#123;&#123; (a ? b : c) | x &#125;&#125;</code></p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本篇章中介紹了什麼是 pipe、該怎麼使用它以及客製化自己的 pipe，了解 pipe 對於開發專案是有幫助的，也要特別注意在預設情況下 pipe 是 pure 的，當傳入的輸入是複合型資料時，只有在他的 reference 發生改變時才會觸發，如果想要避免這個問題可以將 pipe 更改為 impure 就可以了。</p>\n<p>在官方文檔中還有介紹 <code>observable</code> 與 <code>HTTP</code> 的 pipe，但是因為牽扯到太多其他的技巧不太符合我們新手入門的領域，所以不在這邊介紹，不過了解了pipe 的基本原理之後，當遇到類似問題再去看就會比較容易看懂，所以就允許我偷懶一下吧</p>\n<p>下一篇會介紹 template 的 property binding，它的作用是可以讓你設置 HTML Tag 或 directive 的屬性質，詳細的介紹就期待明天吧。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/pipes\">Angular.io - pipes</a></li>\n</ul>"},{"title":"Day10. Property binding and Event binding","date":"2022-02-15T08:20:57.000Z","_content":"\n本篇中將介紹 Angular 的 `property binding` 與 `event binding`，property binding 可以讓你`設置 HTML Tag 或 directive 的屬性值`，可以利用 property binding 做到切換按鈕、以程式方式設置 url 路徑以及在各個 Component 之間共享數據等等。\n\n而 Event binding 則是可以`將事件綁定在 HTML 的元件上`，隨時監聽使用者的操作，例如按下按鍵、滑鼠移動、點擊以及觸摸，就先從 property binding 開始介紹吧。\n\n![img](https://bs-uploads.toptal.io/blackfish-uploads/components/blog_post_page/content/cover_image_file/cover_image/687521/retina_1708x683_cover-top-18-most-common-angularjs-developer-mistakes-41f9ad303a51db70e4a5204e101e7414.png)\n\n<!-- more -->\n\n# Binding to a property\n\n在 Angular 中的 property binding 會讓數據往一個方向流動，就是從 component 流向 HTML 的元件，而如果要將數據綁定到 HTML 元件請使用`方括號（ [ ] ）`將他括在其中，比如說可以將 `<img>`中的 `src` 屬性利用 property binding 綁定。\n\n```html\n<img [src]=\"itemImageUrl\">\n```\n\n在大多數形況下目標名稱就是屬性的名稱，所以以上面的例子來說，src 就是 `<img>` 元件的屬性名稱，而方括號會讓 Angular 將等號右邊評估為動態表達式，如果沒有括號 Angular 會將右側視為字串文字並將屬性設置為該靜態值。\n\n\n# Setting an element property to a component property value\n\n以上面的例子來說，如果要將 `<img>` 的屬性綁定到 Component 的 property，請將 src 放在方括號中，後面加上等號與 component 的 property 名稱。\n\n```html\n<img [src]=\"itemImageUrl\">\n```\n\n這時就可以在 Component 中定義一個 property 並將他賦值，那麼這個值就會綁定到 HTML 的元件上\n\n```typescript\nitemImageUrl: '../assets/phone.png'\n```\n\n\n# Toggling button functionality\n\n在 `<button>` 這個 HTML 中有一個屬性可以控制是否可以點擊這個按鈕那就是 `disabled`，我們可以透過 property binding 將這個屬性綁定到 component 的 property，建立一個動態改變他狀態的功能，一樣來舉個例子吧：\n\n1. 在 app.component.ts 中新增一個 property 用來綁定 `<button>` 與一個 method 用來更改 property 的值\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n    })\n    export class AppComponent {\n      isUnchanged = true;\n\n      onButtonChange() {\n        this.isUnchanged = !this.isUnchanged;\n      }\n    }\n    ```\n\n2. 在 app.component.html 中新增兩個 `<button>` 一個用來做 property binding 另一個用來改變 property 的內容\n\n    ```html\n    <!-- app.component.html -->\n\n    <div style=\"margin-bottom: 10px;\">\n      <button [disabled]=\"isUnchanged\">Property binding</button>\n    </div>\n\n    <button (click)=\"onButtonChange()\">Change Property value</button>\n    ```\n\n\n在畫面中可以看到，當我們點擊 `Change Property value` 時，他將 Component 中的 isUnchanged 內容更改，所以讓 `Property binding` 這個 `<button>` 可以動態被 disable 與 enable。\n\n\n\n# Bind values between components\n\n在前幾天介紹 @Input() 時常常在用到的 `<app-child-component [item]=\"currentItem\"></app-child-component>` 其實就是 property binding，將父層 component 中的 property 綁定給子層，當父層 Component 的這個 property 發生改變時，因為綁定的關係所以會將這個改變也帶給子層，\n\n這邊再稍微複習一下該怎麼使用 @Input() 吧![/images/emoticon/emoticon05.gif](/images/emoticon/emoticon05.gif)\n\n1. 先 parent.component.ts 中定義一個 property 並將他賦值\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-parent-component',\n      templateUrl: './parent.component.html'\n    })\n    export class ParentComponent {\n      constructor() { }\n      currentItem = 'Television';  // defind a property\n    }\n    ```\n\n2. 在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層\n\n    ```html\n    <app-child-component [item]=\"currentItem\"></app-child-component>\n    ```\n\n3. 在 child.component.ts 中使用 @Input( ) 裝飾器將 property 裝飾為是從父層傳下來的\n\n    ```typescript\n    import { Component, Input } from '@angular/core'; \n\n    @Component({\n      selector: 'app-child-component',\n      templateUrl: './child.component.html'\n    })\n    export class ChildComponent {\n      @Input() item = '';\n      constructor() { }\n    }\n    ```\n\n4. 在 child.component.html 中使用 Text interpolation 將他呈現在畫面上\n\n    ```html\n    <div>Today's item: {{ item }}</div>\n    ```\n    \n當初在介紹 @Input() 時還有很多技巧沒有講到（property binding、test interpolation）現在在重複看一次之前的例子有沒有比較可以把前幾章的內容串起來了呢。\n\n\n\n# Property binding and security\n\n既然 property binding 這麼好用，那有沒有什麼問題或是缺點呢？來看看下面的例子\n\n```typescript\nevilTitle = 'Template <script>alert(\"evil never sleeps\")</script> Syntax';\n```\n\n當我在一個 component 中添加一個屬性，並將這個屬性裡面多加了 `<script>`，在這個裡面放了一些會危害到你專案的 javascript 程式，那麼會發生什麼事？\n\n其實不會發生上面說的會危害到你專案的情況發生，因為 Angular 在 property binding 中有做一個限制，`不允許帶有 <script> 標籤的 HTML 元件，也不允許帶有插值和屬性綁定`，所以將上面那個 property 差值到你的 HTML file 中時，會有下面的 error message\n\n```bash\n\"Template <script>alert(\"evil never sleeps\")</script> Syntax\" is the interpolated evil title.\n```\n\n這是 Angular 對 property binding 做的安全機制。\n\n\n\n# Property binding and interpolation\n\n可能有人會問拉：property binding 與 text interpolation 都是將 component 中的 property 綁定在 HTML file 中，那們他們有什麼不一樣嗎？\n\n其實這個問題非常好，他們兩個理論上可以達到相同的目的\n\n```html\n<p>\n  <img src=\"{{itemImageUrl}}\"> is the <i>interpolated</i> image.\n</p>\n<p>\n  <img [src]=\"itemImageUrl\"> is the <i>property bound</i> image.\n</p>\n```\n\n上面這兩個的結果會是一樣的，無論是透過 text interpolation 將 property 插進 `<img>` 的 src 屬性，還是利用 proprety binding 住 `<img>` 的 src 屬性都是可以將 component 的 property 放進我們想放的位置。\n\n雖然兩個都可以達到目的，所以`當在將數據值呈現為字串時可以使用兩種方法的其中一種`，但為了可讀性更傾向於使用 text interpolation，但是當將元素屬性設置為`非字串數值`時，就必須使用屬性綁定，比如上面提到的 `<button>` 的 disabled 屬性。\n\n\n\n# Binding to events\n\n介紹完 property binding 後，接著要來介紹 event binding，顧名思義他就是將 event 綁定到 HTML 的元件上用於監聽使用這的操作，event binding 的語法是將`目標事件名稱放在等號左邊的括弧中`和將`引號的模板語句` 放在右側，舉個例子吧，當畫面中的一個按鈕被點擊到時，要觸發 component 中的 onSave() method，這時就可以這樣寫\n\n```html\n<button (click)=\"onSave()\">Save</button>\n```\n\n![https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png](https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png)\n\n如果你的 method 是帶有參數的，只要再等號右邊的 method 的括號中填入參數即可\n\n```html\n<button (click)=\"onSave(data)\">Save</button>\n```\n\n\n\n# Custom events with EventEmitter\n\n還記得在前幾天中介紹的 @Output() 嗎？來複習一下吧， @Output() 的用意是將子層的內容透過一個 event 往上傳遞給父層，一樣舉個子來回憶一下吧\n\n1. 在 child.component.ts 中加入一個 property 並將他使用 @Output() 裝飾成 EventEmitter 型態\n\n    ```typescript\n    import { Component, Output, EventEmitter } from '@angular/core'; \n\n    @Component({\n      selector: 'app-child-component',\n      templateUrl: './child.component.html',\n      styleUrls: ['./child.component.css']\n    })\n    export class ChildComponent {\n      @Output() newItemEvent = new EventEmitter<boolean>();  // (2)\n      constructor() { }\n\n      parentValueChange(value: boolean) { \n        this.newItemEvent.emit(value);\n      }\n    }\n    ```\n\n2.  在 child.component.html 中新增兩個 `<button>` 用來讓 user 點擊觸發 event\n\n    ```html\n    <!-- child.component.html  -->\n    <p>child component works!</p>\n\n    <div class=\"button\">\n        <button (click)=\"parentValueChange(true)\">+</button>\n        <button (click)=\"parentValueChange(false)\">-</button>\n    </div>\n    ```\n\n3. 在 parent.component.ts 中添加一個 method，用來處理當子層傳送的數據\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-parent-component',\n      templateUrl: './parent.component.html'\n    })\n    export class ParentComponent {\n      constructor() { }\n      counterValue = 0;\n\n      addOrSub(event: boolean) { \n        if (event) {\n          this.counterValue++;\n        } else {\n          this.counterValue--;\n        }\n      }\n    }\n    ```\n\n4. 在 parent.component.html 中使用 event binding 將子層傳送的事件與 parent.component.ts 的 method 綁定\n\n    ```html\n    <!-- parent.component.html -->\n    <p>parent component works!</p>\n    <div>parent component property counter: {{counterValue}}</div>\n\n    <hr>\n    <app-child-component (newItemEvent)=\"addOrSub($event)\"></app-child-component>\n    ```\n\n在介紹完 event binding 後再回來看這個例子，有沒有更能夠了解如何使用 @Output() 與 evebt binding 了呢？\n\n\n\n# Determining an event target\n\n在使用 Event binding 時，Angular 會檢查 event target 的名稱是否與已知指令事件屬性匹配，比如說\n\n```html\n<button (myClick)=\"clickMessage=$event\" clickable>click with myClick</button>\n```\n\n你使用了一個自訂義的 `(myClick)` 作爲 event target 時，因為他不符合已知指令事件屬性，所以 Angular 會傳出 `unknown directive` 的錯誤訊息，所以在使用 event binding 時要記得使用正確的 event target 喔！\n\n\n\n# 結論\n\n在本章中介紹了兩種 binding，property binding 是用於將 component 中的 property 綁定給 HTML 中的元件，常用在將父層的 property 綁定給子層、將比較複雜或是需要邏輯計算的 HTML 元件屬性放到 component 中計算後再放回等等。\n\n而 event binding 是將 component 中的 method 綁定到 HTML 的元件上用於監聽使用者的操作，常用再處理使用者使用者操作畫面而處發的事件、將子層透過 EventEmitter 往父層傳遞數據時的綁定。\n\n下一章將會介紹另外兩種 binding 方法，分別是 Attrubute, class, strle binding 與 Two-way binding， Attrubute, class, strle binding 顧名思義就是將 component 中的 property 綁定到 HTML 的 class 或 attrubute，而 Two-way binding 則是可以讓父子層之間只使用一個 binding 就可以同時監聽事件與更新值，不需要使用 property binding 和 event binding。\n\n\n\n# Reference\n- [Angular.io - property binding](https://angular.io/guide/property-binding)\n- [Angular.io - event binding](https://angular.io/guide/event-binding)","source":"_posts/Angular/angular-10.md","raw":"---\ntitle: Day10. Property binding and Event binding\ndate: 2022-02-15 16:20:57\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n本篇中將介紹 Angular 的 `property binding` 與 `event binding`，property binding 可以讓你`設置 HTML Tag 或 directive 的屬性值`，可以利用 property binding 做到切換按鈕、以程式方式設置 url 路徑以及在各個 Component 之間共享數據等等。\n\n而 Event binding 則是可以`將事件綁定在 HTML 的元件上`，隨時監聽使用者的操作，例如按下按鍵、滑鼠移動、點擊以及觸摸，就先從 property binding 開始介紹吧。\n\n![img](https://bs-uploads.toptal.io/blackfish-uploads/components/blog_post_page/content/cover_image_file/cover_image/687521/retina_1708x683_cover-top-18-most-common-angularjs-developer-mistakes-41f9ad303a51db70e4a5204e101e7414.png)\n\n<!-- more -->\n\n# Binding to a property\n\n在 Angular 中的 property binding 會讓數據往一個方向流動，就是從 component 流向 HTML 的元件，而如果要將數據綁定到 HTML 元件請使用`方括號（ [ ] ）`將他括在其中，比如說可以將 `<img>`中的 `src` 屬性利用 property binding 綁定。\n\n```html\n<img [src]=\"itemImageUrl\">\n```\n\n在大多數形況下目標名稱就是屬性的名稱，所以以上面的例子來說，src 就是 `<img>` 元件的屬性名稱，而方括號會讓 Angular 將等號右邊評估為動態表達式，如果沒有括號 Angular 會將右側視為字串文字並將屬性設置為該靜態值。\n\n\n# Setting an element property to a component property value\n\n以上面的例子來說，如果要將 `<img>` 的屬性綁定到 Component 的 property，請將 src 放在方括號中，後面加上等號與 component 的 property 名稱。\n\n```html\n<img [src]=\"itemImageUrl\">\n```\n\n這時就可以在 Component 中定義一個 property 並將他賦值，那麼這個值就會綁定到 HTML 的元件上\n\n```typescript\nitemImageUrl: '../assets/phone.png'\n```\n\n\n# Toggling button functionality\n\n在 `<button>` 這個 HTML 中有一個屬性可以控制是否可以點擊這個按鈕那就是 `disabled`，我們可以透過 property binding 將這個屬性綁定到 component 的 property，建立一個動態改變他狀態的功能，一樣來舉個例子吧：\n\n1. 在 app.component.ts 中新增一個 property 用來綁定 `<button>` 與一個 method 用來更改 property 的值\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n    })\n    export class AppComponent {\n      isUnchanged = true;\n\n      onButtonChange() {\n        this.isUnchanged = !this.isUnchanged;\n      }\n    }\n    ```\n\n2. 在 app.component.html 中新增兩個 `<button>` 一個用來做 property binding 另一個用來改變 property 的內容\n\n    ```html\n    <!-- app.component.html -->\n\n    <div style=\"margin-bottom: 10px;\">\n      <button [disabled]=\"isUnchanged\">Property binding</button>\n    </div>\n\n    <button (click)=\"onButtonChange()\">Change Property value</button>\n    ```\n\n\n在畫面中可以看到，當我們點擊 `Change Property value` 時，他將 Component 中的 isUnchanged 內容更改，所以讓 `Property binding` 這個 `<button>` 可以動態被 disable 與 enable。\n\n\n\n# Bind values between components\n\n在前幾天介紹 @Input() 時常常在用到的 `<app-child-component [item]=\"currentItem\"></app-child-component>` 其實就是 property binding，將父層 component 中的 property 綁定給子層，當父層 Component 的這個 property 發生改變時，因為綁定的關係所以會將這個改變也帶給子層，\n\n這邊再稍微複習一下該怎麼使用 @Input() 吧![/images/emoticon/emoticon05.gif](/images/emoticon/emoticon05.gif)\n\n1. 先 parent.component.ts 中定義一個 property 並將他賦值\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-parent-component',\n      templateUrl: './parent.component.html'\n    })\n    export class ParentComponent {\n      constructor() { }\n      currentItem = 'Television';  // defind a property\n    }\n    ```\n\n2. 在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層\n\n    ```html\n    <app-child-component [item]=\"currentItem\"></app-child-component>\n    ```\n\n3. 在 child.component.ts 中使用 @Input( ) 裝飾器將 property 裝飾為是從父層傳下來的\n\n    ```typescript\n    import { Component, Input } from '@angular/core'; \n\n    @Component({\n      selector: 'app-child-component',\n      templateUrl: './child.component.html'\n    })\n    export class ChildComponent {\n      @Input() item = '';\n      constructor() { }\n    }\n    ```\n\n4. 在 child.component.html 中使用 Text interpolation 將他呈現在畫面上\n\n    ```html\n    <div>Today's item: {{ item }}</div>\n    ```\n    \n當初在介紹 @Input() 時還有很多技巧沒有講到（property binding、test interpolation）現在在重複看一次之前的例子有沒有比較可以把前幾章的內容串起來了呢。\n\n\n\n# Property binding and security\n\n既然 property binding 這麼好用，那有沒有什麼問題或是缺點呢？來看看下面的例子\n\n```typescript\nevilTitle = 'Template <script>alert(\"evil never sleeps\")</script> Syntax';\n```\n\n當我在一個 component 中添加一個屬性，並將這個屬性裡面多加了 `<script>`，在這個裡面放了一些會危害到你專案的 javascript 程式，那麼會發生什麼事？\n\n其實不會發生上面說的會危害到你專案的情況發生，因為 Angular 在 property binding 中有做一個限制，`不允許帶有 <script> 標籤的 HTML 元件，也不允許帶有插值和屬性綁定`，所以將上面那個 property 差值到你的 HTML file 中時，會有下面的 error message\n\n```bash\n\"Template <script>alert(\"evil never sleeps\")</script> Syntax\" is the interpolated evil title.\n```\n\n這是 Angular 對 property binding 做的安全機制。\n\n\n\n# Property binding and interpolation\n\n可能有人會問拉：property binding 與 text interpolation 都是將 component 中的 property 綁定在 HTML file 中，那們他們有什麼不一樣嗎？\n\n其實這個問題非常好，他們兩個理論上可以達到相同的目的\n\n```html\n<p>\n  <img src=\"{{itemImageUrl}}\"> is the <i>interpolated</i> image.\n</p>\n<p>\n  <img [src]=\"itemImageUrl\"> is the <i>property bound</i> image.\n</p>\n```\n\n上面這兩個的結果會是一樣的，無論是透過 text interpolation 將 property 插進 `<img>` 的 src 屬性，還是利用 proprety binding 住 `<img>` 的 src 屬性都是可以將 component 的 property 放進我們想放的位置。\n\n雖然兩個都可以達到目的，所以`當在將數據值呈現為字串時可以使用兩種方法的其中一種`，但為了可讀性更傾向於使用 text interpolation，但是當將元素屬性設置為`非字串數值`時，就必須使用屬性綁定，比如上面提到的 `<button>` 的 disabled 屬性。\n\n\n\n# Binding to events\n\n介紹完 property binding 後，接著要來介紹 event binding，顧名思義他就是將 event 綁定到 HTML 的元件上用於監聽使用這的操作，event binding 的語法是將`目標事件名稱放在等號左邊的括弧中`和將`引號的模板語句` 放在右側，舉個例子吧，當畫面中的一個按鈕被點擊到時，要觸發 component 中的 onSave() method，這時就可以這樣寫\n\n```html\n<button (click)=\"onSave()\">Save</button>\n```\n\n![https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png](https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png)\n\n如果你的 method 是帶有參數的，只要再等號右邊的 method 的括號中填入參數即可\n\n```html\n<button (click)=\"onSave(data)\">Save</button>\n```\n\n\n\n# Custom events with EventEmitter\n\n還記得在前幾天中介紹的 @Output() 嗎？來複習一下吧， @Output() 的用意是將子層的內容透過一個 event 往上傳遞給父層，一樣舉個子來回憶一下吧\n\n1. 在 child.component.ts 中加入一個 property 並將他使用 @Output() 裝飾成 EventEmitter 型態\n\n    ```typescript\n    import { Component, Output, EventEmitter } from '@angular/core'; \n\n    @Component({\n      selector: 'app-child-component',\n      templateUrl: './child.component.html',\n      styleUrls: ['./child.component.css']\n    })\n    export class ChildComponent {\n      @Output() newItemEvent = new EventEmitter<boolean>();  // (2)\n      constructor() { }\n\n      parentValueChange(value: boolean) { \n        this.newItemEvent.emit(value);\n      }\n    }\n    ```\n\n2.  在 child.component.html 中新增兩個 `<button>` 用來讓 user 點擊觸發 event\n\n    ```html\n    <!-- child.component.html  -->\n    <p>child component works!</p>\n\n    <div class=\"button\">\n        <button (click)=\"parentValueChange(true)\">+</button>\n        <button (click)=\"parentValueChange(false)\">-</button>\n    </div>\n    ```\n\n3. 在 parent.component.ts 中添加一個 method，用來處理當子層傳送的數據\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-parent-component',\n      templateUrl: './parent.component.html'\n    })\n    export class ParentComponent {\n      constructor() { }\n      counterValue = 0;\n\n      addOrSub(event: boolean) { \n        if (event) {\n          this.counterValue++;\n        } else {\n          this.counterValue--;\n        }\n      }\n    }\n    ```\n\n4. 在 parent.component.html 中使用 event binding 將子層傳送的事件與 parent.component.ts 的 method 綁定\n\n    ```html\n    <!-- parent.component.html -->\n    <p>parent component works!</p>\n    <div>parent component property counter: {{counterValue}}</div>\n\n    <hr>\n    <app-child-component (newItemEvent)=\"addOrSub($event)\"></app-child-component>\n    ```\n\n在介紹完 event binding 後再回來看這個例子，有沒有更能夠了解如何使用 @Output() 與 evebt binding 了呢？\n\n\n\n# Determining an event target\n\n在使用 Event binding 時，Angular 會檢查 event target 的名稱是否與已知指令事件屬性匹配，比如說\n\n```html\n<button (myClick)=\"clickMessage=$event\" clickable>click with myClick</button>\n```\n\n你使用了一個自訂義的 `(myClick)` 作爲 event target 時，因為他不符合已知指令事件屬性，所以 Angular 會傳出 `unknown directive` 的錯誤訊息，所以在使用 event binding 時要記得使用正確的 event target 喔！\n\n\n\n# 結論\n\n在本章中介紹了兩種 binding，property binding 是用於將 component 中的 property 綁定給 HTML 中的元件，常用在將父層的 property 綁定給子層、將比較複雜或是需要邏輯計算的 HTML 元件屬性放到 component 中計算後再放回等等。\n\n而 event binding 是將 component 中的 method 綁定到 HTML 的元件上用於監聽使用者的操作，常用再處理使用者使用者操作畫面而處發的事件、將子層透過 EventEmitter 往父層傳遞數據時的綁定。\n\n下一章將會介紹另外兩種 binding 方法，分別是 Attrubute, class, strle binding 與 Two-way binding， Attrubute, class, strle binding 顧名思義就是將 component 中的 property 綁定到 HTML 的 class 或 attrubute，而 Two-way binding 則是可以讓父子層之間只使用一個 binding 就可以同時監聽事件與更新值，不需要使用 property binding 和 event binding。\n\n\n\n# Reference\n- [Angular.io - property binding](https://angular.io/guide/property-binding)\n- [Angular.io - event binding](https://angular.io/guide/event-binding)","slug":"Angular/angular-10","published":1,"updated":"2022-02-15T10:12:15.197Z","_id":"ckznuvv3o001hkww3bs3y8xyp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本篇中將介紹 Angular 的 <code>property binding</code> 與 <code>event binding</code>，property binding 可以讓你<code>設置 HTML Tag 或 directive 的屬性值</code>，可以利用 property binding 做到切換按鈕、以程式方式設置 url 路徑以及在各個 Component 之間共享數據等等。</p>\n<p>而 Event binding 則是可以<code>將事件綁定在 HTML 的元件上</code>，隨時監聽使用者的操作，例如按下按鍵、滑鼠移動、點擊以及觸摸，就先從 property binding 開始介紹吧。</p>\n<p><img src=\"https://bs-uploads.toptal.io/blackfish-uploads/components/blog_post_page/content/cover_image_file/cover_image/687521/retina_1708x683_cover-top-18-most-common-angularjs-developer-mistakes-41f9ad303a51db70e4a5204e101e7414.png\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Binding-to-a-property\"><a href=\"#Binding-to-a-property\" class=\"headerlink\" title=\"Binding to a property\"></a>Binding to a property</h1><p>在 Angular 中的 property binding 會讓數據往一個方向流動，就是從 component 流向 HTML 的元件，而如果要將數據綁定到 HTML 元件請使用<code>方括號（ [ ] ）</code>將他括在其中，比如說可以將 <code>&lt;img&gt;</code>中的 <code>src</code> 屬性利用 property binding 綁定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> [<span class=\"attr\">src</span>]=<span class=\"string\">&quot;itemImageUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在大多數形況下目標名稱就是屬性的名稱，所以以上面的例子來說，src 就是 <code>&lt;img&gt;</code> 元件的屬性名稱，而方括號會讓 Angular 將等號右邊評估為動態表達式，如果沒有括號 Angular 會將右側視為字串文字並將屬性設置為該靜態值。</p>\n<h1 id=\"Setting-an-element-property-to-a-component-property-value\"><a href=\"#Setting-an-element-property-to-a-component-property-value\" class=\"headerlink\" title=\"Setting an element property to a component property value\"></a>Setting an element property to a component property value</h1><p>以上面的例子來說，如果要將 <code>&lt;img&gt;</code> 的屬性綁定到 Component 的 property，請將 src 放在方括號中，後面加上等號與 component 的 property 名稱。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> [<span class=\"attr\">src</span>]=<span class=\"string\">&quot;itemImageUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>這時就可以在 Component 中定義一個 property 並將他賦值，那麼這個值就會綁定到 HTML 的元件上</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">itemImageUrl</span>: <span class=\"string\">&#x27;../assets/phone.png&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Toggling-button-functionality\"><a href=\"#Toggling-button-functionality\" class=\"headerlink\" title=\"Toggling button functionality\"></a>Toggling button functionality</h1><p>在 <code>&lt;button&gt;</code> 這個 HTML 中有一個屬性可以控制是否可以點擊這個按鈕那就是 <code>disabled</code>，我們可以透過 property binding 將這個屬性綁定到 component 的 property，建立一個動態改變他狀態的功能，一樣來舉個例子吧：</p>\n<ol>\n<li><p>在 app.component.ts 中新增一個 property 用來綁定 <code>&lt;button&gt;</code> 與一個 method 用來更改 property 的值</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  isUnchanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onButtonChange</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">isUnchanged</span> = !<span class=\"variable language_\">this</span>.<span class=\"property\">isUnchanged</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中新增兩個 <code>&lt;button&gt;</code> 一個用來做 property binding 另一個用來改變 property 的內容</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-bottom: 10px;&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> [<span class=\"attr\">disabled</span>]=<span class=\"string\">&quot;isUnchanged&quot;</span>&gt;</span>Property binding<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;onButtonChange()&quot;</span>&gt;</span>Change Property value<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>在畫面中可以看到，當我們點擊 <code>Change Property value</code> 時，他將 Component 中的 isUnchanged 內容更改，所以讓 <code>Property binding</code> 這個 <code>&lt;button&gt;</code> 可以動態被 disable 與 enable。</p>\n<h1 id=\"Bind-values-between-components\"><a href=\"#Bind-values-between-components\" class=\"headerlink\" title=\"Bind values between components\"></a>Bind values between components</h1><p>在前幾天介紹 @Input() 時常常在用到的 <code>&lt;app-child-component [item]=&quot;currentItem&quot;&gt;&lt;/app-child-component&gt;</code> 其實就是 property binding，將父層 component 中的 property 綁定給子層，當父層 Component 的這個 property 發生改變時，因為綁定的關係所以會將這個改變也帶給子層，</p>\n<p>這邊再稍微複習一下該怎麼使用 @Input() 吧<img src=\"/images/emoticon/emoticon05.gif\" alt=\"/images/emoticon/emoticon05.gif\"></p>\n<ol>\n<li><p>先 parent.component.ts 中定義一個 property 並將他賦值</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  currentItem = <span class=\"string\">&#x27;Television&#x27;</span>;  <span class=\"comment\">// defind a property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> [<span class=\"attr\">item</span>]=<span class=\"string\">&quot;currentItem&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 child.component.ts 中使用 @Input( ) 裝飾器將 property 裝飾為是從父層傳下來的</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() item = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 child.component.html 中使用 Text interpolation 將他呈現在畫面上</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Today&#x27;s item: &#123;&#123; item &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>當初在介紹 @Input() 時還有很多技巧沒有講到（property binding、test interpolation）現在在重複看一次之前的例子有沒有比較可以把前幾章的內容串起來了呢。</p>\n<h1 id=\"Property-binding-and-security\"><a href=\"#Property-binding-and-security\" class=\"headerlink\" title=\"Property binding and security\"></a>Property binding and security</h1><p>既然 property binding 這麼好用，那有沒有什麼問題或是缺點呢？來看看下面的例子</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evilTitle = <span class=\"string\">&#x27;Template &lt;script&gt;alert(&quot;evil never sleeps&quot;)&lt;/script&gt; Syntax&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>當我在一個 component 中添加一個屬性，並將這個屬性裡面多加了 <code>&lt;script&gt;</code>，在這個裡面放了一些會危害到你專案的 javascript 程式，那麼會發生什麼事？</p>\n<p>其實不會發生上面說的會危害到你專案的情況發生，因為 Angular 在 property binding 中有做一個限制，<code>不允許帶有 &lt;script&gt; 標籤的 HTML 元件，也不允許帶有插值和屬性綁定</code>，所以將上面那個 property 差值到你的 HTML file 中時，會有下面的 error message</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Template &lt;script&gt;alert(&quot;</span>evil never sleeps<span class=\"string\">&quot;)&lt;/script&gt; Syntax&quot;</span> is the interpolated evil title.</span><br></pre></td></tr></table></figure>\n\n<p>這是 Angular 對 property binding 做的安全機制。</p>\n<h1 id=\"Property-binding-and-interpolation\"><a href=\"#Property-binding-and-interpolation\" class=\"headerlink\" title=\"Property binding and interpolation\"></a>Property binding and interpolation</h1><p>可能有人會問拉：property binding 與 text interpolation 都是將 component 中的 property 綁定在 HTML file 中，那們他們有什麼不一樣嗎？</p>\n<p>其實這個問題非常好，他們兩個理論上可以達到相同的目的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123;itemImageUrl&#125;&#125;&quot;</span>&gt;</span> is the <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>interpolated<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span> image.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> [<span class=\"attr\">src</span>]=<span class=\"string\">&quot;itemImageUrl&quot;</span>&gt;</span> is the <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>property bound<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span> image.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面這兩個的結果會是一樣的，無論是透過 text interpolation 將 property 插進 <code>&lt;img&gt;</code> 的 src 屬性，還是利用 proprety binding 住 <code>&lt;img&gt;</code> 的 src 屬性都是可以將 component 的 property 放進我們想放的位置。</p>\n<p>雖然兩個都可以達到目的，所以<code>當在將數據值呈現為字串時可以使用兩種方法的其中一種</code>，但為了可讀性更傾向於使用 text interpolation，但是當將元素屬性設置為<code>非字串數值</code>時，就必須使用屬性綁定，比如上面提到的 <code>&lt;button&gt;</code> 的 disabled 屬性。</p>\n<h1 id=\"Binding-to-events\"><a href=\"#Binding-to-events\" class=\"headerlink\" title=\"Binding to events\"></a>Binding to events</h1><p>介紹完 property binding 後，接著要來介紹 event binding，顧名思義他就是將 event 綁定到 HTML 的元件上用於監聽使用這的操作，event binding 的語法是將<code>目標事件名稱放在等號左邊的括弧中</code>和將<code>引號的模板語句</code> 放在右側，舉個例子吧，當畫面中的一個按鈕被點擊到時，要觸發 component 中的 onSave() method，這時就可以這樣寫</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;onSave()&quot;</span>&gt;</span>Save<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png\" alt=\"https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png\"></p>\n<p>如果你的 method 是帶有參數的，只要再等號右邊的 method 的括號中填入參數即可</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;onSave(data)&quot;</span>&gt;</span>Save<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Custom-events-with-EventEmitter\"><a href=\"#Custom-events-with-EventEmitter\" class=\"headerlink\" title=\"Custom events with EventEmitter\"></a>Custom events with EventEmitter</h1><p>還記得在前幾天中介紹的 @Output() 嗎？來複習一下吧， @Output() 的用意是將子層的內容透過一個 event 往上傳遞給父層，一樣舉個子來回憶一下吧</p>\n<ol>\n<li><p>在 child.component.ts 中加入一個 property 並將他使用 @Output() 裝飾成 EventEmitter 型態</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Output</span>() newItemEvent = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;<span class=\"built_in\">boolean</span>&gt;();  <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">parentValueChange</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">newItemEvent</span>.<span class=\"title function_\">emit</span>(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 child.component.html 中新增兩個 <code>&lt;button&gt;</code> 用來讓 user 點擊觸發 event</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- child.component.html  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>child component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(true)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(false)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.ts 中添加一個 method，用來處理當子層傳送的數據</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  counterValue = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addOrSub</span>(<span class=\"params\">event: <span class=\"built_in\">boolean</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.html 中使用 event binding 將子層傳送的事件與 parent.component.ts 的 method 綁定</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>parent component property counter: &#123;&#123;counterValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> (<span class=\"attr\">newItemEvent</span>)=<span class=\"string\">&quot;addOrSub($event)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>在介紹完 event binding 後再回來看這個例子，有沒有更能夠了解如何使用 @Output() 與 evebt binding 了呢？</p>\n<h1 id=\"Determining-an-event-target\"><a href=\"#Determining-an-event-target\" class=\"headerlink\" title=\"Determining an event target\"></a>Determining an event target</h1><p>在使用 Event binding 時，Angular 會檢查 event target 的名稱是否與已知指令事件屬性匹配，比如說</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">myClick</span>)=<span class=\"string\">&quot;clickMessage=$event&quot;</span> <span class=\"attr\">clickable</span>&gt;</span>click with myClick<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>你使用了一個自訂義的 <code>(myClick)</code> 作爲 event target 時，因為他不符合已知指令事件屬性，所以 Angular 會傳出 <code>unknown directive</code> 的錯誤訊息，所以在使用 event binding 時要記得使用正確的 event target 喔！</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本章中介紹了兩種 binding，property binding 是用於將 component 中的 property 綁定給 HTML 中的元件，常用在將父層的 property 綁定給子層、將比較複雜或是需要邏輯計算的 HTML 元件屬性放到 component 中計算後再放回等等。</p>\n<p>而 event binding 是將 component 中的 method 綁定到 HTML 的元件上用於監聽使用者的操作，常用再處理使用者使用者操作畫面而處發的事件、將子層透過 EventEmitter 往父層傳遞數據時的綁定。</p>\n<p>下一章將會介紹另外兩種 binding 方法，分別是 Attrubute, class, strle binding 與 Two-way binding， Attrubute, class, strle binding 顧名思義就是將 component 中的 property 綁定到 HTML 的 class 或 attrubute，而 Two-way binding 則是可以讓父子層之間只使用一個 binding 就可以同時監聽事件與更新值，不需要使用 property binding 和 event binding。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/property-binding\">Angular.io - property binding</a></li>\n<li><a href=\"https://angular.io/guide/event-binding\">Angular.io - event binding</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本篇中將介紹 Angular 的 <code>property binding</code> 與 <code>event binding</code>，property binding 可以讓你<code>設置 HTML Tag 或 directive 的屬性值</code>，可以利用 property binding 做到切換按鈕、以程式方式設置 url 路徑以及在各個 Component 之間共享數據等等。</p>\n<p>而 Event binding 則是可以<code>將事件綁定在 HTML 的元件上</code>，隨時監聽使用者的操作，例如按下按鍵、滑鼠移動、點擊以及觸摸，就先從 property binding 開始介紹吧。</p>\n<p><img src=\"https://bs-uploads.toptal.io/blackfish-uploads/components/blog_post_page/content/cover_image_file/cover_image/687521/retina_1708x683_cover-top-18-most-common-angularjs-developer-mistakes-41f9ad303a51db70e4a5204e101e7414.png\" alt=\"img\"></p>","more":"<h1 id=\"Binding-to-a-property\"><a href=\"#Binding-to-a-property\" class=\"headerlink\" title=\"Binding to a property\"></a>Binding to a property</h1><p>在 Angular 中的 property binding 會讓數據往一個方向流動，就是從 component 流向 HTML 的元件，而如果要將數據綁定到 HTML 元件請使用<code>方括號（ [ ] ）</code>將他括在其中，比如說可以將 <code>&lt;img&gt;</code>中的 <code>src</code> 屬性利用 property binding 綁定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> [<span class=\"attr\">src</span>]=<span class=\"string\">&quot;itemImageUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在大多數形況下目標名稱就是屬性的名稱，所以以上面的例子來說，src 就是 <code>&lt;img&gt;</code> 元件的屬性名稱，而方括號會讓 Angular 將等號右邊評估為動態表達式，如果沒有括號 Angular 會將右側視為字串文字並將屬性設置為該靜態值。</p>\n<h1 id=\"Setting-an-element-property-to-a-component-property-value\"><a href=\"#Setting-an-element-property-to-a-component-property-value\" class=\"headerlink\" title=\"Setting an element property to a component property value\"></a>Setting an element property to a component property value</h1><p>以上面的例子來說，如果要將 <code>&lt;img&gt;</code> 的屬性綁定到 Component 的 property，請將 src 放在方括號中，後面加上等號與 component 的 property 名稱。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> [<span class=\"attr\">src</span>]=<span class=\"string\">&quot;itemImageUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>這時就可以在 Component 中定義一個 property 並將他賦值，那麼這個值就會綁定到 HTML 的元件上</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">itemImageUrl</span>: <span class=\"string\">&#x27;../assets/phone.png&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Toggling-button-functionality\"><a href=\"#Toggling-button-functionality\" class=\"headerlink\" title=\"Toggling button functionality\"></a>Toggling button functionality</h1><p>在 <code>&lt;button&gt;</code> 這個 HTML 中有一個屬性可以控制是否可以點擊這個按鈕那就是 <code>disabled</code>，我們可以透過 property binding 將這個屬性綁定到 component 的 property，建立一個動態改變他狀態的功能，一樣來舉個例子吧：</p>\n<ol>\n<li><p>在 app.component.ts 中新增一個 property 用來綁定 <code>&lt;button&gt;</code> 與一個 method 用來更改 property 的值</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  isUnchanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onButtonChange</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">isUnchanged</span> = !<span class=\"variable language_\">this</span>.<span class=\"property\">isUnchanged</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 app.component.html 中新增兩個 <code>&lt;button&gt;</code> 一個用來做 property binding 另一個用來改變 property 的內容</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-bottom: 10px;&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> [<span class=\"attr\">disabled</span>]=<span class=\"string\">&quot;isUnchanged&quot;</span>&gt;</span>Property binding<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;onButtonChange()&quot;</span>&gt;</span>Change Property value<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>在畫面中可以看到，當我們點擊 <code>Change Property value</code> 時，他將 Component 中的 isUnchanged 內容更改，所以讓 <code>Property binding</code> 這個 <code>&lt;button&gt;</code> 可以動態被 disable 與 enable。</p>\n<h1 id=\"Bind-values-between-components\"><a href=\"#Bind-values-between-components\" class=\"headerlink\" title=\"Bind values between components\"></a>Bind values between components</h1><p>在前幾天介紹 @Input() 時常常在用到的 <code>&lt;app-child-component [item]=&quot;currentItem&quot;&gt;&lt;/app-child-component&gt;</code> 其實就是 property binding，將父層 component 中的 property 綁定給子層，當父層 Component 的這個 property 發生改變時，因為綁定的關係所以會將這個改變也帶給子層，</p>\n<p>這邊再稍微複習一下該怎麼使用 @Input() 吧<img src=\"/images/emoticon/emoticon05.gif\" alt=\"/images/emoticon/emoticon05.gif\"></p>\n<ol>\n<li><p>先 parent.component.ts 中定義一個 property 並將他賦值</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  currentItem = <span class=\"string\">&#x27;Television&#x27;</span>;  <span class=\"comment\">// defind a property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.html 中使用 property binding 將父層的 currentItem property 綁定給子層</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> [<span class=\"attr\">item</span>]=<span class=\"string\">&quot;currentItem&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 child.component.ts 中使用 @Input( ) 裝飾器將 property 裝飾為是從父層傳下來的</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() item = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 child.component.html 中使用 Text interpolation 將他呈現在畫面上</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Today&#x27;s item: &#123;&#123; item &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>當初在介紹 @Input() 時還有很多技巧沒有講到（property binding、test interpolation）現在在重複看一次之前的例子有沒有比較可以把前幾章的內容串起來了呢。</p>\n<h1 id=\"Property-binding-and-security\"><a href=\"#Property-binding-and-security\" class=\"headerlink\" title=\"Property binding and security\"></a>Property binding and security</h1><p>既然 property binding 這麼好用，那有沒有什麼問題或是缺點呢？來看看下面的例子</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evilTitle = <span class=\"string\">&#x27;Template &lt;script&gt;alert(&quot;evil never sleeps&quot;)&lt;/script&gt; Syntax&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>當我在一個 component 中添加一個屬性，並將這個屬性裡面多加了 <code>&lt;script&gt;</code>，在這個裡面放了一些會危害到你專案的 javascript 程式，那麼會發生什麼事？</p>\n<p>其實不會發生上面說的會危害到你專案的情況發生，因為 Angular 在 property binding 中有做一個限制，<code>不允許帶有 &lt;script&gt; 標籤的 HTML 元件，也不允許帶有插值和屬性綁定</code>，所以將上面那個 property 差值到你的 HTML file 中時，會有下面的 error message</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Template &lt;script&gt;alert(&quot;</span>evil never sleeps<span class=\"string\">&quot;)&lt;/script&gt; Syntax&quot;</span> is the interpolated evil title.</span><br></pre></td></tr></table></figure>\n\n<p>這是 Angular 對 property binding 做的安全機制。</p>\n<h1 id=\"Property-binding-and-interpolation\"><a href=\"#Property-binding-and-interpolation\" class=\"headerlink\" title=\"Property binding and interpolation\"></a>Property binding and interpolation</h1><p>可能有人會問拉：property binding 與 text interpolation 都是將 component 中的 property 綁定在 HTML file 中，那們他們有什麼不一樣嗎？</p>\n<p>其實這個問題非常好，他們兩個理論上可以達到相同的目的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123;itemImageUrl&#125;&#125;&quot;</span>&gt;</span> is the <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>interpolated<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span> image.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> [<span class=\"attr\">src</span>]=<span class=\"string\">&quot;itemImageUrl&quot;</span>&gt;</span> is the <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>property bound<span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span> image.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面這兩個的結果會是一樣的，無論是透過 text interpolation 將 property 插進 <code>&lt;img&gt;</code> 的 src 屬性，還是利用 proprety binding 住 <code>&lt;img&gt;</code> 的 src 屬性都是可以將 component 的 property 放進我們想放的位置。</p>\n<p>雖然兩個都可以達到目的，所以<code>當在將數據值呈現為字串時可以使用兩種方法的其中一種</code>，但為了可讀性更傾向於使用 text interpolation，但是當將元素屬性設置為<code>非字串數值</code>時，就必須使用屬性綁定，比如上面提到的 <code>&lt;button&gt;</code> 的 disabled 屬性。</p>\n<h1 id=\"Binding-to-events\"><a href=\"#Binding-to-events\" class=\"headerlink\" title=\"Binding to events\"></a>Binding to events</h1><p>介紹完 property binding 後，接著要來介紹 event binding，顧名思義他就是將 event 綁定到 HTML 的元件上用於監聽使用這的操作，event binding 的語法是將<code>目標事件名稱放在等號左邊的括弧中</code>和將<code>引號的模板語句</code> 放在右側，舉個例子吧，當畫面中的一個按鈕被點擊到時，要觸發 component 中的 onSave() method，這時就可以這樣寫</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;onSave()&quot;</span>&gt;</span>Save<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png\" alt=\"https://www.tektutorialshub.com/wp-content/uploads/2020/03/Event-Binding-in-Angular.png\"></p>\n<p>如果你的 method 是帶有參數的，只要再等號右邊的 method 的括號中填入參數即可</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;onSave(data)&quot;</span>&gt;</span>Save<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Custom-events-with-EventEmitter\"><a href=\"#Custom-events-with-EventEmitter\" class=\"headerlink\" title=\"Custom events with EventEmitter\"></a>Custom events with EventEmitter</h1><p>還記得在前幾天中介紹的 @Output() 嗎？來複習一下吧， @Output() 的用意是將子層的內容透過一個 event 往上傳遞給父層，一樣舉個子來回憶一下吧</p>\n<ol>\n<li><p>在 child.component.ts 中加入一個 property 並將他使用 @Output() 裝飾成 EventEmitter 型態</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Output</span>() newItemEvent = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;<span class=\"built_in\">boolean</span>&gt;();  <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">parentValueChange</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">newItemEvent</span>.<span class=\"title function_\">emit</span>(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 child.component.html 中新增兩個 <code>&lt;button&gt;</code> 用來讓 user 點擊觸發 event</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- child.component.html  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>child component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(true)&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;parentValueChange(false)&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.ts 中添加一個 method，用來處理當子層傳送的數據</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent-component&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">  counterValue = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addOrSub</span>(<span class=\"params\">event: <span class=\"built_in\">boolean</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">counterValue</span>--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.html 中使用 event binding 將子層傳送的事件與 parent.component.ts 的 method 綁定</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- parent.component.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>parent component works!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>parent component property counter: &#123;&#123;counterValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child-component</span> (<span class=\"attr\">newItemEvent</span>)=<span class=\"string\">&quot;addOrSub($event)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>在介紹完 event binding 後再回來看這個例子，有沒有更能夠了解如何使用 @Output() 與 evebt binding 了呢？</p>\n<h1 id=\"Determining-an-event-target\"><a href=\"#Determining-an-event-target\" class=\"headerlink\" title=\"Determining an event target\"></a>Determining an event target</h1><p>在使用 Event binding 時，Angular 會檢查 event target 的名稱是否與已知指令事件屬性匹配，比如說</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">myClick</span>)=<span class=\"string\">&quot;clickMessage=$event&quot;</span> <span class=\"attr\">clickable</span>&gt;</span>click with myClick<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>你使用了一個自訂義的 <code>(myClick)</code> 作爲 event target 時，因為他不符合已知指令事件屬性，所以 Angular 會傳出 <code>unknown directive</code> 的錯誤訊息，所以在使用 event binding 時要記得使用正確的 event target 喔！</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>在本章中介紹了兩種 binding，property binding 是用於將 component 中的 property 綁定給 HTML 中的元件，常用在將父層的 property 綁定給子層、將比較複雜或是需要邏輯計算的 HTML 元件屬性放到 component 中計算後再放回等等。</p>\n<p>而 event binding 是將 component 中的 method 綁定到 HTML 的元件上用於監聽使用者的操作，常用再處理使用者使用者操作畫面而處發的事件、將子層透過 EventEmitter 往父層傳遞數據時的綁定。</p>\n<p>下一章將會介紹另外兩種 binding 方法，分別是 Attrubute, class, strle binding 與 Two-way binding， Attrubute, class, strle binding 顧名思義就是將 component 中的 property 綁定到 HTML 的 class 或 attrubute，而 Two-way binding 則是可以讓父子層之間只使用一個 binding 就可以同時監聽事件與更新值，不需要使用 property binding 和 event binding。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/property-binding\">Angular.io - property binding</a></li>\n<li><a href=\"https://angular.io/guide/event-binding\">Angular.io - event binding</a></li>\n</ul>"},{"title":"Day11. Attribute, class, and style bindings and Two-way binding","date":"2022-02-15T10:17:24.000Z","_content":"\n在上一張中介紹了 property binding 是用來將 Component 中的 property 綁定給 HTML Tag 的 property，還介紹了 event binding 是用來將 Component 中的 method 綁定給 HTML Tag 用來監聽畫面事件，而本章將持續介紹兩種 binding 方式。\n\nAttribute binding 可以用來讓你在開發 Template 時直接設置 property 值，透過 attuibute 可以提高訪問性、動態設置畫面樣式與可以同時管理多個 CSS Class 或樣式。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png)\n\n<!-- more -->\n\n# Binding to an attribute\n\n在大部分的情況下，對於設置 HTML 元件屬性都建議你都使用 property binding 來做，但是有時候會遇到你可能要綁定某一個元件的某個屬性，但這個元件並沒有這個屬性，如果強制使用 property binding 則會出錯，這實際需要使用 attibute binding了，比如說 [ARIA（WAI-ARIA）](https://www.w3.org/WAI/standards-guidelines/aria/) 或 [SVG（Scalable Vector Graphic）](https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it) 都是 `purely attribute`，代表他們既沒有元件的 property 也無法對他進行設置，這時就必須使用 attribute binding。\n\n到這邊可能有滿多新手開始頭暈了，attribute 跟 property 不是都是屬性嗎？有什麼不一樣，這邊簡單來說 `attributes 由 HTML 定義，所有出現在 HTML 標籤內的描述皆為 attributes` ，而 DOM properties 則是 `標準的 HTML attributes 經過瀏覽器解析後會產生相對應的 DOM properties`，有興趣可以看看 [這篇文章](https://jimmyswebnote.com/html-attributes-and-dom-properties/) 裡面詳細的介紹了什麼是 HTML attribute 與 DOM Property 的區別。\n## Syntax\n\n要了解一個新的用法就必須先瞭解他的語法，而 attribure binding 的語法與 property binding 相似，但不是將 element property 放在括號之間，而是在 attuibute 前面加上一個前綴字 `attr 後跟一個點（.）`，這樣就會把你輸入在後面的字串表達式解析成 attribute 值。\n\n**Note**: 這邊的介紹可能都會使用英文介紹對應的專有名詞，畢竟 property 與 attribute 的中文都是屬性...\n\n```html\n<p [attr.attribute-you-are-targeting]=\"expression\"></p>\n```\n\n注意喔！如果將後面的字串表達式設置為 `null` 或 `undefined` 的話，Angular 會直接將這個屬性完全刪除。\n\n\n\n# Example: Binding to colspan\n\n舉個 attribute binding 的例子吧，常見的使用 attribute binding 的例子是 table 中的 `colspan` attribute，colspan 是用來改變一個單元的格子應該跨越多少格，所以如果使用 attribute binding 可以做到動態這是 table。\n\n```html\n<!--  expression calculates colspan=2 -->\n<tr><td [attr.colspan]=\"1 + 1\">One-Two</td></tr>\n```\n\n這樣的設定可以使綁定的 `<tr>` 跨越兩列。\n\n**Note**: 要注意，`<tr>` 元件擁有的是 `colspan`  attribute，而如果是 property 的話則是 `colSpan`，大小寫要非常注意！ \n\n\n\n# Binding to the class attribute\n\nattribute 還有一個常用的用法，就是用於綁定 element 中的 CSS class，可以做到同時新增或刪除等管理多個 CSS class。\n\n## Binding to a single CSS class\n\n如果要綁定單個 CSS class 請使用 `class` 當作前綴後面跟上一個點（.）和 CSS class 的名稱，例如 `[class.sale]=\"onSale\"`，當訂的表達是為 true 時 Angular 會為這個 element 多添加一個 CSS class，反之則會被移除。\n\n## Binding to multiple CSS classes\n\n如果要同時綁定多個 CSS class 請使用 `[class]`，例如：[class]=\"classExpression\"，插入的表達是可以是：\n\n- 以`空格`分隔的 CSS class 的名字\n- 以 object 的 key 作為名稱，以 true 或 false 表達式作為值的物件\n- 包含多個 CSS class 名字的陣列\n\n\n\n# Binding to the style attribute\n\nattribute binding 也可以做到動態設置你的 element stype。\n\n## Binding to a single style\n\n要創建單個的 style binding，請使用前綴字 `style`後跟一個點（.）和 CSS stype property，例如 `[style.width]=\"width\"`， Angular 將 property 設置為綁定表達式的值，通常是一個字串或著可以添加像 `em` 或 `%` 的單位擴展符。\n\n**Note**: 可以使用破折號或駝峰命民法來編寫 style property 的名稱\n\n```html\n<nav [style.background-color]=\"expression\"></nav>\n\n<nav [style.backgroundColor]=\"expression\"></nav>\n```\n\n## Binding to multiple styles\n\n要綁定多個 style 請綁定到 [style] property，例如 [style]=\"styleExpression\" 而 styleExpression 可以是以下之一：\n\n- 樣式的字串列表：`\"width: 100px; height: 100px; background-color: cornflowerblue;\"`\n- 以樣式名稱為 key，以樣式值為 value 的物件：`{width: '100px', height: '100px', backgroundColor: 'cornflowerblue'}`\n\n**Note**: 注意！ [style] 不像 [class] 一樣支持綁定陣列喔！\n\n\n\n# Styling Precedence\n\n可以將多個源頭的值綁定給單一 HTML element 的 CSS class 和 style，當同一個 CSS class 或 style property 有多個綁定時，Angular 會遵循一組優先規則解決衝突並確定哪些 CSS class 或 stype 最終被應用於 HTML element。\n\n1. Template bindings\n    1. **Property binding**: `<div [class.foo]=\"hasFoo\"> or <div [style.colo]=\"color\">`\n    2. **Map binding**: `<div [class]=\"classExpr\"> or <div [style]=\"styleExpr\"`\n    3. **Static value**:  `<div class=\"foo\"> or <div style=\"color: blue\">`\n2. Directive host bindings\n    1. **Property binding**: `host: {'[class.foo]': 'hasFoo'} or host: {'[style.color]': 'color'}`\n    2. **Map binding**: `host: {'[class]': 'classExpr'} or host: {'[style]': 'styleExpr'}`\n    3. **Static value**: `host: {'class': 'foo'} or host: {'style': 'color: blue'}`\n3. Component host bindings\n    1. **Property binding**: `host: {'[class.foo]': 'hasFoo'} or host: {'[style.color]': 'color'}`\n    2. **Map binding**: `host: {'[class]': 'classExpr'} or host: {'[style]': 'styleExpr'}`\n    3. **Static value**: `host: {'class': 'foo'} or host: {'style': 'color: blue'}`\n\n可以看到 CSS class 或 style 越具體其優先級就越高，綁定到特定 CSS class（[class.foo]）會優先於通用 [class] 的綁定，而通用 [class] 的綁定又會優先於特定樣式綁定（[style.bar]），而他又會優先於通用 [style]  的綁定。\n\n\n\n# Two-way binding\n\n介紹完 attribute, class, style binding 後，接著要來介紹另一個非常常用的 binding 方法 `Two-way binding`，還記得在前幾天介紹的 @Input() 與 @Output() 嗎？在父層的 HTML 中如果要傳遞數據給子層，需要將父層的 property 利用 porperty binding 將它放入中括號 ( [ ] ) 中傳遞給子層，而父層要接受子層傳遞的數據時，需要利用 event binding 將子層的 EventEmitter 放括號中，當子層傳遞數據時觸發父層中綁定的 method\n\n```html\n<app-childComponent [inputData]=\"inputData\" (outputData)=\"onChildOutpu($event)\"></app-childComponent>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png](https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png)\n\n所以如果同一個子層同時要有 @Input() 與 @Output() 那就會把他家的很長不太好看，所以 Angular  提供了 `Two-way binding`，將 property binding 與 event binding 整合再一起，語法是將方括號與圓括號組合再一起 `[()]`。\n\n```html\n<app-sizer [(size)]=\"fontSizePx\"></app-sizer>\n```\n\n\n# How two-way binding works\n\n要讓 Two-way binding 可以正常運作需要將 @Output() property 使用 `inputChange` 模式，其中 input 是 @Input() 的名稱，舉例來說當你的 @Input() 命名為 size 則要將 @Output() 命名為 sizeChange，讓我們舉個例吧\n\n1. 在 child.component.ts 中建立一個 @Input() 屬性 size 與 @Output() 屬性 sizeChange 並加入三個 method\n\n    ```typescript\n    import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n    @Component({\n      selector: 'app-child',\n      templateUrl: './child.component.html',\n      styleUrls: ['./child.component.css'],\n    })\n    export class ChildComponent {\n      @Input() size!: number | string;                             // (1)\n      @Output() sizeChange = new EventEmitter<number>();           // (2)\n      constructor() {}\n\n      dec() {                                                      // (3)\n        this.resize(-1);\n      }\n      inc() {                                                      // (4)\n        this.resize(+1);\n      }\n\n      resize(delta: number) {                                      // (5)\n        this.size = Math.min(40, Math.max(8, +this.size + delta));\n        this.sizeChange.emit(this.size);\n      }\n    }\n    ```\n\n    - (1):  使用 @Input() 將 size 裝飾為父層傳遞下來的數據\n    - (2): 使用@Output() 將 sizeChange 裝飾為一個 EventEmitter 用於將數據向上傳給父層\n    - (3): 用於減小字體大小\n    - (4): 用於增加字體大小\n    - (5): 增加或減少字體大小的 method\n2. 在 child.component.html 中新增兩個按鈕用於讓使用者增加或減少字體大小，和使用 text interpolation 將 size 插入到 template 中\n\n    ```html\n    <div>\n      <button (click)=\"dec()\" title=\"smaller\">-</button>\n      <button (click)=\"inc()\" title=\"bigger\">+</button>\n      <label [style.font-size.px]=\"size\">FontSize: {{size}}px</label>\n    </div>\n    ```\n\n3. 在 parent.component.ts 中新增一個 property \n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-parent',\n      templateUrl: './parent.component.html',\n    })\n    export class ParentComponent {\n      frontSizePx = 16;\n      constructor() { }\n    }\n    ```\n\n4. 在 parent.component.html 中將 frontSizePx 使用 Two-way binding 綁定給子層\n\n    ```html\n    <app-child [(size)]=\"fontSizePx\"></app-child>\n    <div [style.font-size.px]=\"fontSizePx\">Resizable Text</div>\n    ```\n    \n![img](https://i.imgur.com/oKbjOZJ.gif)\n在畫面中可以看到，當我們點擊畫面中的 button 後，首先先讓子層向父層傳遞更改的大小，父層收到後再透過 @Input() 將變更的大小傳遞回子層讓子層可以顯示出 FontSize 的數值，這又就可以透過一個綁定就完成需要 @Input() 與 @Output() 的情況。\n\n\n\n# 結論\n\n本章中介紹了什麼最後的兩種綁定模式，可以使用 attribute binding 對沒有 property 的 HTML 元件動態綁定，可以使用 class binding 對一個 HTML 元件綁定一個或多個 CSS class，可以使用 style binding 對一個 HTML 元件綁定一個或多個樣式，而 CSS class 與 style 的綁定優先級遵守越具體其優先級就越高的概念。\n\n第二種介紹了 Two-way binding，如何透過一種綁定就達成 property binding 與 event binding，要注意的是如果要讓 Two-way binding 成功作用必須將 @Output() 麼名稱設定為 @Input() 的名稱加上Change。\n\n下一篇將會介紹 `Template variables`，他可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，詳細的內容就留到明天在介紹吧，那我們明天見。\n\n\n\n# Reference\n\n- [Angular.io - Attribute, class, and style bindings](https://angular.io/guide/attribute-binding)\n- [Angular.io - Two-way binding](https://angular.io/guide/two-way-binding)\n- [HTML Attributes 與 DOM Properties 的區別](https://jimmyswebnote.com/html-attributes-and-dom-properties/)\n- [What is an SVG File (And How Do You Use it)?](https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it)\n- [WAI-ARIA Overview](https://www.w3.org/WAI/standards-guidelines/aria/)","source":"_posts/Angular/angular-11.md","raw":"---\ntitle: Day11. Attribute, class, and style bindings and Two-way binding\ndate: 2022-02-15 18:17:24\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\n在上一張中介紹了 property binding 是用來將 Component 中的 property 綁定給 HTML Tag 的 property，還介紹了 event binding 是用來將 Component 中的 method 綁定給 HTML Tag 用來監聽畫面事件，而本章將持續介紹兩種 binding 方式。\n\nAttribute binding 可以用來讓你在開發 Template 時直接設置 property 值，透過 attuibute 可以提高訪問性、動態設置畫面樣式與可以同時管理多個 CSS Class 或樣式。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png)\n\n<!-- more -->\n\n# Binding to an attribute\n\n在大部分的情況下，對於設置 HTML 元件屬性都建議你都使用 property binding 來做，但是有時候會遇到你可能要綁定某一個元件的某個屬性，但這個元件並沒有這個屬性，如果強制使用 property binding 則會出錯，這實際需要使用 attibute binding了，比如說 [ARIA（WAI-ARIA）](https://www.w3.org/WAI/standards-guidelines/aria/) 或 [SVG（Scalable Vector Graphic）](https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it) 都是 `purely attribute`，代表他們既沒有元件的 property 也無法對他進行設置，這時就必須使用 attribute binding。\n\n到這邊可能有滿多新手開始頭暈了，attribute 跟 property 不是都是屬性嗎？有什麼不一樣，這邊簡單來說 `attributes 由 HTML 定義，所有出現在 HTML 標籤內的描述皆為 attributes` ，而 DOM properties 則是 `標準的 HTML attributes 經過瀏覽器解析後會產生相對應的 DOM properties`，有興趣可以看看 [這篇文章](https://jimmyswebnote.com/html-attributes-and-dom-properties/) 裡面詳細的介紹了什麼是 HTML attribute 與 DOM Property 的區別。\n## Syntax\n\n要了解一個新的用法就必須先瞭解他的語法，而 attribure binding 的語法與 property binding 相似，但不是將 element property 放在括號之間，而是在 attuibute 前面加上一個前綴字 `attr 後跟一個點（.）`，這樣就會把你輸入在後面的字串表達式解析成 attribute 值。\n\n**Note**: 這邊的介紹可能都會使用英文介紹對應的專有名詞，畢竟 property 與 attribute 的中文都是屬性...\n\n```html\n<p [attr.attribute-you-are-targeting]=\"expression\"></p>\n```\n\n注意喔！如果將後面的字串表達式設置為 `null` 或 `undefined` 的話，Angular 會直接將這個屬性完全刪除。\n\n\n\n# Example: Binding to colspan\n\n舉個 attribute binding 的例子吧，常見的使用 attribute binding 的例子是 table 中的 `colspan` attribute，colspan 是用來改變一個單元的格子應該跨越多少格，所以如果使用 attribute binding 可以做到動態這是 table。\n\n```html\n<!--  expression calculates colspan=2 -->\n<tr><td [attr.colspan]=\"1 + 1\">One-Two</td></tr>\n```\n\n這樣的設定可以使綁定的 `<tr>` 跨越兩列。\n\n**Note**: 要注意，`<tr>` 元件擁有的是 `colspan`  attribute，而如果是 property 的話則是 `colSpan`，大小寫要非常注意！ \n\n\n\n# Binding to the class attribute\n\nattribute 還有一個常用的用法，就是用於綁定 element 中的 CSS class，可以做到同時新增或刪除等管理多個 CSS class。\n\n## Binding to a single CSS class\n\n如果要綁定單個 CSS class 請使用 `class` 當作前綴後面跟上一個點（.）和 CSS class 的名稱，例如 `[class.sale]=\"onSale\"`，當訂的表達是為 true 時 Angular 會為這個 element 多添加一個 CSS class，反之則會被移除。\n\n## Binding to multiple CSS classes\n\n如果要同時綁定多個 CSS class 請使用 `[class]`，例如：[class]=\"classExpression\"，插入的表達是可以是：\n\n- 以`空格`分隔的 CSS class 的名字\n- 以 object 的 key 作為名稱，以 true 或 false 表達式作為值的物件\n- 包含多個 CSS class 名字的陣列\n\n\n\n# Binding to the style attribute\n\nattribute binding 也可以做到動態設置你的 element stype。\n\n## Binding to a single style\n\n要創建單個的 style binding，請使用前綴字 `style`後跟一個點（.）和 CSS stype property，例如 `[style.width]=\"width\"`， Angular 將 property 設置為綁定表達式的值，通常是一個字串或著可以添加像 `em` 或 `%` 的單位擴展符。\n\n**Note**: 可以使用破折號或駝峰命民法來編寫 style property 的名稱\n\n```html\n<nav [style.background-color]=\"expression\"></nav>\n\n<nav [style.backgroundColor]=\"expression\"></nav>\n```\n\n## Binding to multiple styles\n\n要綁定多個 style 請綁定到 [style] property，例如 [style]=\"styleExpression\" 而 styleExpression 可以是以下之一：\n\n- 樣式的字串列表：`\"width: 100px; height: 100px; background-color: cornflowerblue;\"`\n- 以樣式名稱為 key，以樣式值為 value 的物件：`{width: '100px', height: '100px', backgroundColor: 'cornflowerblue'}`\n\n**Note**: 注意！ [style] 不像 [class] 一樣支持綁定陣列喔！\n\n\n\n# Styling Precedence\n\n可以將多個源頭的值綁定給單一 HTML element 的 CSS class 和 style，當同一個 CSS class 或 style property 有多個綁定時，Angular 會遵循一組優先規則解決衝突並確定哪些 CSS class 或 stype 最終被應用於 HTML element。\n\n1. Template bindings\n    1. **Property binding**: `<div [class.foo]=\"hasFoo\"> or <div [style.colo]=\"color\">`\n    2. **Map binding**: `<div [class]=\"classExpr\"> or <div [style]=\"styleExpr\"`\n    3. **Static value**:  `<div class=\"foo\"> or <div style=\"color: blue\">`\n2. Directive host bindings\n    1. **Property binding**: `host: {'[class.foo]': 'hasFoo'} or host: {'[style.color]': 'color'}`\n    2. **Map binding**: `host: {'[class]': 'classExpr'} or host: {'[style]': 'styleExpr'}`\n    3. **Static value**: `host: {'class': 'foo'} or host: {'style': 'color: blue'}`\n3. Component host bindings\n    1. **Property binding**: `host: {'[class.foo]': 'hasFoo'} or host: {'[style.color]': 'color'}`\n    2. **Map binding**: `host: {'[class]': 'classExpr'} or host: {'[style]': 'styleExpr'}`\n    3. **Static value**: `host: {'class': 'foo'} or host: {'style': 'color: blue'}`\n\n可以看到 CSS class 或 style 越具體其優先級就越高，綁定到特定 CSS class（[class.foo]）會優先於通用 [class] 的綁定，而通用 [class] 的綁定又會優先於特定樣式綁定（[style.bar]），而他又會優先於通用 [style]  的綁定。\n\n\n\n# Two-way binding\n\n介紹完 attribute, class, style binding 後，接著要來介紹另一個非常常用的 binding 方法 `Two-way binding`，還記得在前幾天介紹的 @Input() 與 @Output() 嗎？在父層的 HTML 中如果要傳遞數據給子層，需要將父層的 property 利用 porperty binding 將它放入中括號 ( [ ] ) 中傳遞給子層，而父層要接受子層傳遞的數據時，需要利用 event binding 將子層的 EventEmitter 放括號中，當子層傳遞數據時觸發父層中綁定的 method\n\n```html\n<app-childComponent [inputData]=\"inputData\" (outputData)=\"onChildOutpu($event)\"></app-childComponent>\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png](https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png)\n\n所以如果同一個子層同時要有 @Input() 與 @Output() 那就會把他家的很長不太好看，所以 Angular  提供了 `Two-way binding`，將 property binding 與 event binding 整合再一起，語法是將方括號與圓括號組合再一起 `[()]`。\n\n```html\n<app-sizer [(size)]=\"fontSizePx\"></app-sizer>\n```\n\n\n# How two-way binding works\n\n要讓 Two-way binding 可以正常運作需要將 @Output() property 使用 `inputChange` 模式，其中 input 是 @Input() 的名稱，舉例來說當你的 @Input() 命名為 size 則要將 @Output() 命名為 sizeChange，讓我們舉個例吧\n\n1. 在 child.component.ts 中建立一個 @Input() 屬性 size 與 @Output() 屬性 sizeChange 並加入三個 method\n\n    ```typescript\n    import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n    @Component({\n      selector: 'app-child',\n      templateUrl: './child.component.html',\n      styleUrls: ['./child.component.css'],\n    })\n    export class ChildComponent {\n      @Input() size!: number | string;                             // (1)\n      @Output() sizeChange = new EventEmitter<number>();           // (2)\n      constructor() {}\n\n      dec() {                                                      // (3)\n        this.resize(-1);\n      }\n      inc() {                                                      // (4)\n        this.resize(+1);\n      }\n\n      resize(delta: number) {                                      // (5)\n        this.size = Math.min(40, Math.max(8, +this.size + delta));\n        this.sizeChange.emit(this.size);\n      }\n    }\n    ```\n\n    - (1):  使用 @Input() 將 size 裝飾為父層傳遞下來的數據\n    - (2): 使用@Output() 將 sizeChange 裝飾為一個 EventEmitter 用於將數據向上傳給父層\n    - (3): 用於減小字體大小\n    - (4): 用於增加字體大小\n    - (5): 增加或減少字體大小的 method\n2. 在 child.component.html 中新增兩個按鈕用於讓使用者增加或減少字體大小，和使用 text interpolation 將 size 插入到 template 中\n\n    ```html\n    <div>\n      <button (click)=\"dec()\" title=\"smaller\">-</button>\n      <button (click)=\"inc()\" title=\"bigger\">+</button>\n      <label [style.font-size.px]=\"size\">FontSize: {{size}}px</label>\n    </div>\n    ```\n\n3. 在 parent.component.ts 中新增一個 property \n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-parent',\n      templateUrl: './parent.component.html',\n    })\n    export class ParentComponent {\n      frontSizePx = 16;\n      constructor() { }\n    }\n    ```\n\n4. 在 parent.component.html 中將 frontSizePx 使用 Two-way binding 綁定給子層\n\n    ```html\n    <app-child [(size)]=\"fontSizePx\"></app-child>\n    <div [style.font-size.px]=\"fontSizePx\">Resizable Text</div>\n    ```\n    \n![img](https://i.imgur.com/oKbjOZJ.gif)\n在畫面中可以看到，當我們點擊畫面中的 button 後，首先先讓子層向父層傳遞更改的大小，父層收到後再透過 @Input() 將變更的大小傳遞回子層讓子層可以顯示出 FontSize 的數值，這又就可以透過一個綁定就完成需要 @Input() 與 @Output() 的情況。\n\n\n\n# 結論\n\n本章中介紹了什麼最後的兩種綁定模式，可以使用 attribute binding 對沒有 property 的 HTML 元件動態綁定，可以使用 class binding 對一個 HTML 元件綁定一個或多個 CSS class，可以使用 style binding 對一個 HTML 元件綁定一個或多個樣式，而 CSS class 與 style 的綁定優先級遵守越具體其優先級就越高的概念。\n\n第二種介紹了 Two-way binding，如何透過一種綁定就達成 property binding 與 event binding，要注意的是如果要讓 Two-way binding 成功作用必須將 @Output() 麼名稱設定為 @Input() 的名稱加上Change。\n\n下一篇將會介紹 `Template variables`，他可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，詳細的內容就留到明天在介紹吧，那我們明天見。\n\n\n\n# Reference\n\n- [Angular.io - Attribute, class, and style bindings](https://angular.io/guide/attribute-binding)\n- [Angular.io - Two-way binding](https://angular.io/guide/two-way-binding)\n- [HTML Attributes 與 DOM Properties 的區別](https://jimmyswebnote.com/html-attributes-and-dom-properties/)\n- [What is an SVG File (And How Do You Use it)?](https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it)\n- [WAI-ARIA Overview](https://www.w3.org/WAI/standards-guidelines/aria/)","slug":"Angular/angular-11","published":1,"updated":"2022-02-15T10:19:15.277Z","_id":"ckznz1lmg001mkww3bld65c2x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在上一張中介紹了 property binding 是用來將 Component 中的 property 綁定給 HTML Tag 的 property，還介紹了 event binding 是用來將 Component 中的 method 綁定給 HTML Tag 用來監聽畫面事件，而本章將持續介紹兩種 binding 方式。</p>\n<p>Attribute binding 可以用來讓你在開發 Template 時直接設置 property 值，透過 attuibute 可以提高訪問性、動態設置畫面樣式與可以同時管理多個 CSS Class 或樣式。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Binding-to-an-attribute\"><a href=\"#Binding-to-an-attribute\" class=\"headerlink\" title=\"Binding to an attribute\"></a>Binding to an attribute</h1><p>在大部分的情況下，對於設置 HTML 元件屬性都建議你都使用 property binding 來做，但是有時候會遇到你可能要綁定某一個元件的某個屬性，但這個元件並沒有這個屬性，如果強制使用 property binding 則會出錯，這實際需要使用 attibute binding了，比如說 <a href=\"https://www.w3.org/WAI/standards-guidelines/aria/\">ARIA（WAI-ARIA）</a> 或 <a href=\"https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it\">SVG（Scalable Vector Graphic）</a> 都是 <code>purely attribute</code>，代表他們既沒有元件的 property 也無法對他進行設置，這時就必須使用 attribute binding。</p>\n<p>到這邊可能有滿多新手開始頭暈了，attribute 跟 property 不是都是屬性嗎？有什麼不一樣，這邊簡單來說 <code>attributes 由 HTML 定義，所有出現在 HTML 標籤內的描述皆為 attributes</code> ，而 DOM properties 則是 <code>標準的 HTML attributes 經過瀏覽器解析後會產生相對應的 DOM properties</code>，有興趣可以看看 <a href=\"https://jimmyswebnote.com/html-attributes-and-dom-properties/\">這篇文章</a> 裡面詳細的介紹了什麼是 HTML attribute 與 DOM Property 的區別。</p>\n<h2 id=\"Syntax\"><a href=\"#Syntax\" class=\"headerlink\" title=\"Syntax\"></a>Syntax</h2><p>要了解一個新的用法就必須先瞭解他的語法，而 attribure binding 的語法與 property binding 相似，但不是將 element property 放在括號之間，而是在 attuibute 前面加上一個前綴字 <code>attr 後跟一個點（.）</code>，這樣就會把你輸入在後面的字串表達式解析成 attribute 值。</p>\n<p><strong>Note</strong>: 這邊的介紹可能都會使用英文介紹對應的專有名詞，畢竟 property 與 attribute 的中文都是屬性…</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> [<span class=\"attr\">attr.attribute-you-are-targeting</span>]=<span class=\"string\">&quot;expression&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意喔！如果將後面的字串表達式設置為 <code>null</code> 或 <code>undefined</code> 的話，Angular 會直接將這個屬性完全刪除。</p>\n<h1 id=\"Example-Binding-to-colspan\"><a href=\"#Example-Binding-to-colspan\" class=\"headerlink\" title=\"Example: Binding to colspan\"></a>Example: Binding to colspan</h1><p>舉個 attribute binding 的例子吧，常見的使用 attribute binding 的例子是 table 中的 <code>colspan</code> attribute，colspan 是用來改變一個單元的格子應該跨越多少格，所以如果使用 attribute binding 可以做到動態這是 table。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--  expression calculates colspan=2 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">td</span> [<span class=\"attr\">attr.colspan</span>]=<span class=\"string\">&quot;1 + 1&quot;</span>&gt;</span>One-Two<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>這樣的設定可以使綁定的 <code>&lt;tr&gt;</code> 跨越兩列。</p>\n<p><strong>Note</strong>: 要注意，<code>&lt;tr&gt;</code> 元件擁有的是 <code>colspan</code>  attribute，而如果是 property 的話則是 <code>colSpan</code>，大小寫要非常注意！ </p>\n<h1 id=\"Binding-to-the-class-attribute\"><a href=\"#Binding-to-the-class-attribute\" class=\"headerlink\" title=\"Binding to the class attribute\"></a>Binding to the class attribute</h1><p>attribute 還有一個常用的用法，就是用於綁定 element 中的 CSS class，可以做到同時新增或刪除等管理多個 CSS class。</p>\n<h2 id=\"Binding-to-a-single-CSS-class\"><a href=\"#Binding-to-a-single-CSS-class\" class=\"headerlink\" title=\"Binding to a single CSS class\"></a>Binding to a single CSS class</h2><p>如果要綁定單個 CSS class 請使用 <code>class</code> 當作前綴後面跟上一個點（.）和 CSS class 的名稱，例如 <code>[class.sale]=&quot;onSale&quot;</code>，當訂的表達是為 true 時 Angular 會為這個 element 多添加一個 CSS class，反之則會被移除。</p>\n<h2 id=\"Binding-to-multiple-CSS-classes\"><a href=\"#Binding-to-multiple-CSS-classes\" class=\"headerlink\" title=\"Binding to multiple CSS classes\"></a>Binding to multiple CSS classes</h2><p>如果要同時綁定多個 CSS class 請使用 <code>[class]</code>，例如：[class]&#x3D;”classExpression”，插入的表達是可以是：</p>\n<ul>\n<li>以<code>空格</code>分隔的 CSS class 的名字</li>\n<li>以 object 的 key 作為名稱，以 true 或 false 表達式作為值的物件</li>\n<li>包含多個 CSS class 名字的陣列</li>\n</ul>\n<h1 id=\"Binding-to-the-style-attribute\"><a href=\"#Binding-to-the-style-attribute\" class=\"headerlink\" title=\"Binding to the style attribute\"></a>Binding to the style attribute</h1><p>attribute binding 也可以做到動態設置你的 element stype。</p>\n<h2 id=\"Binding-to-a-single-style\"><a href=\"#Binding-to-a-single-style\" class=\"headerlink\" title=\"Binding to a single style\"></a>Binding to a single style</h2><p>要創建單個的 style binding，請使用前綴字 <code>style</code>後跟一個點（.）和 CSS stype property，例如 <code>[style.width]=&quot;width&quot;</code>， Angular 將 property 設置為綁定表達式的值，通常是一個字串或著可以添加像 <code>em</code> 或 <code>%</code> 的單位擴展符。</p>\n<p><strong>Note</strong>: 可以使用破折號或駝峰命民法來編寫 style property 的名稱</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span> [<span class=\"attr\">style.background-color</span>]=<span class=\"string\">&quot;expression&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span> [<span class=\"attr\">style.backgroundColor</span>]=<span class=\"string\">&quot;expression&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Binding-to-multiple-styles\"><a href=\"#Binding-to-multiple-styles\" class=\"headerlink\" title=\"Binding to multiple styles\"></a>Binding to multiple styles</h2><p>要綁定多個 style 請綁定到 [style] property，例如 [style]&#x3D;”styleExpression” 而 styleExpression 可以是以下之一：</p>\n<ul>\n<li>樣式的字串列表：<code>&quot;width: 100px; height: 100px; background-color: cornflowerblue;&quot;</code></li>\n<li>以樣式名稱為 key，以樣式值為 value 的物件：<code>&#123;width: &#39;100px&#39;, height: &#39;100px&#39;, backgroundColor: &#39;cornflowerblue&#39;&#125;</code></li>\n</ul>\n<p><strong>Note</strong>: 注意！ [style] 不像 [class] 一樣支持綁定陣列喔！</p>\n<h1 id=\"Styling-Precedence\"><a href=\"#Styling-Precedence\" class=\"headerlink\" title=\"Styling Precedence\"></a>Styling Precedence</h1><p>可以將多個源頭的值綁定給單一 HTML element 的 CSS class 和 style，當同一個 CSS class 或 style property 有多個綁定時，Angular 會遵循一組優先規則解決衝突並確定哪些 CSS class 或 stype 最終被應用於 HTML element。</p>\n<ol>\n<li>Template bindings<ol>\n<li><strong>Property binding</strong>: <code>&lt;div [class.foo]=&quot;hasFoo&quot;&gt; or &lt;div [style.colo]=&quot;color&quot;&gt;</code></li>\n<li><strong>Map binding</strong>: <code>&lt;div [class]=&quot;classExpr&quot;&gt; or &lt;div [style]=&quot;styleExpr&quot;</code></li>\n<li><strong>Static value</strong>:  <code>&lt;div class=&quot;foo&quot;&gt; or &lt;div style=&quot;color: blue&quot;&gt;</code></li>\n</ol>\n</li>\n<li>Directive host bindings<ol>\n<li><strong>Property binding</strong>: <code>host: &#123;&#39;[class.foo]&#39;: &#39;hasFoo&#39;&#125; or host: &#123;&#39;[style.color]&#39;: &#39;color&#39;&#125;</code></li>\n<li><strong>Map binding</strong>: <code>host: &#123;&#39;[class]&#39;: &#39;classExpr&#39;&#125; or host: &#123;&#39;[style]&#39;: &#39;styleExpr&#39;&#125;</code></li>\n<li><strong>Static value</strong>: <code>host: &#123;&#39;class&#39;: &#39;foo&#39;&#125; or host: &#123;&#39;style&#39;: &#39;color: blue&#39;&#125;</code></li>\n</ol>\n</li>\n<li>Component host bindings<ol>\n<li><strong>Property binding</strong>: <code>host: &#123;&#39;[class.foo]&#39;: &#39;hasFoo&#39;&#125; or host: &#123;&#39;[style.color]&#39;: &#39;color&#39;&#125;</code></li>\n<li><strong>Map binding</strong>: <code>host: &#123;&#39;[class]&#39;: &#39;classExpr&#39;&#125; or host: &#123;&#39;[style]&#39;: &#39;styleExpr&#39;&#125;</code></li>\n<li><strong>Static value</strong>: <code>host: &#123;&#39;class&#39;: &#39;foo&#39;&#125; or host: &#123;&#39;style&#39;: &#39;color: blue&#39;&#125;</code></li>\n</ol>\n</li>\n</ol>\n<p>可以看到 CSS class 或 style 越具體其優先級就越高，綁定到特定 CSS class（[class.foo]）會優先於通用 [class] 的綁定，而通用 [class] 的綁定又會優先於特定樣式綁定（[style.bar]），而他又會優先於通用 [style]  的綁定。</p>\n<h1 id=\"Two-way-binding\"><a href=\"#Two-way-binding\" class=\"headerlink\" title=\"Two-way binding\"></a>Two-way binding</h1><p>介紹完 attribute, class, style binding 後，接著要來介紹另一個非常常用的 binding 方法 <code>Two-way binding</code>，還記得在前幾天介紹的 @Input() 與 @Output() 嗎？在父層的 HTML 中如果要傳遞數據給子層，需要將父層的 property 利用 porperty binding 將它放入中括號 ( [ ] ) 中傳遞給子層，而父層要接受子層傳遞的數據時，需要利用 event binding 將子層的 EventEmitter 放括號中，當子層傳遞數據時觸發父層中綁定的 method</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-childComponent</span> [<span class=\"attr\">inputData</span>]=<span class=\"string\">&quot;inputData&quot;</span> (<span class=\"attr\">outputData</span>)=<span class=\"string\">&quot;onChildOutpu($event)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-childComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png\"></p>\n<p>所以如果同一個子層同時要有 @Input() 與 @Output() 那就會把他家的很長不太好看，所以 Angular  提供了 <code>Two-way binding</code>，將 property binding 與 event binding 整合再一起，語法是將方括號與圓括號組合再一起 <code>[()]</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-sizer</span> [(<span class=\"attr\">size</span>)]=<span class=\"string\">&quot;fontSizePx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-sizer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"How-two-way-binding-works\"><a href=\"#How-two-way-binding-works\" class=\"headerlink\" title=\"How two-way binding works\"></a>How two-way binding works</h1><p>要讓 Two-way binding 可以正常運作需要將 @Output() property 使用 <code>inputChange</code> 模式，其中 input 是 @Input() 的名稱，舉例來說當你的 @Input() 命名為 size 則要將 @Output() 命名為 sizeChange，讓我們舉個例吧</p>\n<ol>\n<li><p>在 child.component.ts 中建立一個 @Input() 屬性 size 與 @Output() 屬性 sizeChange 並加入三個 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() size!: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;                             <span class=\"comment\">// (1)</span></span><br><span class=\"line\">  <span class=\"meta\">@Output</span>() sizeChange = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;<span class=\"built_in\">number</span>&gt;();           <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">dec</span>(<span class=\"params\"></span>) &#123;                                                      <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">resize</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">inc</span>(<span class=\"params\"></span>) &#123;                                                      <span class=\"comment\">// (4)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">resize</span>(+<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">resize</span>(<span class=\"params\">delta: <span class=\"built_in\">number</span></span>) &#123;                                      <span class=\"comment\">// (5)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">size</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(<span class=\"number\">40</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"number\">8</span>, +<span class=\"variable language_\">this</span>.<span class=\"property\">size</span> + delta));</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">sizeChange</span>.<span class=\"title function_\">emit</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">size</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>(1):  使用 @Input() 將 size 裝飾為父層傳遞下來的數據</li>\n<li>(2): 使用@Output() 將 sizeChange 裝飾為一個 EventEmitter 用於將數據向上傳給父層</li>\n<li>(3): 用於減小字體大小</li>\n<li>(4): 用於增加字體大小</li>\n<li>(5): 增加或減少字體大小的 method</li>\n</ul>\n</li>\n<li><p>在 child.component.html 中新增兩個按鈕用於讓使用者增加或減少字體大小，和使用 text interpolation 將 size 插入到 template 中</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;dec()&quot;</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;smaller&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;inc()&quot;</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;bigger&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> [<span class=\"attr\">style.font-size.px</span>]=<span class=\"string\">&quot;size&quot;</span>&gt;</span>FontSize: &#123;&#123;size&#125;&#125;px<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.ts 中新增一個 property </p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  frontSizePx = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.html 中將 frontSizePx 使用 Two-way binding 綁定給子層</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child</span> [(<span class=\"attr\">size</span>)]=<span class=\"string\">&quot;fontSizePx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">style.font-size.px</span>]=<span class=\"string\">&quot;fontSizePx&quot;</span>&gt;</span>Resizable Text<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://i.imgur.com/oKbjOZJ.gif\" alt=\"img\"><br>在畫面中可以看到，當我們點擊畫面中的 button 後，首先先讓子層向父層傳遞更改的大小，父層收到後再透過 @Input() 將變更的大小傳遞回子層讓子層可以顯示出 FontSize 的數值，這又就可以透過一個綁定就完成需要 @Input() 與 @Output() 的情況。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本章中介紹了什麼最後的兩種綁定模式，可以使用 attribute binding 對沒有 property 的 HTML 元件動態綁定，可以使用 class binding 對一個 HTML 元件綁定一個或多個 CSS class，可以使用 style binding 對一個 HTML 元件綁定一個或多個樣式，而 CSS class 與 style 的綁定優先級遵守越具體其優先級就越高的概念。</p>\n<p>第二種介紹了 Two-way binding，如何透過一種綁定就達成 property binding 與 event binding，要注意的是如果要讓 Two-way binding 成功作用必須將 @Output() 麼名稱設定為 @Input() 的名稱加上Change。</p>\n<p>下一篇將會介紹 <code>Template variables</code>，他可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，詳細的內容就留到明天在介紹吧，那我們明天見。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/attribute-binding\">Angular.io - Attribute, class, and style bindings</a></li>\n<li><a href=\"https://angular.io/guide/two-way-binding\">Angular.io - Two-way binding</a></li>\n<li><a href=\"https://jimmyswebnote.com/html-attributes-and-dom-properties/\">HTML Attributes 與 DOM Properties 的區別</a></li>\n<li><a href=\"https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it\">What is an SVG File (And How Do You Use it)?</a></li>\n<li><a href=\"https://www.w3.org/WAI/standards-guidelines/aria/\">WAI-ARIA Overview</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在上一張中介紹了 property binding 是用來將 Component 中的 property 綁定給 HTML Tag 的 property，還介紹了 event binding 是用來將 Component 中的 method 綁定給 HTML Tag 用來監聽畫面事件，而本章將持續介紹兩種 binding 方式。</p>\n<p>Attribute binding 可以用來讓你在開發 Template 時直接設置 property 值，透過 attuibute 可以提高訪問性、動態設置畫面樣式與可以同時管理多個 CSS Class 或樣式。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767uy096133tc.png\"></p>","more":"<h1 id=\"Binding-to-an-attribute\"><a href=\"#Binding-to-an-attribute\" class=\"headerlink\" title=\"Binding to an attribute\"></a>Binding to an attribute</h1><p>在大部分的情況下，對於設置 HTML 元件屬性都建議你都使用 property binding 來做，但是有時候會遇到你可能要綁定某一個元件的某個屬性，但這個元件並沒有這個屬性，如果強制使用 property binding 則會出錯，這實際需要使用 attibute binding了，比如說 <a href=\"https://www.w3.org/WAI/standards-guidelines/aria/\">ARIA（WAI-ARIA）</a> 或 <a href=\"https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it\">SVG（Scalable Vector Graphic）</a> 都是 <code>purely attribute</code>，代表他們既沒有元件的 property 也無法對他進行設置，這時就必須使用 attribute binding。</p>\n<p>到這邊可能有滿多新手開始頭暈了，attribute 跟 property 不是都是屬性嗎？有什麼不一樣，這邊簡單來說 <code>attributes 由 HTML 定義，所有出現在 HTML 標籤內的描述皆為 attributes</code> ，而 DOM properties 則是 <code>標準的 HTML attributes 經過瀏覽器解析後會產生相對應的 DOM properties</code>，有興趣可以看看 <a href=\"https://jimmyswebnote.com/html-attributes-and-dom-properties/\">這篇文章</a> 裡面詳細的介紹了什麼是 HTML attribute 與 DOM Property 的區別。</p>\n<h2 id=\"Syntax\"><a href=\"#Syntax\" class=\"headerlink\" title=\"Syntax\"></a>Syntax</h2><p>要了解一個新的用法就必須先瞭解他的語法，而 attribure binding 的語法與 property binding 相似，但不是將 element property 放在括號之間，而是在 attuibute 前面加上一個前綴字 <code>attr 後跟一個點（.）</code>，這樣就會把你輸入在後面的字串表達式解析成 attribute 值。</p>\n<p><strong>Note</strong>: 這邊的介紹可能都會使用英文介紹對應的專有名詞，畢竟 property 與 attribute 的中文都是屬性…</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> [<span class=\"attr\">attr.attribute-you-are-targeting</span>]=<span class=\"string\">&quot;expression&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意喔！如果將後面的字串表達式設置為 <code>null</code> 或 <code>undefined</code> 的話，Angular 會直接將這個屬性完全刪除。</p>\n<h1 id=\"Example-Binding-to-colspan\"><a href=\"#Example-Binding-to-colspan\" class=\"headerlink\" title=\"Example: Binding to colspan\"></a>Example: Binding to colspan</h1><p>舉個 attribute binding 的例子吧，常見的使用 attribute binding 的例子是 table 中的 <code>colspan</code> attribute，colspan 是用來改變一個單元的格子應該跨越多少格，所以如果使用 attribute binding 可以做到動態這是 table。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--  expression calculates colspan=2 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">td</span> [<span class=\"attr\">attr.colspan</span>]=<span class=\"string\">&quot;1 + 1&quot;</span>&gt;</span>One-Two<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>這樣的設定可以使綁定的 <code>&lt;tr&gt;</code> 跨越兩列。</p>\n<p><strong>Note</strong>: 要注意，<code>&lt;tr&gt;</code> 元件擁有的是 <code>colspan</code>  attribute，而如果是 property 的話則是 <code>colSpan</code>，大小寫要非常注意！ </p>\n<h1 id=\"Binding-to-the-class-attribute\"><a href=\"#Binding-to-the-class-attribute\" class=\"headerlink\" title=\"Binding to the class attribute\"></a>Binding to the class attribute</h1><p>attribute 還有一個常用的用法，就是用於綁定 element 中的 CSS class，可以做到同時新增或刪除等管理多個 CSS class。</p>\n<h2 id=\"Binding-to-a-single-CSS-class\"><a href=\"#Binding-to-a-single-CSS-class\" class=\"headerlink\" title=\"Binding to a single CSS class\"></a>Binding to a single CSS class</h2><p>如果要綁定單個 CSS class 請使用 <code>class</code> 當作前綴後面跟上一個點（.）和 CSS class 的名稱，例如 <code>[class.sale]=&quot;onSale&quot;</code>，當訂的表達是為 true 時 Angular 會為這個 element 多添加一個 CSS class，反之則會被移除。</p>\n<h2 id=\"Binding-to-multiple-CSS-classes\"><a href=\"#Binding-to-multiple-CSS-classes\" class=\"headerlink\" title=\"Binding to multiple CSS classes\"></a>Binding to multiple CSS classes</h2><p>如果要同時綁定多個 CSS class 請使用 <code>[class]</code>，例如：[class]&#x3D;”classExpression”，插入的表達是可以是：</p>\n<ul>\n<li>以<code>空格</code>分隔的 CSS class 的名字</li>\n<li>以 object 的 key 作為名稱，以 true 或 false 表達式作為值的物件</li>\n<li>包含多個 CSS class 名字的陣列</li>\n</ul>\n<h1 id=\"Binding-to-the-style-attribute\"><a href=\"#Binding-to-the-style-attribute\" class=\"headerlink\" title=\"Binding to the style attribute\"></a>Binding to the style attribute</h1><p>attribute binding 也可以做到動態設置你的 element stype。</p>\n<h2 id=\"Binding-to-a-single-style\"><a href=\"#Binding-to-a-single-style\" class=\"headerlink\" title=\"Binding to a single style\"></a>Binding to a single style</h2><p>要創建單個的 style binding，請使用前綴字 <code>style</code>後跟一個點（.）和 CSS stype property，例如 <code>[style.width]=&quot;width&quot;</code>， Angular 將 property 設置為綁定表達式的值，通常是一個字串或著可以添加像 <code>em</code> 或 <code>%</code> 的單位擴展符。</p>\n<p><strong>Note</strong>: 可以使用破折號或駝峰命民法來編寫 style property 的名稱</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span> [<span class=\"attr\">style.background-color</span>]=<span class=\"string\">&quot;expression&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span> [<span class=\"attr\">style.backgroundColor</span>]=<span class=\"string\">&quot;expression&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Binding-to-multiple-styles\"><a href=\"#Binding-to-multiple-styles\" class=\"headerlink\" title=\"Binding to multiple styles\"></a>Binding to multiple styles</h2><p>要綁定多個 style 請綁定到 [style] property，例如 [style]&#x3D;”styleExpression” 而 styleExpression 可以是以下之一：</p>\n<ul>\n<li>樣式的字串列表：<code>&quot;width: 100px; height: 100px; background-color: cornflowerblue;&quot;</code></li>\n<li>以樣式名稱為 key，以樣式值為 value 的物件：<code>&#123;width: &#39;100px&#39;, height: &#39;100px&#39;, backgroundColor: &#39;cornflowerblue&#39;&#125;</code></li>\n</ul>\n<p><strong>Note</strong>: 注意！ [style] 不像 [class] 一樣支持綁定陣列喔！</p>\n<h1 id=\"Styling-Precedence\"><a href=\"#Styling-Precedence\" class=\"headerlink\" title=\"Styling Precedence\"></a>Styling Precedence</h1><p>可以將多個源頭的值綁定給單一 HTML element 的 CSS class 和 style，當同一個 CSS class 或 style property 有多個綁定時，Angular 會遵循一組優先規則解決衝突並確定哪些 CSS class 或 stype 最終被應用於 HTML element。</p>\n<ol>\n<li>Template bindings<ol>\n<li><strong>Property binding</strong>: <code>&lt;div [class.foo]=&quot;hasFoo&quot;&gt; or &lt;div [style.colo]=&quot;color&quot;&gt;</code></li>\n<li><strong>Map binding</strong>: <code>&lt;div [class]=&quot;classExpr&quot;&gt; or &lt;div [style]=&quot;styleExpr&quot;</code></li>\n<li><strong>Static value</strong>:  <code>&lt;div class=&quot;foo&quot;&gt; or &lt;div style=&quot;color: blue&quot;&gt;</code></li>\n</ol>\n</li>\n<li>Directive host bindings<ol>\n<li><strong>Property binding</strong>: <code>host: &#123;&#39;[class.foo]&#39;: &#39;hasFoo&#39;&#125; or host: &#123;&#39;[style.color]&#39;: &#39;color&#39;&#125;</code></li>\n<li><strong>Map binding</strong>: <code>host: &#123;&#39;[class]&#39;: &#39;classExpr&#39;&#125; or host: &#123;&#39;[style]&#39;: &#39;styleExpr&#39;&#125;</code></li>\n<li><strong>Static value</strong>: <code>host: &#123;&#39;class&#39;: &#39;foo&#39;&#125; or host: &#123;&#39;style&#39;: &#39;color: blue&#39;&#125;</code></li>\n</ol>\n</li>\n<li>Component host bindings<ol>\n<li><strong>Property binding</strong>: <code>host: &#123;&#39;[class.foo]&#39;: &#39;hasFoo&#39;&#125; or host: &#123;&#39;[style.color]&#39;: &#39;color&#39;&#125;</code></li>\n<li><strong>Map binding</strong>: <code>host: &#123;&#39;[class]&#39;: &#39;classExpr&#39;&#125; or host: &#123;&#39;[style]&#39;: &#39;styleExpr&#39;&#125;</code></li>\n<li><strong>Static value</strong>: <code>host: &#123;&#39;class&#39;: &#39;foo&#39;&#125; or host: &#123;&#39;style&#39;: &#39;color: blue&#39;&#125;</code></li>\n</ol>\n</li>\n</ol>\n<p>可以看到 CSS class 或 style 越具體其優先級就越高，綁定到特定 CSS class（[class.foo]）會優先於通用 [class] 的綁定，而通用 [class] 的綁定又會優先於特定樣式綁定（[style.bar]），而他又會優先於通用 [style]  的綁定。</p>\n<h1 id=\"Two-way-binding\"><a href=\"#Two-way-binding\" class=\"headerlink\" title=\"Two-way binding\"></a>Two-way binding</h1><p>介紹完 attribute, class, style binding 後，接著要來介紹另一個非常常用的 binding 方法 <code>Two-way binding</code>，還記得在前幾天介紹的 @Input() 與 @Output() 嗎？在父層的 HTML 中如果要傳遞數據給子層，需要將父層的 property 利用 porperty binding 將它放入中括號 ( [ ] ) 中傳遞給子層，而父層要接受子層傳遞的數據時，需要利用 event binding 將子層的 EventEmitter 放括號中，當子層傳遞數據時觸發父層中綁定的 method</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-childComponent</span> [<span class=\"attr\">inputData</span>]=<span class=\"string\">&quot;inputData&quot;</span> (<span class=\"attr\">outputData</span>)=<span class=\"string\">&quot;onChildOutpu($event)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-childComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210805/20124767zQSQyFVxiV.png\"></p>\n<p>所以如果同一個子層同時要有 @Input() 與 @Output() 那就會把他家的很長不太好看，所以 Angular  提供了 <code>Two-way binding</code>，將 property binding 與 event binding 整合再一起，語法是將方括號與圓括號組合再一起 <code>[()]</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-sizer</span> [(<span class=\"attr\">size</span>)]=<span class=\"string\">&quot;fontSizePx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-sizer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"How-two-way-binding-works\"><a href=\"#How-two-way-binding-works\" class=\"headerlink\" title=\"How two-way binding works\"></a>How two-way binding works</h1><p>要讓 Two-way binding 可以正常運作需要將 @Output() property 使用 <code>inputChange</code> 模式，其中 input 是 @Input() 的名稱，舉例來說當你的 @Input() 命名為 size 則要將 @Output() 命名為 sizeChange，讓我們舉個例吧</p>\n<ol>\n<li><p>在 child.component.ts 中建立一個 @Input() 屬性 size 與 @Output() 屬性 sizeChange 並加入三個 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span>, <span class=\"title class_\">Input</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-child&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./child.component.html&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">styleUrls</span>: [<span class=\"string\">&#x27;./child.component.css&#x27;</span>],</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChildComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Input</span>() size!: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;                             <span class=\"comment\">// (1)</span></span><br><span class=\"line\">  <span class=\"meta\">@Output</span>() sizeChange = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;<span class=\"built_in\">number</span>&gt;();           <span class=\"comment\">// (2)</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">dec</span>(<span class=\"params\"></span>) &#123;                                                      <span class=\"comment\">// (3)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">resize</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">inc</span>(<span class=\"params\"></span>) &#123;                                                      <span class=\"comment\">// (4)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">resize</span>(+<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">resize</span>(<span class=\"params\">delta: <span class=\"built_in\">number</span></span>) &#123;                                      <span class=\"comment\">// (5)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">size</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(<span class=\"number\">40</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"number\">8</span>, +<span class=\"variable language_\">this</span>.<span class=\"property\">size</span> + delta));</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">sizeChange</span>.<span class=\"title function_\">emit</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">size</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>(1):  使用 @Input() 將 size 裝飾為父層傳遞下來的數據</li>\n<li>(2): 使用@Output() 將 sizeChange 裝飾為一個 EventEmitter 用於將數據向上傳給父層</li>\n<li>(3): 用於減小字體大小</li>\n<li>(4): 用於增加字體大小</li>\n<li>(5): 增加或減少字體大小的 method</li>\n</ul>\n</li>\n<li><p>在 child.component.html 中新增兩個按鈕用於讓使用者增加或減少字體大小，和使用 text interpolation 將 size 插入到 template 中</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;dec()&quot;</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;smaller&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;inc()&quot;</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;bigger&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> [<span class=\"attr\">style.font-size.px</span>]=<span class=\"string\">&quot;size&quot;</span>&gt;</span>FontSize: &#123;&#123;size&#125;&#125;px<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.ts 中新增一個 property </p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-parent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./parent.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParentComponent</span> &#123;</span><br><span class=\"line\">  frontSizePx = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 parent.component.html 中將 frontSizePx 使用 Two-way binding 綁定給子層</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child</span> [(<span class=\"attr\">size</span>)]=<span class=\"string\">&quot;fontSizePx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">style.font-size.px</span>]=<span class=\"string\">&quot;fontSizePx&quot;</span>&gt;</span>Resizable Text<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://i.imgur.com/oKbjOZJ.gif\" alt=\"img\"><br>在畫面中可以看到，當我們點擊畫面中的 button 後，首先先讓子層向父層傳遞更改的大小，父層收到後再透過 @Input() 將變更的大小傳遞回子層讓子層可以顯示出 FontSize 的數值，這又就可以透過一個綁定就完成需要 @Input() 與 @Output() 的情況。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本章中介紹了什麼最後的兩種綁定模式，可以使用 attribute binding 對沒有 property 的 HTML 元件動態綁定，可以使用 class binding 對一個 HTML 元件綁定一個或多個 CSS class，可以使用 style binding 對一個 HTML 元件綁定一個或多個樣式，而 CSS class 與 style 的綁定優先級遵守越具體其優先級就越高的概念。</p>\n<p>第二種介紹了 Two-way binding，如何透過一種綁定就達成 property binding 與 event binding，要注意的是如果要讓 Two-way binding 成功作用必須將 @Output() 麼名稱設定為 @Input() 的名稱加上Change。</p>\n<p>下一篇將會介紹 <code>Template variables</code>，他可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，詳細的內容就留到明天在介紹吧，那我們明天見。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/attribute-binding\">Angular.io - Attribute, class, and style bindings</a></li>\n<li><a href=\"https://angular.io/guide/two-way-binding\">Angular.io - Two-way binding</a></li>\n<li><a href=\"https://jimmyswebnote.com/html-attributes-and-dom-properties/\">HTML Attributes 與 DOM Properties 的區別</a></li>\n<li><a href=\"https://www.elegantthemes.com/blog/wordpress/what-is-an-svg-file-and-how-do-you-use-it\">What is an SVG File (And How Do You Use it)?</a></li>\n<li><a href=\"https://www.w3.org/WAI/standards-guidelines/aria/\">WAI-ARIA Overview</a></li>\n</ul>"},{"title":"angular-12","date":"2021-09-12T06:07:10.000Z","_content":"\nTemplate variable 可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，例如響應使用者的輸入或微調應用程序的表單，簡單來說當你在畫面中有一個 `<input>`，除了透過 Form 獲得使用者在這個 `<input>` 所以輸入的數據之外，也可以透過將這個 `<input>` 設定為 template variable，這樣就可以讓在別的地方的 `<button>` 中的 event binding 獲得這個 `<input>` 的數據，詳細的內容讓我們繼續看下去吧。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png)\n\n<!-- more -->\n\n# Syntax\n\n要將 template 中的元件聲明為 template variable，需要在這個元件上加上`哈希符號 #`，舉個例子\n\n```html\n<input #phone placeholder=\"phone number\" />\n\n<!-- lots of other elements -->\n\n<!-- phone refers to the input element; pass its `value` to an event handler -->\n<button (click)=\"callPhone(phone.value)\">Call</button>\n```\n\n雖然在 template 中 `<button>` 離 `<input>` 很遠，但因為`<input>` 透過 # 被標記為 template variable，所以遠處的 `<button>` 可以透過呼叫 phone.value 獲取這個 `<input>` 的值。\n\n\n# How Angular assigns values to template variables\n\n了解了 template variable 後，接著要來介紹 Angular 是如何根據你聲明變量的位置為 template variable 分配一個值：\n\n- 如果在 component 的 selector 上聲明變量，則是指這個 component 的 instance\n- 如果在標準 HTML element 上聲明變量，則是指這個 HTML 的 element\n- 如果在 `<ng-template>` 上聲明變量，則該變量引用一個 `TemplateRef` 的 instance，它代表著這個 template，這個之後會詳細介紹\n- 如果在變量右邊指定了一個名稱，例如 `#var=\"ngModel\"，則該變量引用匹配 ngModel 名稱 (exportAs name) 的元素上的 directive 或 component\n\n## Using NgForm with template variables\n\n在大多數情況下，Angular 將 template varibale 的值設置為他出現的元素，比如上面的例子，phone 是指 `<input>`，而點擊了按鈕則會將 `<input>` 的內容傳遞給 component 中的 callPhone() method。\n\n不過也可以透過在變量右邊指定一個名稱達到其他的效果，比如說可以使用 NgForm directive 來達到 Form 的效果，他通過引用 directive 的 exportAs name 來獲取對不同值得引用，來舉個例子吧\n\n1. 在 app.component.ts 中加入 property 與 method\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n    })\n    export class AppComponent {\n      submitMessage: string = '';                 // (1)\n\n      onSubmit($event: any) {                     // (2)\n        this.submitMessage = $event.form.value.name;\n      }\n    }\n    ```\n\n    - (1): 新增 property 用於在畫面中顯示 `<input>` 的值\n    - (2): 新增一個 method 用於當使用者點擊按鈕時觸發\n2. 在 app.component.html 中添加 `<form>`\n\n    ```html\n    <!-- app.component.html -->\n\n    <form #itemForm=\"ngForm\" (ngSubmit)=\"onSubmit(itemForm)\">\n      <label for=\"name\"\n        >Name <input class=\"form-control\" name=\"name\" ngModel required />\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n\n    <div [hidden]=\"!itemForm.form.valid\">\n      <p>{{ submitMessage }}</p>\n    </div>\n    ```\n    \n![img](https://i.imgur.com/ZhvCzuM.gif)\n\n如果沒有在 #itemForm 右邊使用 `ngForm` 則 #itemForm 的引用值將是 `HTMLFormElement` 的 `<form>` 元件，但這邊是使用了 `ngForm` 所以 #itemForm 是對 NgForm directive 的引用，他可以跟蹤表單中的每一個可控制元件的值和有效性，這與原生的 `<form>` 元素不同，NgForm directive 中有一個 property，他用於檢測整個表單的有效性，所以當 itemForm.form.valid 無效時，則整個 NgForm 會將 submit 按鈕 disable。\n\n\n# Template variable scope\n\n既然提到 variable 就不免俗的要提到 scope，至於什麼是 scope？簡單來說 `scope 就是一個變數的生存範圍，一但超出了這個範圍就無法存取到這個變數` 至於詳細的內容可以看我這一篇 [[JS] You Don't Know JavaScript [Scope & Closures] - What is Scope?](https://ithelp.ithome.com.tw/articles/10249231) 文章中有詳細的介紹什麼是 scope。\n\n而 template variable 則可以在 template 中的任何一個位置中調用到，但是 `Structural directive` （*ngIf, *ngFor, `<ng-template>` ...） 他會充當 template 的邊界，所以你會無法訪問到 Structural directive 內部的 template variable。\n\n## Accessing in a nested template\n\n就如同 Javascript 的 scope 一樣，template 中內部的 template 可以訪問外部 template 的變量，但相反的話不行，舉個在同層級的例子\n\n```html\n<input #ref1 type=\"text\" [(ngModel)]=\"firstExample\" />\n<span *ngIf=\"true\">Value: {{ ref1.value }}</span> \n```\n\n 當更改了 `<input>` 的內容時會立即更改 `<span>` 中的內容，因為 Angular 會立即通過 template variable ref1 來更新內容，接著再舉一個由內部訪問到外部變量的例子\n\n```html\n<input #ref1 type=\"text\" [(ngModel)]=\"firstExample\" />\n\n<!-- New template -->\n<ng-template [ngIf]=\"true\">\n  <!-- Because the context is inherited, the value is available to the new template -->\n  <span>Value: {{ ref1.value }}</span>\n</ng-template>\n```\n\n像上面提到的，`<ng-template>` 會創造一個新的 template 範圍，但是因為在這個新的 template 範圍中的 `<span>` 是從內部訪問外部的變量 ref1，所以是可以正常訪問到的，就跟 Javascript  一樣\n\n```javascript\nconst ref1 = 'input value';\n\nfunction spanValue() {\n\tconsole.log(ref1); // input value\n}\n```\n\n雖然 ref1 與 function spanValue 是不同的 scope，但因為內部可以訪問外部變量，所以可以將 ref1 給 console 出來，接著來看父層如果訪問子層變量會發生什麼事\n\n```html\n<ng-template [ngIf]=\"true\">\n  <!-- The reference is defined within a template -->\n  <input #ref2 type=\"text\" [(ngModel)]=\"secondExample\" />\n</ng-template>\n<!-- ref2 accessed from outside that template doesn't work -->\n<span>Value: {{ ref2?.value }}</span>\n```\n\n如果是上面例子的情況，`<span>` 會無法獲得 ref2 的內容，因為對於 ref2 來說他是存在於子層的變量，所以無法透過父層呼叫到，就跟 Javascript 一樣\n\n```javascript\nfunction inputScope() {\n    let ref2 = 'in child scope';\n}\n\nconsole.log(ref2);  // Uncaught ReferenceError: ref2 is not defined\n```\n\n外部無法呼叫到內部 scope 的變量，所以在使用 template variable 時要記得存取變量的規則， `外部 scope 無法存取到內部 scope 的變量`。\n\n\n# 結論\n\n本章中介紹了什麼是 template variable 與他的使用方法，簡單來說就是可以利用他獲得其他 element 的內容，不過因為他也是屬於變量所以也會有 scope 的問題，要記住外部 scope 是無法訪問到內部 scope 的變量的，而使用了 `Structural directive` 則會創造一個獨立的 template 讓整個 template 出現父子層的現象，就跟在 javescript 中使用 function 建立 function scope  一樣，所以要特別注意。\n\n而本篇也是講解 template 的最後一篇，明天開始將會進入到 directive，這個觀念在前面多多少少都有提到一點，但沒關係之後會詳細地對他進行講解，那我們就明天見吧。\n\n---\n\n# Reference\n\n- [Angular.io](https://angular.io/guide/template-reference-variables)","source":"_posts/Angular/angular-12.md","raw":"---\ntitle: angular-12\ndate: 2021-09-12 14:07:10\ntags:\n- Angular\n- Front-end\n\ncategories:\n- 2021 鐵人賽\n---\n\nTemplate variable 可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，例如響應使用者的輸入或微調應用程序的表單，簡單來說當你在畫面中有一個 `<input>`，除了透過 Form 獲得使用者在這個 `<input>` 所以輸入的數據之外，也可以透過將這個 `<input>` 設定為 template variable，這樣就可以讓在別的地方的 `<button>` 中的 event binding 獲得這個 `<input>` 的數據，詳細的內容讓我們繼續看下去吧。\n\n![https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png](https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png)\n\n<!-- more -->\n\n# Syntax\n\n要將 template 中的元件聲明為 template variable，需要在這個元件上加上`哈希符號 #`，舉個例子\n\n```html\n<input #phone placeholder=\"phone number\" />\n\n<!-- lots of other elements -->\n\n<!-- phone refers to the input element; pass its `value` to an event handler -->\n<button (click)=\"callPhone(phone.value)\">Call</button>\n```\n\n雖然在 template 中 `<button>` 離 `<input>` 很遠，但因為`<input>` 透過 # 被標記為 template variable，所以遠處的 `<button>` 可以透過呼叫 phone.value 獲取這個 `<input>` 的值。\n\n\n# How Angular assigns values to template variables\n\n了解了 template variable 後，接著要來介紹 Angular 是如何根據你聲明變量的位置為 template variable 分配一個值：\n\n- 如果在 component 的 selector 上聲明變量，則是指這個 component 的 instance\n- 如果在標準 HTML element 上聲明變量，則是指這個 HTML 的 element\n- 如果在 `<ng-template>` 上聲明變量，則該變量引用一個 `TemplateRef` 的 instance，它代表著這個 template，這個之後會詳細介紹\n- 如果在變量右邊指定了一個名稱，例如 `#var=\"ngModel\"，則該變量引用匹配 ngModel 名稱 (exportAs name) 的元素上的 directive 或 component\n\n## Using NgForm with template variables\n\n在大多數情況下，Angular 將 template varibale 的值設置為他出現的元素，比如上面的例子，phone 是指 `<input>`，而點擊了按鈕則會將 `<input>` 的內容傳遞給 component 中的 callPhone() method。\n\n不過也可以透過在變量右邊指定一個名稱達到其他的效果，比如說可以使用 NgForm directive 來達到 Form 的效果，他通過引用 directive 的 exportAs name 來獲取對不同值得引用，來舉個例子吧\n\n1. 在 app.component.ts 中加入 property 與 method\n\n    ```typescript\n    import { Component } from '@angular/core';\n\n    @Component({\n      selector: 'app-root',\n      templateUrl: './app.component.html',\n    })\n    export class AppComponent {\n      submitMessage: string = '';                 // (1)\n\n      onSubmit($event: any) {                     // (2)\n        this.submitMessage = $event.form.value.name;\n      }\n    }\n    ```\n\n    - (1): 新增 property 用於在畫面中顯示 `<input>` 的值\n    - (2): 新增一個 method 用於當使用者點擊按鈕時觸發\n2. 在 app.component.html 中添加 `<form>`\n\n    ```html\n    <!-- app.component.html -->\n\n    <form #itemForm=\"ngForm\" (ngSubmit)=\"onSubmit(itemForm)\">\n      <label for=\"name\"\n        >Name <input class=\"form-control\" name=\"name\" ngModel required />\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n\n    <div [hidden]=\"!itemForm.form.valid\">\n      <p>{{ submitMessage }}</p>\n    </div>\n    ```\n    \n![img](https://i.imgur.com/ZhvCzuM.gif)\n\n如果沒有在 #itemForm 右邊使用 `ngForm` 則 #itemForm 的引用值將是 `HTMLFormElement` 的 `<form>` 元件，但這邊是使用了 `ngForm` 所以 #itemForm 是對 NgForm directive 的引用，他可以跟蹤表單中的每一個可控制元件的值和有效性，這與原生的 `<form>` 元素不同，NgForm directive 中有一個 property，他用於檢測整個表單的有效性，所以當 itemForm.form.valid 無效時，則整個 NgForm 會將 submit 按鈕 disable。\n\n\n# Template variable scope\n\n既然提到 variable 就不免俗的要提到 scope，至於什麼是 scope？簡單來說 `scope 就是一個變數的生存範圍，一但超出了這個範圍就無法存取到這個變數` 至於詳細的內容可以看我這一篇 [[JS] You Don't Know JavaScript [Scope & Closures] - What is Scope?](https://ithelp.ithome.com.tw/articles/10249231) 文章中有詳細的介紹什麼是 scope。\n\n而 template variable 則可以在 template 中的任何一個位置中調用到，但是 `Structural directive` （*ngIf, *ngFor, `<ng-template>` ...） 他會充當 template 的邊界，所以你會無法訪問到 Structural directive 內部的 template variable。\n\n## Accessing in a nested template\n\n就如同 Javascript 的 scope 一樣，template 中內部的 template 可以訪問外部 template 的變量，但相反的話不行，舉個在同層級的例子\n\n```html\n<input #ref1 type=\"text\" [(ngModel)]=\"firstExample\" />\n<span *ngIf=\"true\">Value: {{ ref1.value }}</span> \n```\n\n 當更改了 `<input>` 的內容時會立即更改 `<span>` 中的內容，因為 Angular 會立即通過 template variable ref1 來更新內容，接著再舉一個由內部訪問到外部變量的例子\n\n```html\n<input #ref1 type=\"text\" [(ngModel)]=\"firstExample\" />\n\n<!-- New template -->\n<ng-template [ngIf]=\"true\">\n  <!-- Because the context is inherited, the value is available to the new template -->\n  <span>Value: {{ ref1.value }}</span>\n</ng-template>\n```\n\n像上面提到的，`<ng-template>` 會創造一個新的 template 範圍，但是因為在這個新的 template 範圍中的 `<span>` 是從內部訪問外部的變量 ref1，所以是可以正常訪問到的，就跟 Javascript  一樣\n\n```javascript\nconst ref1 = 'input value';\n\nfunction spanValue() {\n\tconsole.log(ref1); // input value\n}\n```\n\n雖然 ref1 與 function spanValue 是不同的 scope，但因為內部可以訪問外部變量，所以可以將 ref1 給 console 出來，接著來看父層如果訪問子層變量會發生什麼事\n\n```html\n<ng-template [ngIf]=\"true\">\n  <!-- The reference is defined within a template -->\n  <input #ref2 type=\"text\" [(ngModel)]=\"secondExample\" />\n</ng-template>\n<!-- ref2 accessed from outside that template doesn't work -->\n<span>Value: {{ ref2?.value }}</span>\n```\n\n如果是上面例子的情況，`<span>` 會無法獲得 ref2 的內容，因為對於 ref2 來說他是存在於子層的變量，所以無法透過父層呼叫到，就跟 Javascript 一樣\n\n```javascript\nfunction inputScope() {\n    let ref2 = 'in child scope';\n}\n\nconsole.log(ref2);  // Uncaught ReferenceError: ref2 is not defined\n```\n\n外部無法呼叫到內部 scope 的變量，所以在使用 template variable 時要記得存取變量的規則， `外部 scope 無法存取到內部 scope 的變量`。\n\n\n# 結論\n\n本章中介紹了什麼是 template variable 與他的使用方法，簡單來說就是可以利用他獲得其他 element 的內容，不過因為他也是屬於變量所以也會有 scope 的問題，要記住外部 scope 是無法訪問到內部 scope 的變量的，而使用了 `Structural directive` 則會創造一個獨立的 template 讓整個 template 出現父子層的現象，就跟在 javescript 中使用 function 建立 function scope  一樣，所以要特別注意。\n\n而本篇也是講解 template 的最後一篇，明天開始將會進入到 directive，這個觀念在前面多多少少都有提到一點，但沒關係之後會詳細地對他進行講解，那我們就明天見吧。\n\n---\n\n# Reference\n\n- [Angular.io](https://angular.io/guide/template-reference-variables)","slug":"Angular/angular-12","published":1,"updated":"2022-02-16T01:20:39.682Z","_id":"ckzov8v8x001rkww36guggd8c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Template variable 可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，例如響應使用者的輸入或微調應用程序的表單，簡單來說當你在畫面中有一個 <code>&lt;input&gt;</code>，除了透過 Form 獲得使用者在這個 <code>&lt;input&gt;</code> 所以輸入的數據之外，也可以透過將這個 <code>&lt;input&gt;</code> 設定為 template variable，這樣就可以讓在別的地方的 <code>&lt;button&gt;</code> 中的 event binding 獲得這個 <code>&lt;input&gt;</code> 的數據，詳細的內容讓我們繼續看下去吧。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Syntax\"><a href=\"#Syntax\" class=\"headerlink\" title=\"Syntax\"></a>Syntax</h1><p>要將 template 中的元件聲明為 template variable，需要在這個元件上加上<code>哈希符號 #</code>，舉個例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">phone</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;phone number&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- lots of other elements --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;callPhone(phone.value)&quot;</span>&gt;</span>Call<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>雖然在 template 中 <code>&lt;button&gt;</code> 離 <code>&lt;input&gt;</code> 很遠，但因為<code>&lt;input&gt;</code> 透過 # 被標記為 template variable，所以遠處的 <code>&lt;button&gt;</code> 可以透過呼叫 phone.value 獲取這個 <code>&lt;input&gt;</code> 的值。</p>\n<h1 id=\"How-Angular-assigns-values-to-template-variables\"><a href=\"#How-Angular-assigns-values-to-template-variables\" class=\"headerlink\" title=\"How Angular assigns values to template variables\"></a>How Angular assigns values to template variables</h1><p>了解了 template variable 後，接著要來介紹 Angular 是如何根據你聲明變量的位置為 template variable 分配一個值：</p>\n<ul>\n<li>如果在 component 的 selector 上聲明變量，則是指這個 component 的 instance</li>\n<li>如果在標準 HTML element 上聲明變量，則是指這個 HTML 的 element</li>\n<li>如果在 <code>&lt;ng-template&gt;</code> 上聲明變量，則該變量引用一個 <code>TemplateRef</code> 的 instance，它代表著這個 template，這個之後會詳細介紹</li>\n<li>如果在變量右邊指定了一個名稱，例如 &#96;#var&#x3D;”ngModel”，則該變量引用匹配 ngModel 名稱 (exportAs name) 的元素上的 directive 或 component</li>\n</ul>\n<h2 id=\"Using-NgForm-with-template-variables\"><a href=\"#Using-NgForm-with-template-variables\" class=\"headerlink\" title=\"Using NgForm with template variables\"></a>Using NgForm with template variables</h2><p>在大多數情況下，Angular 將 template varibale 的值設置為他出現的元素，比如上面的例子，phone 是指 <code>&lt;input&gt;</code>，而點擊了按鈕則會將 <code>&lt;input&gt;</code> 的內容傳遞給 component 中的 callPhone() method。</p>\n<p>不過也可以透過在變量右邊指定一個名稱達到其他的效果，比如說可以使用 NgForm directive 來達到 Form 的效果，他通過引用 directive 的 exportAs name 來獲取對不同值得引用，來舉個例子吧</p>\n<ol>\n<li><p>在 app.component.ts 中加入 property 與 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">submitMessage</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;&#x27;</span>;                 <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onSubmit</span>(<span class=\"params\">$event: <span class=\"built_in\">any</span></span>) &#123;                     <span class=\"comment\">// (2)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">submitMessage</span> = $event.<span class=\"property\">form</span>.<span class=\"property\">value</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>(1): 新增 property 用於在畫面中顯示 <code>&lt;input&gt;</code> 的值</li>\n<li>(2): 新增一個 method 用於當使用者點擊按鈕時觸發</li>\n</ul>\n</li>\n<li><p>在 app.component.html 中添加 <code>&lt;form&gt;</code></p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">itemForm</span>=<span class=\"string\">&quot;ngForm&quot;</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">&quot;onSubmit(itemForm)&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;name&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span>Name <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;form-control&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">required</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!itemForm.form.valid&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; submitMessage &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://i.imgur.com/ZhvCzuM.gif\" alt=\"img\"></p>\n<p>如果沒有在 #itemForm 右邊使用 <code>ngForm</code> 則 #itemForm 的引用值將是 <code>HTMLFormElement</code> 的 <code>&lt;form&gt;</code> 元件，但這邊是使用了 <code>ngForm</code> 所以 #itemForm 是對 NgForm directive 的引用，他可以跟蹤表單中的每一個可控制元件的值和有效性，這與原生的 <code>&lt;form&gt;</code> 元素不同，NgForm directive 中有一個 property，他用於檢測整個表單的有效性，所以當 itemForm.form.valid 無效時，則整個 NgForm 會將 submit 按鈕 disable。</p>\n<h1 id=\"Template-variable-scope\"><a href=\"#Template-variable-scope\" class=\"headerlink\" title=\"Template variable scope\"></a>Template variable scope</h1><p>既然提到 variable 就不免俗的要提到 scope，至於什麼是 scope？簡單來說 <code>scope 就是一個變數的生存範圍，一但超出了這個範圍就無法存取到這個變數</code> 至於詳細的內容可以看我這一篇 <a href=\"https://ithelp.ithome.com.tw/articles/10249231\">[JS] You Don’t Know JavaScript [Scope &amp; Closures] - What is Scope?</a> 文章中有詳細的介紹什麼是 scope。</p>\n<p>而 template variable 則可以在 template 中的任何一個位置中調用到，但是 <code>Structural directive</code> （*ngIf, *ngFor, <code>&lt;ng-template&gt;</code> …） 他會充當 template 的邊界，所以你會無法訪問到 Structural directive 內部的 template variable。</p>\n<h2 id=\"Accessing-in-a-nested-template\"><a href=\"#Accessing-in-a-nested-template\" class=\"headerlink\" title=\"Accessing in a nested template\"></a>Accessing in a nested template</h2><p>就如同 Javascript 的 scope 一樣，template 中內部的 template 可以訪問外部 template 的變量，但相反的話不行，舉個在同層級的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">ref1</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;firstExample&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span>Value: &#123;&#123; ref1.value &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p> 當更改了 <code>&lt;input&gt;</code> 的內容時會立即更改 <code>&lt;span&gt;</code> 中的內容，因為 Angular 會立即通過 template variable ref1 來更新內容，接著再舉一個由內部訪問到外部變量的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">ref1</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;firstExample&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- New template --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-template</span> [<span class=\"attr\">ngIf</span>]=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- Because the context is inherited, the value is available to the new template --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Value: &#123;&#123; ref1.value &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>像上面提到的，<code>&lt;ng-template&gt;</code> 會創造一個新的 template 範圍，但是因為在這個新的 template 範圍中的 <code>&lt;span&gt;</code> 是從內部訪問外部的變量 ref1，所以是可以正常訪問到的，就跟 Javascript  一樣</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ref1 = <span class=\"string\">&#x27;input value&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spanValue</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(ref1); <span class=\"comment\">// input value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>雖然 ref1 與 function spanValue 是不同的 scope，但因為內部可以訪問外部變量，所以可以將 ref1 給 console 出來，接著來看父層如果訪問子層變量會發生什麼事</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-template</span> [<span class=\"attr\">ngIf</span>]=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- The reference is defined within a template --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">ref2</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;secondExample&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ng-template</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ref2 accessed from outside that template doesn&#x27;t work --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Value: &#123;&#123; ref2?.value &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果是上面例子的情況，<code>&lt;span&gt;</code> 會無法獲得 ref2 的內容，因為對於 ref2 來說他是存在於子層的變量，所以無法透過父層呼叫到，就跟 Javascript 一樣</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inputScope</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref2 = <span class=\"string\">&#x27;in child scope&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(ref2);  <span class=\"comment\">// Uncaught ReferenceError: ref2 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>外部無法呼叫到內部 scope 的變量，所以在使用 template variable 時要記得存取變量的規則， <code>外部 scope 無法存取到內部 scope 的變量</code>。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本章中介紹了什麼是 template variable 與他的使用方法，簡單來說就是可以利用他獲得其他 element 的內容，不過因為他也是屬於變量所以也會有 scope 的問題，要記住外部 scope 是無法訪問到內部 scope 的變量的，而使用了 <code>Structural directive</code> 則會創造一個獨立的 template 讓整個 template 出現父子層的現象，就跟在 javescript 中使用 function 建立 function scope  一樣，所以要特別注意。</p>\n<p>而本篇也是講解 template 的最後一篇，明天開始將會進入到 directive，這個觀念在前面多多少少都有提到一點，但沒關係之後會詳細地對他進行講解，那我們就明天見吧。</p>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/template-reference-variables\">Angular.io</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Template variable 可以讓你在 template 的任意一處使用被標記過的 HTML 元件的數據，例如響應使用者的輸入或微調應用程序的表單，簡單來說當你在畫面中有一個 <code>&lt;input&gt;</code>，除了透過 Form 獲得使用者在這個 <code>&lt;input&gt;</code> 所以輸入的數據之外，也可以透過將這個 <code>&lt;input&gt;</code> 設定為 template variable，這樣就可以讓在別的地方的 <code>&lt;button&gt;</code> 中的 event binding 獲得這個 <code>&lt;input&gt;</code> 的數據，詳細的內容讓我們繼續看下去吧。</p>\n<p><img src=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png\" alt=\"https://ithelp.ithome.com.tw/upload/images/20210821/20124767lMmC7T1IVB.png\"></p>","more":"<h1 id=\"Syntax\"><a href=\"#Syntax\" class=\"headerlink\" title=\"Syntax\"></a>Syntax</h1><p>要將 template 中的元件聲明為 template variable，需要在這個元件上加上<code>哈希符號 #</code>，舉個例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">phone</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;phone number&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- lots of other elements --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;callPhone(phone.value)&quot;</span>&gt;</span>Call<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>雖然在 template 中 <code>&lt;button&gt;</code> 離 <code>&lt;input&gt;</code> 很遠，但因為<code>&lt;input&gt;</code> 透過 # 被標記為 template variable，所以遠處的 <code>&lt;button&gt;</code> 可以透過呼叫 phone.value 獲取這個 <code>&lt;input&gt;</code> 的值。</p>\n<h1 id=\"How-Angular-assigns-values-to-template-variables\"><a href=\"#How-Angular-assigns-values-to-template-variables\" class=\"headerlink\" title=\"How Angular assigns values to template variables\"></a>How Angular assigns values to template variables</h1><p>了解了 template variable 後，接著要來介紹 Angular 是如何根據你聲明變量的位置為 template variable 分配一個值：</p>\n<ul>\n<li>如果在 component 的 selector 上聲明變量，則是指這個 component 的 instance</li>\n<li>如果在標準 HTML element 上聲明變量，則是指這個 HTML 的 element</li>\n<li>如果在 <code>&lt;ng-template&gt;</code> 上聲明變量，則該變量引用一個 <code>TemplateRef</code> 的 instance，它代表著這個 template，這個之後會詳細介紹</li>\n<li>如果在變量右邊指定了一個名稱，例如 &#96;#var&#x3D;”ngModel”，則該變量引用匹配 ngModel 名稱 (exportAs name) 的元素上的 directive 或 component</li>\n</ul>\n<h2 id=\"Using-NgForm-with-template-variables\"><a href=\"#Using-NgForm-with-template-variables\" class=\"headerlink\" title=\"Using NgForm with template variables\"></a>Using NgForm with template variables</h2><p>在大多數情況下，Angular 將 template varibale 的值設置為他出現的元素，比如上面的例子，phone 是指 <code>&lt;input&gt;</code>，而點擊了按鈕則會將 <code>&lt;input&gt;</code> 的內容傳遞給 component 中的 callPhone() method。</p>\n<p>不過也可以透過在變量右邊指定一個名稱達到其他的效果，比如說可以使用 NgForm directive 來達到 Form 的效果，他通過引用 directive 的 exportAs name 來獲取對不同值得引用，來舉個例子吧</p>\n<ol>\n<li><p>在 app.component.ts 中加入 property 與 method</p>\n <figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;app-root&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">templateUrl</span>: <span class=\"string\">&#x27;./app.component.html&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">submitMessage</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&#x27;&#x27;</span>;                 <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">onSubmit</span>(<span class=\"params\">$event: <span class=\"built_in\">any</span></span>) &#123;                     <span class=\"comment\">// (2)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">submitMessage</span> = $event.<span class=\"property\">form</span>.<span class=\"property\">value</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>(1): 新增 property 用於在畫面中顯示 <code>&lt;input&gt;</code> 的值</li>\n<li>(2): 新增一個 method 用於當使用者點擊按鈕時觸發</li>\n</ul>\n</li>\n<li><p>在 app.component.html 中添加 <code>&lt;form&gt;</code></p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- app.component.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">itemForm</span>=<span class=\"string\">&quot;ngForm&quot;</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">&quot;onSubmit(itemForm)&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;name&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span>Name <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;form-control&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">required</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!itemForm.form.valid&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; submitMessage &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://i.imgur.com/ZhvCzuM.gif\" alt=\"img\"></p>\n<p>如果沒有在 #itemForm 右邊使用 <code>ngForm</code> 則 #itemForm 的引用值將是 <code>HTMLFormElement</code> 的 <code>&lt;form&gt;</code> 元件，但這邊是使用了 <code>ngForm</code> 所以 #itemForm 是對 NgForm directive 的引用，他可以跟蹤表單中的每一個可控制元件的值和有效性，這與原生的 <code>&lt;form&gt;</code> 元素不同，NgForm directive 中有一個 property，他用於檢測整個表單的有效性，所以當 itemForm.form.valid 無效時，則整個 NgForm 會將 submit 按鈕 disable。</p>\n<h1 id=\"Template-variable-scope\"><a href=\"#Template-variable-scope\" class=\"headerlink\" title=\"Template variable scope\"></a>Template variable scope</h1><p>既然提到 variable 就不免俗的要提到 scope，至於什麼是 scope？簡單來說 <code>scope 就是一個變數的生存範圍，一但超出了這個範圍就無法存取到這個變數</code> 至於詳細的內容可以看我這一篇 <a href=\"https://ithelp.ithome.com.tw/articles/10249231\">[JS] You Don’t Know JavaScript [Scope &amp; Closures] - What is Scope?</a> 文章中有詳細的介紹什麼是 scope。</p>\n<p>而 template variable 則可以在 template 中的任何一個位置中調用到，但是 <code>Structural directive</code> （*ngIf, *ngFor, <code>&lt;ng-template&gt;</code> …） 他會充當 template 的邊界，所以你會無法訪問到 Structural directive 內部的 template variable。</p>\n<h2 id=\"Accessing-in-a-nested-template\"><a href=\"#Accessing-in-a-nested-template\" class=\"headerlink\" title=\"Accessing in a nested template\"></a>Accessing in a nested template</h2><p>就如同 Javascript 的 scope 一樣，template 中內部的 template 可以訪問外部 template 的變量，但相反的話不行，舉個在同層級的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">ref1</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;firstExample&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span>Value: &#123;&#123; ref1.value &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p> 當更改了 <code>&lt;input&gt;</code> 的內容時會立即更改 <code>&lt;span&gt;</code> 中的內容，因為 Angular 會立即通過 template variable ref1 來更新內容，接著再舉一個由內部訪問到外部變量的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">ref1</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;firstExample&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- New template --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-template</span> [<span class=\"attr\">ngIf</span>]=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- Because the context is inherited, the value is available to the new template --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Value: &#123;&#123; ref1.value &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>像上面提到的，<code>&lt;ng-template&gt;</code> 會創造一個新的 template 範圍，但是因為在這個新的 template 範圍中的 <code>&lt;span&gt;</code> 是從內部訪問外部的變量 ref1，所以是可以正常訪問到的，就跟 Javascript  一樣</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ref1 = <span class=\"string\">&#x27;input value&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spanValue</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(ref1); <span class=\"comment\">// input value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>雖然 ref1 與 function spanValue 是不同的 scope，但因為內部可以訪問外部變量，所以可以將 ref1 給 console 出來，接著來看父層如果訪問子層變量會發生什麼事</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-template</span> [<span class=\"attr\">ngIf</span>]=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- The reference is defined within a template --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">ref2</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">&quot;secondExample&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ng-template</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ref2 accessed from outside that template doesn&#x27;t work --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Value: &#123;&#123; ref2?.value &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果是上面例子的情況，<code>&lt;span&gt;</code> 會無法獲得 ref2 的內容，因為對於 ref2 來說他是存在於子層的變量，所以無法透過父層呼叫到，就跟 Javascript 一樣</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inputScope</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref2 = <span class=\"string\">&#x27;in child scope&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(ref2);  <span class=\"comment\">// Uncaught ReferenceError: ref2 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>外部無法呼叫到內部 scope 的變量，所以在使用 template variable 時要記得存取變量的規則， <code>外部 scope 無法存取到內部 scope 的變量</code>。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>本章中介紹了什麼是 template variable 與他的使用方法，簡單來說就是可以利用他獲得其他 element 的內容，不過因為他也是屬於變量所以也會有 scope 的問題，要記住外部 scope 是無法訪問到內部 scope 的變量的，而使用了 <code>Structural directive</code> 則會創造一個獨立的 template 讓整個 template 出現父子層的現象，就跟在 javescript 中使用 function 建立 function scope  一樣，所以要特別注意。</p>\n<p>而本篇也是講解 template 的最後一篇，明天開始將會進入到 directive，這個觀念在前面多多少少都有提到一點，但沒關係之後會詳細地對他進行講解，那我們就明天見吧。</p>\n<hr>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://angular.io/guide/template-reference-variables\">Angular.io</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckznurmnj0009kww3b3tea85s","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmnm000fkww36nhgh1ty"},{"post_id":"ckznurmnd0003kww31d731dhn","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmno000kkww32ka45yid"},{"post_id":"ckznurmnj000akww3d6dx9lih","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmno000mkww3189gg27m"},{"post_id":"ckznurmnl000dkww36xbj5wov","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmno000pkww353rn6e1p"},{"post_id":"ckznurmnf0005kww34lwjc1u9","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmnp000rkww359y38gxh"},{"post_id":"ckznurmnm000ekww3ehqsfmtv","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmnp000ukww3e0ed3bcv"},{"post_id":"ckznurmnn000jkww3et9t3tk5","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmnp000wkww3ew0m36ee"},{"post_id":"ckznurmni0008kww31ns71pgf","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznurmnp000zkww30ntbdfcb"},{"post_id":"ckznus5dt001ckww30je6escn","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznutj2v001fkww30ykceauw"},{"post_id":"ckznuvv3o001hkww3bs3y8xyp","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznv06xs001kkww3c67rd4lz"},{"post_id":"ckznz1lmg001mkww3bld65c2x","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckznz28bx001pkww38sy99489"},{"post_id":"ckzov8v8x001rkww36guggd8c","category_id":"ckznurmng0006kww3cwxhe6la","_id":"ckzovav9j001ukww37dl33pfx"}],"PostTag":[{"post_id":"ckznurmnl000dkww36xbj5wov","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnn000ikww39uba2hg6"},{"post_id":"ckznurmnl000dkww36xbj5wov","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmno000lkww3eu0470bb"},{"post_id":"ckznurmnd0003kww31d731dhn","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmno000okww35kwqf40t"},{"post_id":"ckznurmnd0003kww31d731dhn","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnp000qkww32uv7c0ir"},{"post_id":"ckznurmnm000ekww3ehqsfmtv","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnp000tkww35aed2lqq"},{"post_id":"ckznurmnm000ekww3ehqsfmtv","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnp000vkww33ercbtum"},{"post_id":"ckznurmnn000jkww3et9t3tk5","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnp000ykww30qc3bcpb"},{"post_id":"ckznurmnn000jkww3et9t3tk5","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnq0010kww39p0t8azc"},{"post_id":"ckznurmnf0005kww34lwjc1u9","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnq0012kww3clt85cs0"},{"post_id":"ckznurmnf0005kww34lwjc1u9","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnq0013kww39af5gplh"},{"post_id":"ckznurmni0008kww31ns71pgf","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnq0015kww3aiwc3mwc"},{"post_id":"ckznurmni0008kww31ns71pgf","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnr0016kww34xi98am5"},{"post_id":"ckznurmnj0009kww3b3tea85s","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnr0017kww3elny06ge"},{"post_id":"ckznurmnj0009kww3b3tea85s","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnr0018kww3eki179d3"},{"post_id":"ckznurmnj000akww3d6dx9lih","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznurmnr0019kww30mw8csit"},{"post_id":"ckznurmnj000akww3d6dx9lih","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznurmnr001akww3crij7zr1"},{"post_id":"ckznus5dt001ckww30je6escn","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznutj2u001dkww39zz76opm"},{"post_id":"ckznus5dt001ckww30je6escn","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznutj2v001ekww32paqhext"},{"post_id":"ckznuvv3o001hkww3bs3y8xyp","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznv06xr001ikww3hi34fn5p"},{"post_id":"ckznuvv3o001hkww3bs3y8xyp","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznv06xs001jkww32dmj3b0o"},{"post_id":"ckznz1lmg001mkww3bld65c2x","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckznz28bv001nkww39nhy4kwo"},{"post_id":"ckznz1lmg001mkww3bld65c2x","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckznz28bx001okww3bv0193rr"},{"post_id":"ckzov8v8x001rkww36guggd8c","tag_id":"ckznurmnh0007kww3bocnh2ry","_id":"ckzovav9i001skww3a2zjaeav"},{"post_id":"ckzov8v8x001rkww36guggd8c","tag_id":"ckznurmnk000ckww39cdhfbyk","_id":"ckzovav9j001tkww32o0m7f0u"}],"Tag":[{"name":"Angular","_id":"ckznurmnh0007kww3bocnh2ry"},{"name":"Front-end","_id":"ckznurmnk000ckww39cdhfbyk"}]}}